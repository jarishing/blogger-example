This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-07-11T07:14:04.819Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.cspell.json
.cspell/aws.txt
.cspell/nodejs.txt
.cspell/project.txt
.dockerignore
.editorconfig
.github/PULL_REQUEST_TEMPLATE.md
.github/workflows/ci.yaml
.github/workflows/deploy-to-develop.yaml
.github/workflows/release.yaml
.gitignore
.nvmrc
apps/app/.eslintrc.js
apps/app/.prettierrc.cjs
apps/app/app.ts
apps/app/controller/getApiDoc/getApiDoc.ts
apps/app/controller/getApiDoc/index.ts
apps/app/controller/getApiDoc/redoc.html
apps/app/controller/getSwaggerJson/getSwaggerJson.ts
apps/app/controller/getSwaggerJson/index.ts
apps/app/controller/getSwaggerJson/swagger.json
apps/app/controller/healthCheck.ts
apps/app/controller/index.ts
apps/app/Dockerfile
apps/app/jest.config.js
apps/app/local.ts
apps/app/package.json
apps/app/route.ts
apps/app/server.ts
apps/app/tests/api-doc.spec.ts
apps/app/tests/health-check.spec.ts
apps/app/tests/swagger-json.spec.ts
apps/app/tsconfig.json
apps/app/types/global.d.ts
apps/article/.eslintrc.js
apps/article/.prettierrc.cjs
apps/article/app.ts
apps/article/controller/addComment.ts
apps/article/controller/createArticle.ts
apps/article/controller/deleteArticle.ts
apps/article/controller/deleteComment.ts
apps/article/controller/favoriteArticle.ts
apps/article/controller/getArticle.ts
apps/article/controller/getArticles.ts
apps/article/controller/getArticleTags.ts
apps/article/controller/getComments.ts
apps/article/controller/getFeedArticles.ts
apps/article/controller/index.ts
apps/article/controller/unfavoriteArticle.ts
apps/article/controller/updateArticle.ts
apps/article/Dockerfile
apps/article/dto/DtoArticle.ts
apps/article/dto/DtoComment.ts
apps/article/dto/index.ts
apps/article/jest.config.js
apps/article/local.ts
apps/article/package.json
apps/article/route.ts
apps/article/schema/addCommentBody.ts
apps/article/schema/createArticleBody.ts
apps/article/schema/getArticleFeedQuery.ts
apps/article/schema/getArticlesQuery.ts
apps/article/schema/getCommentsQuery.ts
apps/article/schema/index.ts
apps/article/schema/updateArticleBody.ts
apps/article/server.ts
apps/article/service/ApiAddComments/ApiAddComments.ts
apps/article/service/ApiAddComments/index.ts
apps/article/service/ApiAddComments/types.ts
apps/article/service/ApiCreateArticle/ApiCreateArticle.ts
apps/article/service/ApiCreateArticle/index.ts
apps/article/service/ApiCreateArticle/types.ts
apps/article/service/ApiDeleteArticle/ApiDeleteArticle.ts
apps/article/service/ApiDeleteArticle/index.ts
apps/article/service/ApiDeleteArticle/types.ts
apps/article/service/ApiDeleteComment/ApiDeleteComment.ts
apps/article/service/ApiDeleteComment/index.ts
apps/article/service/ApiDeleteComment/types.ts
apps/article/service/ApiFavoriteArticle/ApiFavoriteArticle.ts
apps/article/service/ApiFavoriteArticle/index.ts
apps/article/service/ApiFavoriteArticle/types.ts
apps/article/service/ApiFeedArticles/ApiFeedArticles.ts
apps/article/service/ApiFeedArticles/index.ts
apps/article/service/ApiFeedArticles/types.ts
apps/article/service/ApiGetArticle/ApiGetArticle.ts
apps/article/service/ApiGetArticle/index.ts
apps/article/service/ApiGetArticle/types.ts
apps/article/service/ApiGetComments/ApiGetComments.ts
apps/article/service/ApiGetComments/index.ts
apps/article/service/ApiGetComments/types.ts
apps/article/service/ApiGetTags/ApiGetTags.ts
apps/article/service/ApiGetTags/index.ts
apps/article/service/ApiGetTags/types.ts
apps/article/service/ApiListArticles/ApiListArticles.ts
apps/article/service/ApiListArticles/index.ts
apps/article/service/ApiListArticles/types.ts
apps/article/service/ApiUnfavoriteArticle/ApiUnfavoriteArticle.ts
apps/article/service/ApiUnfavoriteArticle/index.ts
apps/article/service/ApiUnfavoriteArticle/types.ts
apps/article/service/ApiUpdateArticle/ApiUpdateArticle.ts
apps/article/service/ApiUpdateArticle/index.ts
apps/article/service/ApiUpdateArticle/types.ts
apps/article/service/Factory.ts
apps/article/service/index.ts
apps/article/tests/basic/create-article.spec.ts
apps/article/tests/basic/delete-article.spec.ts
apps/article/tests/basic/feed-articles.spec.ts
apps/article/tests/basic/get-article.spec.ts
apps/article/tests/basic/list-articles.spec.ts
apps/article/tests/basic/update-article.spec.ts
apps/article/tests/comments/add-comments.spec.ts
apps/article/tests/comments/delete-comment.spec.ts
apps/article/tests/comments/get-comments.spec.ts
apps/article/tests/favorite/favorite-article.spec.ts
apps/article/tests/favorite/unfavorite-article.spec.ts
apps/article/tests/tag/get-tags.spec.ts
apps/article/tsconfig.json
apps/article/types/global.d.ts
apps/local/.eslintrc.js
apps/local/.prettierrc.cjs
apps/local/Dockerfile
apps/local/local.ts
apps/local/package.json
apps/local/tsconfig.json
apps/local/types/global.d.ts
apps/user/.eslintrc.js
apps/user/.prettierrc.cjs
apps/user/app.ts
apps/user/constants/ErrorCodes.ts
apps/user/constants/index.ts
apps/user/controller/followUser.ts
apps/user/controller/getCurrentUser.ts
apps/user/controller/getUserProfile.ts
apps/user/controller/index.ts
apps/user/controller/login.ts
apps/user/controller/registration.ts
apps/user/controller/unfollowUser.ts
apps/user/controller/updateUser.ts
apps/user/Dockerfile
apps/user/dto/DtoProfile.ts
apps/user/dto/DtoUser.ts
apps/user/dto/index.ts
apps/user/jest.config.js
apps/user/local.ts
apps/user/package.json
apps/user/route.ts
apps/user/schema/index.ts
apps/user/schema/loginBody.ts
apps/user/schema/registrationBody.ts
apps/user/schema/updateUserBody.ts
apps/user/server.ts
apps/user/service/ApiFollowUser/ApiFollowUser.ts
apps/user/service/ApiFollowUser/index.ts
apps/user/service/ApiFollowUser/types.ts
apps/user/service/ApiGetCurrentUser/ApiGetCurrentUser.ts
apps/user/service/ApiGetCurrentUser/index.ts
apps/user/service/ApiGetCurrentUser/types.ts
apps/user/service/ApiGetProfile/ApiGetProfile.ts
apps/user/service/ApiGetProfile/index.ts
apps/user/service/ApiGetProfile/types.ts
apps/user/service/ApiRegistration/ApiRegistration.ts
apps/user/service/ApiRegistration/index.ts
apps/user/service/ApiRegistration/types.ts
apps/user/service/ApiUnfollowUser/ApiUnfollowUser.ts
apps/user/service/ApiUnfollowUser/index.ts
apps/user/service/ApiUnfollowUser/types.ts
apps/user/service/ApiUpdateUser/ApiUpdateUser.ts
apps/user/service/ApiUpdateUser/index.ts
apps/user/service/ApiUpdateUser/types.ts
apps/user/service/ApiUserLogin/ApiUserLogin.ts
apps/user/service/ApiUserLogin/index.ts
apps/user/service/ApiUserLogin/types.ts
apps/user/service/Factory.ts
apps/user/service/index.ts
apps/user/tests/basic/get-current-user.spec.ts
apps/user/tests/basic/get-profile.spec.ts
apps/user/tests/basic/login.spec.ts
apps/user/tests/basic/registration.spec.ts
apps/user/tests/basic/update-user.spec.ts
apps/user/tests/follow/follow-user.spec.ts
apps/user/tests/follow/unfollow-user.spec.ts
apps/user/tsconfig.json
apps/user/types/global.d.ts
codecov.yml
config/ci.json
config/custom-environment-variables.json
config/default.json
config/develop.json
config/prod.json
config/test.json
docker-compose.yml
infra/.eslintrc.json
infra/.prettierignore
infra/.prettierrc.json
infra/cdk.json
infra/config/custom-environment-variables.json
infra/config/default.json
infra/config/develop.json
infra/config/prod.json
infra/constants/constants.ts
infra/constants/index.ts
infra/constants/Lambdas.ts
infra/constants/Secrets.ts
infra/constants/Stacks.ts
infra/main.ts
infra/Makefile
infra/package.json
infra/stacks/ApiGatewayStack/ApiGatewayStack.ts
infra/stacks/ApiGatewayStack/index.ts
infra/stacks/ApiGatewayStack/types.ts
infra/stacks/index.ts
infra/stacks/LambdaStack/constants/FileExcludeList.ts
infra/stacks/LambdaStack/constants/index.ts
infra/stacks/LambdaStack/index.ts
infra/stacks/LambdaStack/LambdaStack.ts
infra/stacks/LambdaStack/types.ts
infra/stacks/LambdaStack/utils/getEnvironmentVariables.ts
infra/stacks/LambdaStack/utils/index.ts
infra/tsconfig.json
infra/utils/config/config.ts
infra/utils/config/index.ts
infra/utils/config/types.ts
infra/utils/index.ts
LICENSE
Makefile
package.json
packages/config/.eslintrc.json
packages/config/.prettierrc.json
packages/config/jest.config.js
packages/config/package.json
packages/config/tsconfig.base.json
packages/core/.eslintrc.js
packages/core/.prettierrc.cjs
packages/core/database/DbArticle/DbArticle.ts
packages/core/database/DbArticle/dto/DbDtoArticle.ts
packages/core/database/DbArticle/dto/DbDtoArticleComment.ts
packages/core/database/DbArticle/dto/DbDtoArticleCommentWithProfile.ts
packages/core/database/DbArticle/dto/DbDtoArticleTag.ts
packages/core/database/DbArticle/dto/index.ts
packages/core/database/DbArticle/index.ts
packages/core/database/DbArticle/types.ts
packages/core/database/DbFactory.ts
packages/core/database/DbUser/DbUser.ts
packages/core/database/DbUser/dto/DbDtoProfile.ts
packages/core/database/DbUser/dto/DbDtoUser.ts
packages/core/database/DbUser/dto/index.ts
packages/core/database/DbUser/index.ts
packages/core/database/DbUser/types.ts
packages/core/database/Dockerfile
packages/core/database/index.ts
packages/core/database/knex/index.ts
packages/core/database/knex/knex.ts
packages/core/database/knex/knexfile.ts
packages/core/database/knex/migrations/0001_create-user-table.ts
packages/core/database/knex/migrations/0002_create-task-table.ts
packages/core/database/knex/migrations/0003_create-user-follow-table.ts
packages/core/database/knex/migrations/0004_create-article-table.ts
packages/core/database/knex/migrations/0005_create-article-comment-table.ts
packages/core/database/knex/migrations/0006_create-article-favorite-table.ts
packages/core/database/knex/migrations/0007_create-article-tag-table.ts
packages/core/database/knex/types.ts
packages/core/index.ts
packages/core/jest.config.js
packages/core/package.json
packages/core/repository/index.ts
packages/core/repository/RepoArticle/index.ts
packages/core/repository/RepoArticle/RepoArticle.ts
packages/core/repository/RepoArticle/types.ts
packages/core/repository/RepoFactory.ts
packages/core/repository/RepoUser/index.ts
packages/core/repository/RepoUser/RepoUser.ts
packages/core/repository/RepoUser/types.ts
packages/core/service/article/ArticleService.ts
packages/core/service/article/constants/ArticleErrorCodes.ts
packages/core/service/article/constants/index.ts
packages/core/service/article/errors/ArticleAlreadyFavoritedError.ts
packages/core/service/article/errors/ArticleError.ts
packages/core/service/article/errors/ArticleNotFoundError.ts
packages/core/service/article/errors/ArticleNotYetFavoritedError.ts
packages/core/service/article/errors/ArticleTitleAlreadyTakenError.ts
packages/core/service/article/errors/index.ts
packages/core/service/article/implementations/CreateArticleCommentHandler/CreateArticleCommentHandler.ts
packages/core/service/article/implementations/CreateArticleCommentHandler/index.ts
packages/core/service/article/implementations/CreateArticleCommentHandler/types.ts
packages/core/service/article/implementations/CreateArticleHandler/CreateArticleHandler.ts
packages/core/service/article/implementations/CreateArticleHandler/index.ts
packages/core/service/article/implementations/CreateArticleHandler/types.ts
packages/core/service/article/implementations/CreateArticleTagsHandler/CreateArticleTagsHandler.ts
packages/core/service/article/implementations/CreateArticleTagsHandler/index.ts
packages/core/service/article/implementations/CreateArticleTagsHandler/types.ts
packages/core/service/article/implementations/FavoriteArticleHandler/FavoriteArticleHandler.ts
packages/core/service/article/implementations/FavoriteArticleHandler/index.ts
packages/core/service/article/implementations/FavoriteArticleHandler/types.ts
packages/core/service/article/implementations/GetArticleCommentsHandler/GetArticleCommentsHandler.ts
packages/core/service/article/implementations/GetArticleCommentsHandler/index.ts
packages/core/service/article/implementations/GetArticleCommentsHandler/types.ts
packages/core/service/article/implementations/index.ts
packages/core/service/article/implementations/UpdateArticleHandler/index.ts
packages/core/service/article/implementations/UpdateArticleHandler/types.ts
packages/core/service/article/implementations/UpdateArticleHandler/UpdateArticleHandler.ts
packages/core/service/article/index.ts
packages/core/service/article/types.ts
packages/core/service/auth/AuthService.ts
packages/core/service/auth/constants/AuthErrorCodes.ts
packages/core/service/auth/constants/index.ts
packages/core/service/auth/errors/AuthError.ts
packages/core/service/auth/errors/index.ts
packages/core/service/auth/errors/InvalidTokenError.ts
packages/core/service/auth/errors/PasswordNotMatchError.ts
packages/core/service/auth/errors/PasswordRequirementsNotMetError.ts
packages/core/service/auth/implementations/AccessTokenHandler/AccessTokenHandler.ts
packages/core/service/auth/implementations/AccessTokenHandler/index.ts
packages/core/service/auth/implementations/AccessTokenHandler/types.ts
packages/core/service/auth/implementations/index.ts
packages/core/service/auth/implementations/PasswordHandler/index.ts
packages/core/service/auth/implementations/PasswordHandler/PasswordHandler.ts
packages/core/service/auth/implementations/PasswordHandler/types.ts
packages/core/service/auth/index.ts
packages/core/service/index.ts
packages/core/service/ServiceFactory.ts
packages/core/service/user/constants/index.ts
packages/core/service/user/constants/UserErrorCode.ts
packages/core/service/user/errors/index.ts
packages/core/service/user/errors/InvalidFollowError.ts
packages/core/service/user/errors/UserError.ts
packages/core/service/user/errors/UserExistError.ts
packages/core/service/user/errors/UserNotFoundError.ts
packages/core/service/user/implementations/CreateUserHandler/CreateUserHandler.ts
packages/core/service/user/implementations/CreateUserHandler/index.ts
packages/core/service/user/implementations/CreateUserHandler/types.ts
packages/core/service/user/implementations/FollowHandler/FollowHandler.ts
packages/core/service/user/implementations/FollowHandler/index.ts
packages/core/service/user/implementations/FollowHandler/types.ts
packages/core/service/user/implementations/index.ts
packages/core/service/user/implementations/UpdateUserHandler/index.ts
packages/core/service/user/implementations/UpdateUserHandler/types.ts
packages/core/service/user/implementations/UpdateUserHandler/UpdateUserHandler.ts
packages/core/service/user/index.ts
packages/core/service/user/types.ts
packages/core/service/user/UserService.ts
packages/core/tests/article/comment.spec.ts
packages/core/tests/article/create-article.spec.ts
packages/core/tests/article/favorite.spec.ts
packages/core/tests/article/get-article.spec.ts
packages/core/tests/article/list.spec.ts
packages/core/tests/article/tags.spec.ts
packages/core/tests/article/update-article.spec.ts
packages/core/tests/auth/access-token.spec.ts
packages/core/tests/auth/password.spec.ts
packages/core/tests/user/create-user.spec.ts
packages/core/tests/user/following.spec.ts
packages/core/tests/user/update-user.spec.ts
packages/core/tsconfig.json
packages/core/types/global.d.ts
packages/core/types/index.ts
packages/core/types/RecordStatus.ts
packages/core/types/UserStatus.ts
packages/core/utils/error/AppError/AppError.ts
packages/core/utils/error/AppError/index.ts
packages/core/utils/error/AppError/types.ts
packages/core/utils/error/index.ts
packages/core/utils/getObjectId.ts
packages/core/utils/index.ts
packages/middleware/.eslintrc.js
packages/middleware/.prettierrc.cjs
packages/middleware/auth.ts
packages/middleware/configureGlobalExceptionHandler/configureGlobalExceptionHandler.ts
packages/middleware/configureGlobalExceptionHandler/index.ts
packages/middleware/configureGlobalExceptionHandler/types.ts
packages/middleware/configureLambda/configureLambda.ts
packages/middleware/configureLambda/index.ts
packages/middleware/configureLambda/types.ts
packages/middleware/configureMiddlewares/configureMiddlewares.ts
packages/middleware/configureMiddlewares/index.ts
packages/middleware/configureMiddlewares/types.ts
packages/middleware/index.ts
packages/middleware/jest.config.js
packages/middleware/package.json
packages/middleware/tsconfig.json
packages/middleware/types/global.d.ts
packages/types/.eslintrc.js
packages/types/.prettierrc.cjs
packages/types/index.ts
packages/types/NodeEnv.ts
packages/types/package.json
packages/types/tsconfig.json
packages/utils/.eslintrc.js
packages/utils/.prettierrc.cjs
packages/utils/config/config.ts
packages/utils/config/index.ts
packages/utils/config/types.ts
packages/utils/error/ApiError.ts
packages/utils/error/ApiErrorBadRequest.ts
packages/utils/error/ApiErrorConflict.ts
packages/utils/error/ApiErrorForbidden.ts
packages/utils/error/ApiErrorInternalServerError.ts
packages/utils/error/ApiErrorMethodNotAllowed.ts
packages/utils/error/ApiErrorNotFound.ts
packages/utils/error/ApiErrorNotImplemented.ts
packages/utils/error/ApiErrorRequestTimeout.ts
packages/utils/error/ApiErrorServiceUnavailable.ts
packages/utils/error/ApiErrorTooManyRequests.ts
packages/utils/error/ApiErrorUnauthorized.ts
packages/utils/error/ApiErrorUnprocessableEntity.ts
packages/utils/error/constants/http-error.json
packages/utils/error/index.ts
packages/utils/index.ts
packages/utils/jest.config.js
packages/utils/logger/formats/capitalizeLevel.ts
packages/utils/logger/formats/cleanStack.ts
packages/utils/logger/formats/customPrintf.ts
packages/utils/logger/formats/environment.ts
packages/utils/logger/formats/index.ts
packages/utils/logger/formats/json.ts
packages/utils/logger/formats/label.ts
packages/utils/logger/index.ts
packages/utils/logger/logger.ts
packages/utils/package.json
packages/utils/tsconfig.json
README.md
scripts/api-test.sh
scripts/clean.sh
scripts/wait-for-readiness.sh
tests/integration/postman-collections/full.json
tests/integration/testing-environment.json
turbo.json

================================================================
Repository Files
================================================================

================
File: .cspell.json
================
{
	"$schema": "https://raw.githubusercontent.com/streetsidesoftware/cspell/main/cspell.schema.json",
	"version": "0.2",
	"language": "en",
	"useGitignore": true,
	"caseSensitive": false,
	"dictionaries": [
		"typescript",
		"node",
		"html",
		"css",
		"bash",
		"npm",
		"filetypes",
		"fonts",
		"project",
		"nodejs"
	],
	"ignorePaths": [
		"package.json",
		"pnpm-lock.yaml"
	],
	"dictionaryDefinitions": [
		{
			"name": "project",
			"path": "./.cspell/project.txt",
			"description": "Wordings specific to this project and will not be shared with other projects"
		},
		{
			"name": "aws",
			"path": "./.cspell/aws.txt",
			"description": "Keywords specific to the AWS project, including the names of AWS services and the terms used within them"
		},
		{
			"name": "nodejs",
			"path": "./.cspell/nodejs.txt",
			"description": "Keywords specific to the Node.js project, including the names of node_modules and the terms used within them"
		}
	]
}

================
File: .cspell/aws.txt
================
apigatewayv2
certificatemanager
codepipeline
amazonaws
codebuild
apigateway
dbname
secretsmanager
arn
arns

================
File: .cspell/nodejs.txt
================
apiurl
cloudwatchlogs
codegen
colorfied
colorify
knexfile
localstack
logform
longtext
luxon
mediumtext
middlewares
millis
openapi
packagejson
prerequest
redoc
reduxjs
sinonjs
Snyk
sqlstring
tinytext
trivago
unflatten
vendia
graphiql
uncolorize
cicd

================
File: .cspell/project.txt
================
codecov
favorited
favoriting
jwtid
kenyip
realworld
signin
uncategorized
unfavorited
unfavoriting
unfollow
unfollowed
unfollowing
unfollows
kenyip

================
File: .dockerignore
================
# Ignore node_modules and dependencies
node_modules
bower_components

# Ignore logs and temporary files
*.log
*.tmp
*.swp

# Ignore build directories
dist
build
out

# Ignore configuration files and environment files
.env
.env.local
.DS_Store

# Ignore Docker-related files if not needed
Dockerfile.*
docker-compose.*

# Ignore Git and version control metadata
.git
.gitlab-ci.yml

# Ignore IDE/Editor-specific files
.vscode
.idea
*.iml

# Ignore test-related files
coverage

================
File: .editorconfig
================
root = true

[*]
end_of_line = lf
charset = utf-8
indent_size = 2
indent_style = space
trim_trailing_whitespace = true

[*.yml]
indent_size = 2
indent_style = space

[*.yaml]
indent_size = 2
indent_style = space

[*.md]
max_line_length = off
trim_trailing_whitespace = false

================
File: .github/PULL_REQUEST_TEMPLATE.md
================
# Summary  
<!-- Provide a brief description of the changes. Mention the problem or feature addressed and the context around it. -->

## Type of Change  
- [ ] üêõ Bug fix (resolves an issue without affecting existing functionality)  
- [ ] ‚ú® New feature (adds functionality without breaking existing behavior)  
- [ ] üí• Breaking change (alters existing behavior or introduces incompatibilities)  
- [ ] üìù Documentation update (changes to documentation or README)

## List of Changes  
<!-- Highlight the key updates included in this PR. You can group related changes if necessary. -->

1.  
2.  
3.  

## Testing Details  
<!-- Describe the tests executed to verify the changes. Include steps to reproduce where relevant. -->

1.  
2.  
3.  


## Merge Workflow Checklist  

### For New Features / Fixes  
- [ ] Ensure the PR targets the `develop` branch.  
- [ ] Use a descriptive PR title with relevant issue/ticket references (if applicable).  
- [ ] Include relevant design documents, requirements, or tickets in the PR.  
- [ ] Provide screenshots, logs, cURL requests, or backend call samples where relevant.  
- [ ] Follow the **Squash Commits** strategy, ensuring the commit message matches the PR title and follows internal contribution guidelines.

### Release Workflow  
- [ ] Set the PR target to `main` (source branch: `staging`).  
- [ ] Use **Merge Commits** with the message: `Release [Develop ‚Üí Master]`.

================
File: .github/workflows/ci.yaml
================
name: Continuous Integration

on:
  push:
    paths-ignore:
      - '**.md'  # Ignore changes to markdown files
    branches-ignore:
      - 'master' # We have a separate workflow for master branch
      
jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    env:
      NODE_ENV: test
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set Up Node.js Environment
        uses: actions/setup-node@v3
        with:
          node-version: 20.18.0
          cache: 'yarn'  # Cache Yarn dependencies

      - name: Install Dependencies
        run: yarn install --frozen-lockfile  # Ensures dependencies match yarn.lock

      - name: Run Code Linting
        run: yarn lint

      - name: Execute Unit Tests
        run: yarn test:coverage

      - name: Merge Coverage Reports
        run: yarn merge-coverage
        if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/master'  # Run only on develop and master

      - name: Upload Coverage Reports to Codecov
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
        if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/master'  # Run only on develop and master

  e2e-test:
    name: End To End Test
    runs-on: ubuntu-latest
    env:
      NODE_ENV: ci
    services:
      mysql:
        image: mysql:5.7
        env:
          MYSQL_ROOT_PASSWORD: mysql
          MYSQL_PASSWORD: mysql
          MYSQL_USER: mysql
          MYSQL_DATABASE: conduit
        ports:
          - 3306:3306
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set Up Node.js Environment
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'yarn'  # Cache Yarn dependencies

      - name: Install Dependencies
        run: yarn install --frozen-lockfile  # Ensures dependencies match yarn.lock

      - name: Run Database Migration
        run: yarn db:migrate

      - name: Build Application
        run: yarn build

      - name: Start Server in the Background
        run: yarn start:ci --filter=@conduit/local

      - name: Wait for the Server to Start
        run: ./scripts/wait-for-readiness.sh

      - name: Install Newman
        run: npm install -g newman 

      - name: Run Integration Test
        run: ./scripts/api-test.sh

================
File: .github/workflows/deploy-to-develop.yaml
================
name: Deploy to Develop

on:
  workflow_run:
    workflows: ['Continuous Integration'] # Triggers after the specified workflow completes
    types:
      - completed

jobs:
  deploy:
    name: Deploy to Develop
    environment:
      name: develop
    runs-on: ubuntu-latest
    if: |
      github.event.workflow_run.conclusion == 'success' &&  
      contains(github.event.workflow_run.head_branch, 'develop')

    steps:
      - name: Trigger AWS CodePipeline
        run:
          aws codepipeline start-pipeline-execution --name ${{
          vars.CODE_BUILD_PIPELINE }} --region ${{ vars.AWS_REGION }}
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

================
File: .github/workflows/release.yaml
================
name: Release

on:
  push:
    branches:
      - master
    paths-ignore:
      - "**.md" # Ignore changes to markdown files

jobs:
  e2e-test:
    name: End To End Test
    runs-on: ubuntu-latest
    env:
      NODE_ENV: ci
    services:
      mysql:
        image: mysql:5.7
        env:
          MYSQL_ROOT_PASSWORD: mysql
          MYSQL_PASSWORD: mysql
          MYSQL_USER: mysql
          MYSQL_DATABASE: conduit
        ports:
          - 3306:3306
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
      - name: Set Up Node.js Environment
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          cache: "yarn" # Cache Yarn dependencies
      - name: Install Dependencies
        run: yarn install --frozen-lockfile # Ensures dependencies match yarn.lock
      - name: Run Database Migration
        run: yarn db:migrate
      - name: Build Application
        run: yarn build
      - name: Start Server in the Background
        run: yarn start:ci --filter=@conduit/local
      - name: Wait for the Server to Start
        run: ./scripts/wait-for-readiness.sh
      - name: Install Newman
        run: npm install -g newman
      - name: Run Integration Test
        run: ./scripts/api-test.sh

  deploy:
    name: Deploy to Production
    environment:
      name: production
    runs-on: ubuntu-latest
    needs: e2e-test
    steps:
      - name: Trigger AWS CodePipeline
        run: aws codepipeline start-pipeline-execution --name ${{
          vars.CODE_BUILD_PIPELINE }} --region ${{ vars.AWS_REGION }}
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

  release:
    name: Release
    needs: e2e-test
    runs-on: ubuntu-latest
    permissions:
      contents: write # Allow action to push to github
      packages: write
      pull-requests: write
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
      - name: Checkout code
        uses: actions/setup-node@v3
        with:
          node-version: 20.18.0
      - name: Run semantic-release
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: npx semantic-release

================
File: .gitignore
================
# Created by https://www.gitignore.io/api/osx,node,linux,windows

### Linux ###
*~
# Temporary files which can be created if a process still has a handle open of a deleted file
.fuse_hidden*
# KDE directory preferences
.directory
# Linux trash folder which might appear on any partition or disk
.Trash-*
# .nfs files are created when an open file is removed but is still being accessed
.nfs*

### Node ###
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
# Runtime data
pids
*.pid
*.seed
*.pid.lock
# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov
# Coverage directory used by tools like istanbul
coverage
# nyc test coverage
.nyc_output
# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt
# Bower dependency directory (https://bower.io/)
bower_components
# node-waf configuration
.lock-wscript
# Compiled binary addons (http://nodejs.org/api/addons.html)
build/Release
# Dependency directories
node_modules/
jspm_packages/
# Typescript v1 declaration files
typings/
# Optional npm cache directory
.npm
# npm list directory
target
# Optional eslint cache
.eslintcache
# Optional REPL history
.node_repl_history
# Output of 'npm pack'
*.tgz
# Yarn Integrity file
.yarn-integrity
# dotenv environment variables file
.env

### OSX ###
*.DS_Store
.AppleDouble
.LSOverride
# Icon must end with two \r
Icon
# Thumbnails
._*
# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent
# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

### Windows ###
# Windows thumbnail cache files
Thumbs.db
ehthumbs.db
ehthumbs_vista.db
# Folder config file
Desktop.ini
# Recycle Bin used on file shares
$RECYCLE.BIN/
# Windows Installer files
*.cab
*.msi
*.msm
*.msp
# Windows shortcuts
*.lnk

# AWS SAM and CLI directories
.aws/
.aws-sam/

# End of https://www.gitignore.io/api/osx,node,linux,windows

# Custom entries
test.ts
db.sqlite
.turbo
*.sqlite3
output
samconfig.toml
build
.vscode
cdk.out
cdk.context.json

================
File: .nvmrc
================
v20.18.0

================
File: apps/app/.eslintrc.js
================
const defaultConfig = require('@conduit/config/.eslintrc.json');

module.exports = {
  ...defaultConfig,
  parserOptions: {
    project: './tsconfig.json'
  },
  rules: {
    ...defaultConfig.rules,
    'import/no-extraneous-dependencies': 'off'
  }
};

================
File: apps/app/.prettierrc.cjs
================
module.exports = require('@conduit/config/.prettierrc.json');

================
File: apps/app/app.ts
================
import express from 'express';

import {
  configureGlobalExceptionHandler,
  configureMiddlewares
} from '@conduit/middleware';

import { router } from './route';

export const app = express();

configureMiddlewares({ app });

app.use(router);

configureGlobalExceptionHandler({ app });

================
File: apps/app/controller/getApiDoc/getApiDoc.ts
================
import { RequestHandler } from 'express';
import fs from 'fs';
import path from 'path';

const redocHtml = fs.readFileSync(path.join(__dirname, './redoc.html'), 'utf8');

export const getApiDoc: RequestHandler = async (_req, res) => {
  res.send(redocHtml);
};

================
File: apps/app/controller/getApiDoc/index.ts
================
export * from './getApiDoc';

================
File: apps/app/controller/getApiDoc/redoc.html
================
<html>
  <title>Conduit API Documentation</title>
  <body>
    <redoc spec-url="/swagger.json"></redoc>
    <script src="https://cdn.redoc.ly/redoc/latest/bundles/redoc.standalone.js"></script>
  </body>
</html>

================
File: apps/app/controller/getSwaggerJson/getSwaggerJson.ts
================
import { RequestHandler } from 'express';

import swagger from './swagger.json';

export const getSwaggerJson: RequestHandler = async (_req, res) => {
  res.json(swagger);
};

================
File: apps/app/controller/getSwaggerJson/index.ts
================
export * from './getSwaggerJson';

================
File: apps/app/controller/getSwaggerJson/swagger.json
================
{
  "openapi": "3.0.1",
  "info": {
    "title": "RealWorld Conduit API",
    "description": "Conduit API documentation",
    "contact": {
      "name": "RealWorld",
      "url": "https://conduit-develop-api.kenyip.cc"
    },
    "license": {
      "name": "MIT License",
      "url": "https://opensource.org/licenses/MIT"
    },
    "version": "1.0.0"
  },
  "tags": [
    {
      "name": "Articles"
    },
    {
      "name": "Comments"
    },
    {
      "name": "Favorites"
    },
    {
      "name": "Profile"
    },
    {
      "name": "Tags"
    },
    {
      "name": "User and Authentication"
    }
  ],
  "servers": [
    {
      "url": "https://api.realworld.io/api"
    }
  ],
  "paths": {
    "/users/login": {
      "post": {
        "tags": ["User and Authentication"],
        "summary": "Existing user login",
        "description": "Login for existing user",
        "operationId": "Login",
        "requestBody": {
          "$ref": "#/components/requestBodies/LoginUserRequest"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/UserResponse"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/users": {
      "post": {
        "tags": ["User and Authentication"],
        "description": "Register a new user",
        "operationId": "CreateUser",
        "requestBody": {
          "$ref": "#/components/requestBodies/NewUserRequest"
        },
        "responses": {
          "201": {
            "$ref": "#/components/responses/UserResponse"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/user": {
      "get": {
        "tags": ["User and Authentication"],
        "summary": "Get current user",
        "description": "Gets the currently logged-in user",
        "operationId": "GetCurrentUser",
        "responses": {
          "200": {
            "$ref": "#/components/responses/UserResponse"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        },
        "security": [
          {
            "Token": []
          }
        ]
      },
      "put": {
        "tags": ["User and Authentication"],
        "summary": "Update current user",
        "description": "Updated user information for current user",
        "operationId": "UpdateCurrentUser",
        "requestBody": {
          "$ref": "#/components/requestBodies/UpdateUserRequest"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/UserResponse"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        },
        "security": [
          {
            "Token": []
          }
        ],
        "x-codegen-request-body-name": "body"
      }
    },
    "/profiles/{username}": {
      "get": {
        "tags": ["Profile"],
        "summary": "Get a profile",
        "description": "Get a profile of a user of the system. Auth is optional",
        "operationId": "GetProfileByUsername",
        "parameters": [
          {
            "name": "username",
            "in": "path",
            "description": "Username of the profile to get",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ProfileResponse"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        }
      }
    },
    "/profiles/{username}/follow": {
      "post": {
        "tags": ["Profile"],
        "summary": "Follow a user",
        "description": "Follow a user by username",
        "operationId": "FollowUserByUsername",
        "parameters": [
          {
            "name": "username",
            "in": "path",
            "description": "Username of the profile you want to follow",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ProfileResponse"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        },
        "security": [
          {
            "Token": []
          }
        ]
      },
      "delete": {
        "tags": ["Profile"],
        "summary": "Unfollow a user",
        "description": "Unfollow a user by username",
        "operationId": "UnfollowUserByUsername",
        "parameters": [
          {
            "name": "username",
            "in": "path",
            "description": "Username of the profile you want to unfollow",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ProfileResponse"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        },
        "security": [
          {
            "Token": []
          }
        ]
      }
    },
    "/articles/feed": {
      "get": {
        "tags": ["Articles"],
        "summary": "Get recent articles from users you follow",
        "description": "Get most recent articles from users you follow. Use query parameters to limit. Auth is required",
        "operationId": "GetArticlesFeed",
        "parameters": [
          {
            "$ref": "#/components/parameters/offsetParam"
          },
          {
            "$ref": "#/components/parameters/limitParam"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/MultipleArticlesResponse"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        },
        "security": [
          {
            "Token": []
          }
        ]
      }
    },
    "/articles": {
      "get": {
        "tags": ["Articles"],
        "summary": "Get recent articles globally",
        "description": "Get most recent articles globally. Use query parameters to filter results. Auth is optional",
        "operationId": "GetArticles",
        "parameters": [
          {
            "name": "tag",
            "in": "query",
            "description": "Filter by tag",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "author",
            "in": "query",
            "description": "Filter by author (username)",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "favorited",
            "in": "query",
            "description": "Filter by favorites of a user (username)",
            "schema": {
              "type": "string"
            }
          },
          {
            "$ref": "#/components/parameters/offsetParam"
          },
          {
            "$ref": "#/components/parameters/limitParam"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/MultipleArticlesResponse"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        }
      },
      "post": {
        "tags": ["Articles"],
        "summary": "Create an article",
        "description": "Create an article. Auth is required",
        "operationId": "CreateArticle",
        "requestBody": {
          "$ref": "#/components/requestBodies/NewArticleRequest"
        },
        "responses": {
          "201": {
            "$ref": "#/components/responses/SingleArticleResponse"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        },
        "security": [
          {
            "Token": []
          }
        ],
        "x-codegen-request-body-name": "article"
      }
    },
    "/articles/{slug}": {
      "get": {
        "tags": ["Articles"],
        "summary": "Get an article",
        "description": "Get an article. Auth not required",
        "operationId": "GetArticle",
        "parameters": [
          {
            "name": "slug",
            "in": "path",
            "description": "Slug of the article to get",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SingleArticleResponse"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        }
      },
      "put": {
        "tags": ["Articles"],
        "summary": "Update an article",
        "description": "Update an article. Auth is required",
        "operationId": "UpdateArticle",
        "parameters": [
          {
            "name": "slug",
            "in": "path",
            "description": "Slug of the article to update",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/UpdateArticleRequest"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/SingleArticleResponse"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        },
        "security": [
          {
            "Token": []
          }
        ],
        "x-codegen-request-body-name": "article"
      },
      "delete": {
        "tags": ["Articles"],
        "summary": "Delete an article",
        "description": "Delete an article. Auth is required",
        "operationId": "DeleteArticle",
        "parameters": [
          {
            "name": "slug",
            "in": "path",
            "description": "Slug of the article to delete",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyOkResponse"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        },
        "security": [
          {
            "Token": []
          }
        ]
      }
    },
    "/articles/{slug}/comments": {
      "get": {
        "tags": ["Comments"],
        "summary": "Get comments for an article",
        "description": "Get the comments for an article. Auth is optional",
        "operationId": "GetArticleComments",
        "parameters": [
          {
            "name": "slug",
            "in": "path",
            "description": "Slug of the article that you want to get comments for",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/MultipleCommentsResponse"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        }
      },
      "post": {
        "tags": ["Comments"],
        "summary": "Create a comment for an article",
        "description": "Create a comment for an article. Auth is required",
        "operationId": "CreateArticleComment",
        "parameters": [
          {
            "name": "slug",
            "in": "path",
            "description": "Slug of the article that you want to create a comment for",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/NewCommentRequest"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/SingleCommentResponse"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        },
        "security": [
          {
            "Token": []
          }
        ],
        "x-codegen-request-body-name": "comment"
      }
    },
    "/articles/{slug}/comments/{id}": {
      "delete": {
        "tags": ["Comments"],
        "summary": "Delete a comment for an article",
        "description": "Delete a comment for an article. Auth is required",
        "operationId": "DeleteArticleComment",
        "parameters": [
          {
            "name": "slug",
            "in": "path",
            "description": "Slug of the article that you want to delete a comment for",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "description": "ID of the comment you want to delete",
            "required": true,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyOkResponse"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        },
        "security": [
          {
            "Token": []
          }
        ]
      }
    },
    "/articles/{slug}/favorite": {
      "post": {
        "tags": ["Favorites"],
        "summary": "Favorite an article",
        "description": "Favorite an article. Auth is required",
        "operationId": "CreateArticleFavorite",
        "parameters": [
          {
            "name": "slug",
            "in": "path",
            "description": "Slug of the article that you want to favorite",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SingleArticleResponse"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        },
        "security": [
          {
            "Token": []
          }
        ]
      },
      "delete": {
        "tags": ["Favorites"],
        "summary": "Unfavorite an article",
        "description": "Unfavorite an article. Auth is required",
        "operationId": "DeleteArticleFavorite",
        "parameters": [
          {
            "name": "slug",
            "in": "path",
            "description": "Slug of the article that you want to unfavorite",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SingleArticleResponse"
          },
          "401": {
            "$ref": "#/components/responses/Unauthorized"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        },
        "security": [
          {
            "Token": []
          }
        ]
      }
    },
    "/tags": {
      "get": {
        "tags": ["Tags"],
        "summary": "Get tags",
        "description": "Get tags. Auth not required",
        "operationId": "GetTags",
        "responses": {
          "200": {
            "$ref": "#/components/responses/TagsResponse"
          },
          "422": {
            "$ref": "#/components/responses/GenericError"
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "LoginUser": {
        "required": ["email", "password"],
        "type": "object",
        "properties": {
          "email": {
            "type": "string"
          },
          "password": {
            "type": "string",
            "format": "password"
          }
        }
      },
      "NewUser": {
        "required": ["email", "password", "username"],
        "type": "object",
        "properties": {
          "username": {
            "type": "string"
          },
          "email": {
            "type": "string"
          },
          "password": {
            "type": "string",
            "format": "password"
          }
        }
      },
      "User": {
        "required": ["bio", "email", "image", "token", "username"],
        "type": "object",
        "properties": {
          "email": {
            "type": "string"
          },
          "token": {
            "type": "string"
          },
          "username": {
            "type": "string"
          },
          "bio": {
            "type": "string"
          },
          "image": {
            "type": "string"
          }
        }
      },
      "UpdateUser": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string"
          },
          "password": {
            "type": "string"
          },
          "username": {
            "type": "string"
          },
          "bio": {
            "type": "string"
          },
          "image": {
            "type": "string"
          }
        }
      },
      "Profile": {
        "required": ["bio", "following", "image", "username"],
        "type": "object",
        "properties": {
          "username": {
            "type": "string"
          },
          "bio": {
            "type": "string"
          },
          "image": {
            "type": "string"
          },
          "following": {
            "type": "boolean"
          }
        }
      },
      "Article": {
        "required": [
          "author",
          "body",
          "createdAt",
          "description",
          "favorited",
          "favoritesCount",
          "slug",
          "tagList",
          "title",
          "updatedAt"
        ],
        "type": "object",
        "properties": {
          "slug": {
            "type": "string"
          },
          "title": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "body": {
            "type": "string"
          },
          "tagList": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "createdAt": {
            "type": "string",
            "format": "date-time"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time"
          },
          "favorited": {
            "type": "boolean"
          },
          "favoritesCount": {
            "type": "integer"
          },
          "author": {
            "$ref": "#/components/schemas/Profile"
          }
        }
      },
      "NewArticle": {
        "required": ["body", "description", "title"],
        "type": "object",
        "properties": {
          "title": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "body": {
            "type": "string"
          },
          "tagList": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "UpdateArticle": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "body": {
            "type": "string"
          }
        }
      },
      "Comment": {
        "required": ["author", "body", "createdAt", "id", "updatedAt"],
        "type": "object",
        "properties": {
          "id": {
            "type": "integer"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time"
          },
          "body": {
            "type": "string"
          },
          "author": {
            "$ref": "#/components/schemas/Profile"
          }
        }
      },
      "NewComment": {
        "required": ["body"],
        "type": "object",
        "properties": {
          "body": {
            "type": "string"
          }
        }
      },
      "GenericErrorModel": {
        "required": ["errors"],
        "type": "object",
        "properties": {
          "errors": {
            "required": ["body"],
            "type": "object",
            "properties": {
              "body": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "responses": {
      "TagsResponse": {
        "description": "Tags",
        "content": {
          "application/json": {
            "schema": {
              "required": ["tags"],
              "type": "object",
              "properties": {
                "tags": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      },
      "SingleCommentResponse": {
        "description": "Single comment",
        "content": {
          "application/json": {
            "schema": {
              "required": ["comment"],
              "type": "object",
              "properties": {
                "comment": {
                  "$ref": "#/components/schemas/Comment"
                }
              }
            }
          }
        }
      },
      "MultipleCommentsResponse": {
        "description": "Multiple comments",
        "content": {
          "application/json": {
            "schema": {
              "required": ["comments"],
              "type": "object",
              "properties": {
                "comments": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Comment"
                  }
                }
              }
            }
          }
        }
      },
      "SingleArticleResponse": {
        "description": "Single article",
        "content": {
          "application/json": {
            "schema": {
              "required": ["article"],
              "type": "object",
              "properties": {
                "article": {
                  "$ref": "#/components/schemas/Article"
                }
              }
            }
          }
        }
      },
      "MultipleArticlesResponse": {
        "description": "Multiple articles",
        "content": {
          "application/json": {
            "schema": {
              "required": ["articles", "articlesCount"],
              "type": "object",
              "properties": {
                "articles": {
                  "type": "array",
                  "items": {
                    "required": [
                      "author",
                      "createdAt",
                      "description",
                      "favorited",
                      "favoritesCount",
                      "slug",
                      "tagList",
                      "title",
                      "updatedAt"
                    ],
                    "type": "object",
                    "properties": {
                      "slug": {
                        "type": "string"
                      },
                      "title": {
                        "type": "string"
                      },
                      "description": {
                        "type": "string"
                      },
                      "tagList": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "createdAt": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "updatedAt": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "favorited": {
                        "type": "boolean"
                      },
                      "favoritesCount": {
                        "type": "integer"
                      },
                      "author": {
                        "$ref": "#/components/schemas/Profile"
                      }
                    }
                  }
                },
                "articlesCount": {
                  "type": "integer"
                }
              }
            }
          }
        }
      },
      "ProfileResponse": {
        "description": "Profile",
        "content": {
          "application/json": {
            "schema": {
              "required": ["profile"],
              "type": "object",
              "properties": {
                "profile": {
                  "$ref": "#/components/schemas/Profile"
                }
              }
            }
          }
        }
      },
      "UserResponse": {
        "description": "User",
        "content": {
          "application/json": {
            "schema": {
              "required": ["user"],
              "type": "object",
              "properties": {
                "user": {
                  "$ref": "#/components/schemas/User"
                }
              }
            }
          }
        }
      },
      "EmptyOkResponse": {
        "description": "No content",
        "content": {}
      },
      "Unauthorized": {
        "description": "Unauthorized",
        "content": {}
      },
      "GenericError": {
        "description": "Unexpected error",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/GenericErrorModel"
            }
          }
        }
      }
    },
    "requestBodies": {
      "LoginUserRequest": {
        "required": true,
        "description": "Credentials to use",
        "content": {
          "application/json": {
            "schema": {
              "required": ["user"],
              "type": "object",
              "properties": {
                "user": {
                  "$ref": "#/components/schemas/LoginUser"
                }
              }
            }
          }
        }
      },
      "NewUserRequest": {
        "required": true,
        "description": "Details of the new user to register",
        "content": {
          "application/json": {
            "schema": {
              "required": ["user"],
              "type": "object",
              "properties": {
                "user": {
                  "$ref": "#/components/schemas/NewUser"
                }
              }
            }
          }
        }
      },
      "UpdateUserRequest": {
        "required": true,
        "description": "User details to update. At least **one** field is required.",
        "content": {
          "application/json": {
            "schema": {
              "required": ["user"],
              "type": "object",
              "properties": {
                "user": {
                  "$ref": "#/components/schemas/UpdateUser"
                }
              }
            }
          }
        }
      },
      "NewArticleRequest": {
        "required": true,
        "description": "Article to create",
        "content": {
          "application/json": {
            "schema": {
              "required": ["article"],
              "type": "object",
              "properties": {
                "article": {
                  "$ref": "#/components/schemas/NewArticle"
                }
              }
            }
          }
        }
      },
      "UpdateArticleRequest": {
        "required": true,
        "description": "Article to update",
        "content": {
          "application/json": {
            "schema": {
              "required": ["article"],
              "type": "object",
              "properties": {
                "article": {
                  "$ref": "#/components/schemas/UpdateArticle"
                }
              }
            }
          }
        }
      },
      "NewCommentRequest": {
        "required": true,
        "description": "Comment you want to create",
        "content": {
          "application/json": {
            "schema": {
              "required": ["comment"],
              "type": "object",
              "properties": {
                "comment": {
                  "$ref": "#/components/schemas/NewComment"
                }
              }
            }
          }
        }
      }
    },
    "parameters": {
      "offsetParam": {
        "in": "query",
        "name": "offset",
        "required": false,
        "schema": {
          "type": "integer",
          "minimum": 0
        },
        "description": "The number of items to skip before starting to collect the result set."
      },
      "limitParam": {
        "in": "query",
        "name": "limit",
        "required": false,
        "schema": {
          "type": "integer",
          "minimum": 1,
          "default": 20
        },
        "description": "The numbers of items to return."
      }
    },
    "securitySchemes": {
      "Token": {
        "type": "apiKey",
        "description": "For accessing the protected API resources, you must have received a a valid JWT token after registering or logging in. This JWT token must then be used for all protected resources by passing it in via the 'Authorization' header.\n\nA JWT token is generated by the API by either registering via /users or logging in via /users/login.\n\nThe following format must be in the 'Authorization' header :\n\n    Token xxxxxx.yyyyyyy.zzzzzz\n    \n",
        "name": "Authorization",
        "in": "header"
      }
    }
  }
}

================
File: apps/app/controller/healthCheck.ts
================
import { RequestHandler } from 'express';

export const healthCheck: RequestHandler = async (_req, res) => {
  res.send('OK');
};

================
File: apps/app/controller/index.ts
================
export * from './getApiDoc';
export * from './getSwaggerJson';
export * from './healthCheck';

================
File: apps/app/Dockerfile
================
#
# Base image for the server
#
FROM node:18 AS base

ARG WORKSPACE_SCOPE=@conduit/app

# Set working directory
WORKDIR /app
RUN yarn global add turbo

# Copy the project files
COPY . .

# Use the build argument in the turbo prune command
RUN turbo prune --scope=$WORKSPACE_SCOPE --docker

#
# Installer image
# Add lockfile and package.json's of isolated sub-workspace
#
FROM base AS installer

# Set working directory
WORKDIR /app

# Copy necessary files to the installer stage
COPY .gitignore .gitignore
COPY --from=base /app/out/json/ .
COPY --from=base /app/out/yarn.lock ./yarn.lock

# Install dependencies
RUN yarn install

# Build the project using the variable scope
COPY --from=base /app/out/full/ .
RUN turbo run build --filter=$WORKSPACE_SCOPE...

================
File: apps/app/jest.config.js
================
/** @type {import('jest').Config} */

module.exports = require('@conduit/config/jest.config');

================
File: apps/app/local.ts
================
import 'dotenv/config';

import { logger } from '@conduit/utils';

import { app } from './app';

app.listen(3100, () => {
  logger.info('User server is running on http://localhost:3100', { label: 'App' });
});

================
File: apps/app/package.json
================
{
  "name": "@conduit/app",
  "version": "1.0.0",
  "private": true,
  "description": "",
  "license": "MIT",
  "author": {
    "name": "Ken Yip",
    "email": "ken20206@gmail.com",
    "url": "https://kenyip.cc"
  },
  "main": "index.js",
  "workspaces": [
    "../../packages/config",
    "../../packages/core",
    "../../packages/utils",
    "../../packages/types",
    "../../packages/middleware"
  ],
  "scripts": {
    "build": "tsc",
    "check-types": "tsc --skipLibCheck --noEmit",
    "dev": "NODE_CONFIG_DIR='../../config' NODE_ENV=develop ts-node-dev --no-notify --exit-child --respawn --transpile-only --ignore-watch node_modules ./local.ts",
    "lint": "eslint .",
    "lint:fix": "eslint --fix .",
    "prettify": "prettier --write .",
    "test": "NODE_CONFIG_DIR='../../config' NODE_ENV=test jest tests/** --forceExit --maxWorkers=4 --detectOpenHandles",
    "test:coverage": "yarn test --coverage"
  },
  "dependencies": {
    "@conduit/config": "*",
    "@conduit/core": "*",
    "@conduit/middleware": "*",
    "@conduit/utils": "*",
    "express": "^4.21.1",
    "express-promise-router": "^4.1.1",
    "joi": "^17.13.3",
    "p-map": "4.0.0",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "@jest/types": "^29.6.3",
    "@types/aws-lambda": "^8.10.145",
    "@types/supertest": "^6.0.2",
    "@types/uuid": "^10.0.0",
    "better-sqlite3": "^11.3.0",
    "chance": "^1.1.12",
    "dotenv": "^16.4.5",
    "eslint": "^8.19.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "eslint-config-airbnb-typescript": "^17.0.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-jest": "^26.5.3",
    "eslint-plugin-prettier": "^5.2.1",
    "jest": "^26.2.0",
    "jest-when": "^3.6.0",
    "prettier": "^3.3.3",
    "prettier-plugin-packagejson": "^2.5.3",
    "supertest": "^6.0.0",
    "ts-jest": "^26.1.0",
    "ts-node": "^10.9.1",
    "ts-node-dev": "^2.0.0",
    "tsc-alias": "^1.8.10",
    "typescript": "^5.6.3"
  }
}

================
File: apps/app/route.ts
================
import Router from 'express-promise-router';

import { getApiDoc, getSwaggerJson, healthCheck } from './controller';

export const router = Router();

router.get('/api/health-check', healthCheck);

router.get('/swagger.json', getSwaggerJson);

router.get('/', getApiDoc);

================
File: apps/app/server.ts
================
import { configureLambda } from '@conduit/middleware';

import { app } from './app';

export const handler = configureLambda({ app });

================
File: apps/app/tests/api-doc.spec.ts
================
import supertest from 'supertest';

import { app } from '../app';

const request = supertest(app);

describe('GET /', () => {
  it('should be able to retrieve the api documentation', async () => {
    const response = await request.get('/');
    expect(response.status).toBe(200);
    expect(response.header['content-type']).toBe('text/html; charset=utf-8');
  });
});

================
File: apps/app/tests/health-check.spec.ts
================
import supertest from 'supertest';

import { app } from '../app';

const request = supertest(app);

describe('GET /api/health-check', () => {
  it('should be able to retrieve the health check', async () => {
    const response = await request.get('/api/health-check');
    expect(response.status).toBe(200);
  });
});

================
File: apps/app/tests/swagger-json.spec.ts
================
import supertest from 'supertest';

import { app } from '../app';

const request = supertest(app);

describe('GET /swagger-json', () => {
  it('should be able to retrieve the swagger.json', async () => {
    const response = await request.get('/swagger.json');
    expect(response.status).toBe(200);
    expect(response.header['content-type']).toBe('application/json; charset=utf-8');
    expect(response.body).toHaveProperty('openapi');
    expect(response.body).toHaveProperty('info');
    expect(response.body).toHaveProperty('paths');
  });
});

================
File: apps/app/tsconfig.json
================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "@conduit/config/tsconfig.base.json",
  "compilerOptions": {
    "sourceMap": false
  },
  "include": ["./**/*.ts"]
}

================
File: apps/app/types/global.d.ts
================
import '@conduit/core/types/global';

================
File: apps/article/.eslintrc.js
================
const defaultConfig = require('@conduit/config/.eslintrc.json');

module.exports = {
  ...defaultConfig,
  parserOptions: {
    project: './tsconfig.json'
  },
  rules: {
    ...defaultConfig.rules,
    'import/no-extraneous-dependencies': 'off'
  }
};

================
File: apps/article/.prettierrc.cjs
================
module.exports = require('@conduit/config/.prettierrc.json');

================
File: apps/article/app.ts
================
import express from 'express';

import {
  configureGlobalExceptionHandler,
  configureMiddlewares
} from '@conduit/middleware';

import { router } from './route';

export const app = express();

configureMiddlewares({ app });

app.use(router);

configureGlobalExceptionHandler({ app });

================
File: apps/article/controller/addComment.ts
================
import { RequestHandler } from 'express';

import {
  ApiErrorInternalServerError,
  ApiErrorUnprocessableEntity
} from '@conduit/utils';

import { addCommentBodySchema } from '../schema';
import { Factory } from '../service/Factory';

const factory = new Factory();
const apiAddComments = factory.newApiAddComments();

export const addComment: RequestHandler<Params, unknown, Body, unknown> = async (
  req,
  res
) => {
  const { user } = req;
  const { slug } = req.params;

  const { value: input, error } = addCommentBodySchema.validate(req.body);
  if (error) {
    throw new ApiErrorUnprocessableEntity({
      message:
        'Invalid or missing data in the request body. Please ensure all required fields are included and in the correct format.',
      cause: error
    });
  }

  const comment = input.comment.body;

  if (!user || !slug) {
    throw new ApiErrorInternalServerError({
      cause: new Error('Missing required parameters. Check router settings.')
    });
  }

  const response = await apiAddComments.execute({
    slug,
    userId: user.id,
    body: comment
  });
  res.json(response);
};

interface Body {
  comment: {
    body: string;
  };
}

interface Params {
  slug: string;
}

================
File: apps/article/controller/createArticle.ts
================
import { RequestHandler } from 'express';

import {
  ApiErrorInternalServerError,
  ApiErrorUnprocessableEntity
} from '@conduit/utils';

import { createArticleBodySchema } from '../schema';
import { Factory } from '../service/Factory';

const factory = new Factory();
const apiCreateArticle = factory.newApiCreateArticle();

export const createArticle: RequestHandler<unknown, unknown, Body, unknown> = async (
  req,
  res
) => {
  const { user } = req;

  const { value: input, error } = createArticleBodySchema.validate(req.body);
  if (error) {
    throw new ApiErrorUnprocessableEntity({
      message:
        'Invalid or missing data in the request body. Please ensure all required fields are included and in the correct format.',
      cause: error
    });
  }

  if (!user) {
    throw new ApiErrorInternalServerError({
      cause: new Error('Missing required parameters. Check router settings.')
    });
  }

  const { title, description, body, tagList } = input.article;

  const response = await apiCreateArticle.execute({
    title,
    description,
    body,
    tagList,
    author: user
  });
  res.json(response);
};

interface Body {
  article: {
    title: string;
    description: string;
    body: string;
    tagList: string[];
  };
}

================
File: apps/article/controller/deleteArticle.ts
================
import { RequestHandler } from 'express';

import { ApiErrorInternalServerError } from '@conduit/utils';

import { Factory } from '../service/Factory';

const factory = new Factory();
const apiDeleteArticle = factory.newApiDeleteArticle();

export const deleteArticle: RequestHandler<
  Params,
  unknown,
  unknown,
  unknown
> = async (req, res) => {
  const { user } = req;
  const { slug } = req.params;
  if (!user || !slug) {
    throw new ApiErrorInternalServerError({
      cause: new Error('Missing required parameters. Check router settings.')
    });
  }
  const response = await apiDeleteArticle.execute({ slug, userId: user.id });
  res.json(response);
};

interface Params {
  slug: string;
}

================
File: apps/article/controller/deleteComment.ts
================
import { RequestHandler } from 'express';

import { ApiErrorInternalServerError } from '@conduit/utils';

import { Factory } from '../service/Factory';

const factory = new Factory();
const apiDeleteComment = factory.newApiDeleteComment();

export const deleteComment: RequestHandler<
  Params,
  unknown,
  unknown,
  unknown
> = async (req, res) => {
  const { user } = req;
  const { id: commentId } = req.params;
  if (!user || !commentId) {
    throw new ApiErrorInternalServerError({
      cause: new Error('Missing required parameters. Check router settings.')
    });
  }
  const response = await apiDeleteComment.execute({ commentId, userId: user.id });
  res.json(response);
};

interface Params {
  id: string;
}

================
File: apps/article/controller/favoriteArticle.ts
================
import { RequestHandler } from 'express';

import { ApiErrorInternalServerError } from '@conduit/utils';

import { Factory } from '../service/Factory';

const factory = new Factory();
const apiFavoriteArticle = factory.newApiFavoriteArticle();

export const favoriteArticle: RequestHandler<
  Params,
  unknown,
  unknown,
  unknown
> = async (req, res) => {
  const { user } = req;
  const { slug } = req.params;
  if (!user || !slug) {
    throw new ApiErrorInternalServerError({
      cause: new Error('Missing required parameters. Check router settings.')
    });
  }
  const response = await apiFavoriteArticle.execute({ slug, userId: user.id });
  res.json(response);
};

interface Params {
  slug: string;
}

================
File: apps/article/controller/getArticle.ts
================
import { Request, Response } from 'express';

import { ApiErrorInternalServerError } from '@conduit/utils';

import { Factory } from '../service/Factory';

const factory = new Factory();
const apiGetArticle = factory.newApiGetArticle();

export const getArticle = async (
  req: Request<Params, unknown, unknown, unknown>,
  res: Response
) => {
  const { user } = req;
  const { slug } = req.params;
  if (!slug) {
    throw new ApiErrorInternalServerError({
      cause: new Error('Missing required parameters. Check router settings.')
    });
  }
  const response = await apiGetArticle.execute({ slug, userId: user?.id });
  res.json(response);
};

interface Params {
  slug: string;
}

================
File: apps/article/controller/getArticles.ts
================
import { RequestHandler } from 'express';

import { ApiErrorUnprocessableEntity } from '@conduit/utils';

import { getArticlesQuerySchema } from '../schema';
import { Factory } from '../service/Factory';

const factory = new Factory();
const apiListArticles = factory.newApiListArticles();

export const getArticles: RequestHandler<unknown, unknown, unknown, Query> = async (
  req,
  res
) => {
  const { user } = req;
  const { value, error } = getArticlesQuerySchema.validate(req.query);
  if (error) {
    throw new ApiErrorUnprocessableEntity({
      message:
        'Invalid or missing data in the request body. Please ensure all required fields are included and in the correct format.',
      cause: error
    });
  }

  const { tag, author, favorited, limit, offset } = value;

  const response = await apiListArticles.execute({
    tag,
    author,
    favorited,
    limit,
    offset,
    userId: user?.id
  });
  res.json(response);
};

export interface Query {
  tag?: string;
  author?: string;
  favorited?: string;
  limit: number;
  offset: number;
}

================
File: apps/article/controller/getArticleTags.ts
================
import { RequestHandler } from 'express';

import { Factory } from '../service/Factory';

const factory = new Factory();
const apiGetTags = factory.newApiGetTags();

export const getArticleTags: RequestHandler = async (_req, res) => {
  const response = await apiGetTags.execute();
  res.json(response);
};

================
File: apps/article/controller/getComments.ts
================
import { RequestHandler } from 'express';

import {
  ApiErrorInternalServerError,
  ApiErrorUnprocessableEntity
} from '@conduit/utils';

import { getCommentsQuerySchema } from '../schema';
import { Factory } from '../service/Factory';

const factory = new Factory();
const apiGetComments = factory.newApiGetComments();

export const getComments: RequestHandler<Params, unknown, unknown, Query> = async (
  req,
  res
) => {
  const { user } = req;
  const { slug } = req.params;
  const { value, error } = getCommentsQuerySchema.validate(req.query);
  if (error) {
    throw new ApiErrorUnprocessableEntity({
      message:
        'Invalid or missing data in the request body. Please ensure all required fields are included and in the correct format.',
      cause: error
    });
  }
  const { limit, offset } = value;

  if (!slug) {
    throw new ApiErrorInternalServerError({
      cause: new Error('Missing required parameters. Check router settings.')
    });
  }

  const response = await apiGetComments.execute({
    slug,
    userId: user?.id,
    limit,
    offset
  });
  res.json(response);
};

interface Params {
  slug: string;
}

interface Query {
  limit: number;
  offset: number;
}

================
File: apps/article/controller/getFeedArticles.ts
================
import { RequestHandler } from 'express';

import {
  ApiErrorInternalServerError,
  ApiErrorUnprocessableEntity
} from '@conduit/utils';

import { getArticleFeedQuerySchema } from '../schema';
import { Factory } from '../service/Factory';

const factory = new Factory();
const apiFeedArticles = factory.newApiFeedArticles();

export const getFeedArticles: RequestHandler<
  unknown,
  unknown,
  unknown,
  Query
> = async (req, res) => {
  const { value, error } = getArticleFeedQuerySchema.validate(req.query);
  if (error) {
    throw new ApiErrorUnprocessableEntity({
      message:
        'Invalid or missing data in the request body. Please ensure all required fields are included and in the correct format.',
      cause: error
    });
  }
  const { user } = req;
  if (!user) {
    throw new ApiErrorInternalServerError({
      cause: new Error('Missing required parameters. Check router settings.')
    });
  }

  const { limit, offset } = value;
  const response = await apiFeedArticles.execute({
    limit,
    offset,
    userId: user.id
  });
  res.json(response);
};

interface Query {
  limit: number;
  offset: number;
}

================
File: apps/article/controller/index.ts
================
export * from './addComment';
export * from './createArticle';
export * from './deleteArticle';
export * from './deleteComment';
export * from './favoriteArticle';
export * from './getArticle';
export * from './getArticles';
export * from './getArticleTags';
export * from './getComments';
export * from './getFeedArticles';
export * from './unfavoriteArticle';
export * from './updateArticle';

================
File: apps/article/controller/unfavoriteArticle.ts
================
import { RequestHandler } from 'express';

import { ApiErrorInternalServerError } from '@conduit/utils';

import { Factory } from '../service/Factory';

const factory = new Factory();
const apiUnfavoriteArticle = factory.newApiUnfavoriteArticle();

export const unfavoriteArticle: RequestHandler<
  Params,
  unknown,
  unknown,
  unknown
> = async (req, res) => {
  const { user } = req;
  const { slug } = req.params;
  if (!user || !slug) {
    throw new ApiErrorInternalServerError({
      cause: new Error('Missing required parameters. Check router settings.')
    });
  }
  const response = await apiUnfavoriteArticle.execute({ slug, userId: user.id });
  res.json(response);
};

interface Params {
  slug: string;
}

================
File: apps/article/controller/updateArticle.ts
================
import { RequestHandler } from 'express';

import {
  ApiErrorInternalServerError,
  ApiErrorUnprocessableEntity
} from '@conduit/utils';

import { updateArticleBodySchema } from '../schema';
import { Factory } from '../service/Factory';

const factory = new Factory();
const apiUpdateArticle = factory.newApiUpdateArticle();

export const updateArticle: RequestHandler<Params, unknown, Body, unknown> = async (
  req,
  res
) => {
  const { user } = req;
  const { slug } = req.params;
  if (!user || !slug) {
    throw new ApiErrorInternalServerError({
      cause: new Error('Missing required parameters. Check router settings.')
    });
  }

  const { value, error } = updateArticleBodySchema.validate(req.body);

  if (error) {
    throw new ApiErrorUnprocessableEntity({
      message:
        'Invalid or missing data in the request body. Please ensure all required fields are included and in the correct format.',
      cause: error
    });
  }

  const { title, description, body } = value.article;

  const response = await apiUpdateArticle.execute({
    slug,
    userId: user.id,
    title,
    description,
    body
  });
  res.json(response);
};

interface Body {
  article: {
    title?: string;
    description?: string;
    body?: string;
  };
}

interface Params {
  slug: string;
}

================
File: apps/article/Dockerfile
================
#
# Base image for the server
#
FROM node:18 AS base

ARG WORKSPACE_SCOPE=@conduit/article

# Set working directory
WORKDIR /app
RUN yarn global add turbo

# Copy the project files
COPY . .

# Use the build argument in the turbo prune command
RUN turbo prune --scope=$WORKSPACE_SCOPE --docker

#
# Installer image
# Add lockfile and package.json's of isolated sub-workspace
#
FROM base AS installer

# Set working directory
WORKDIR /app

# Copy necessary files to the installer stage
COPY .gitignore .gitignore
COPY --from=base /app/out/json/ .
COPY --from=base /app/out/yarn.lock ./yarn.lock

# Install dependencies
RUN yarn install

# Build the project using the variable scope
COPY --from=base /app/out/full/ .
RUN turbo run build --filter=$WORKSPACE_SCOPE...

================
File: apps/article/dto/DtoArticle.ts
================
export class DtoArticle {
  slug: string;
  title: string;
  description: string;
  body: string;
  tagList: string[];
  createdAt: Date;
  updatedAt: Date;
  favorited: boolean;
  favoritesCount: number;
  author: {
    username: string;
    bio?: string;
    image?: string;
    following: boolean;
  };

  constructor({
    slug,
    title,
    description,
    body,
    tagList,
    createdAt,
    updatedAt,
    favorited,
    favoritesCount,
    author
  }: DtoArticleConstructor) {
    this.slug = slug;
    this.title = title;
    this.description = description;
    this.body = body;
    this.tagList = tagList;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.favorited = favorited;
    this.favoritesCount = favoritesCount;
    this.author = {
      username: author.username,
      bio: author.bio,
      image: author.image,
      following: author.following
    };
  }
}

interface DtoArticleConstructor {
  slug: string;
  title: string;
  description: string;
  body: string;
  tagList: string[];
  createdAt: Date;
  updatedAt: Date;
  favorited: boolean;
  favoritesCount: number;
  author: {
    username: string;
    bio?: string;
    image?: string;
    following: boolean;
  };
}

================
File: apps/article/dto/DtoComment.ts
================
export class DtoComment {
  id: string;
  createdAt: Date;
  updatedAt: Date;
  body: string;
  author: {
    username: string;
    bio?: string;
    image?: string;
    following: boolean;
  };

  constructor({ id, createdAt, updatedAt, body, author }: DtoCommentConstructor) {
    this.id = id;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.body = body;
    this.author = {
      username: author.username,
      bio: author.bio,
      image: author.image,
      following: author.following
    };
  }
}

interface DtoCommentConstructor {
  id: string;
  createdAt: Date;
  updatedAt: Date;
  body: string;
  author: {
    username: string;
    bio?: string;
    image?: string;
    following: boolean;
  };
}

================
File: apps/article/dto/index.ts
================
export * from './DtoArticle';
export * from './DtoComment';

================
File: apps/article/jest.config.js
================
/** @type {import('jest').Config} */

module.exports = require('@conduit/config/jest.config');

================
File: apps/article/local.ts
================
import 'dotenv/config';

import { logger } from '@conduit/utils';

import { app } from './app';

app.listen(3200, () => {
  logger.info('User server is running on http://localhost:3200', { label: 'App' });
});

================
File: apps/article/package.json
================
{
  "name": "@conduit/article",
  "version": "1.0.0",
  "private": true,
  "description": "",
  "license": "MIT",
  "author": {
    "name": "Ken Yip",
    "email": "ken20206@gmail.com",
    "url": "https://kenyip.cc"
  },
  "main": "index.js",
  "workspaces": [
    "../../packages/config",
    "../../packages/core",
    "../../packages/utils",
    "../../packages/types",
    "../../packages/middleware"
  ],
  "scripts": {
    "build": "tsc",
    "check-types": "tsc --skipLibCheck --noEmit",
    "dev": "NODE_CONFIG_DIR='../../config' NODE_ENV=develop ts-node-dev --no-notify --exit-child --respawn --transpile-only --ignore-watch node_modules ./local.ts",
    "lint": "eslint .",
    "lint:fix": "eslint --fix .",
    "prettify": "prettier --write .",
    "test": "NODE_CONFIG_DIR='../../config' NODE_ENV=test jest tests/** --forceExit --maxWorkers=4 --detectOpenHandles",
    "test:coverage": "yarn test --coverage"
  },
  "dependencies": {
    "@conduit/config": "*",
    "@conduit/core": "*",
    "@conduit/middleware": "*",
    "@conduit/utils": "*",
    "express": "^4.21.1",
    "express-promise-router": "^4.1.1",
    "joi": "^17.13.3",
    "p-map": "4.0.0",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "@jest/types": "^29.6.3",
    "@types/aws-lambda": "^8.10.145",
    "@types/supertest": "^6.0.2",
    "@types/uuid": "^10.0.0",
    "better-sqlite3": "^11.3.0",
    "chance": "^1.1.12",
    "dotenv": "^16.4.5",
    "eslint": "^8.19.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "eslint-config-airbnb-typescript": "^17.0.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-jest": "^26.5.3",
    "eslint-plugin-prettier": "^5.2.1",
    "jest": "^26.2.0",
    "jest-when": "^3.6.0",
    "prettier": "^3.3.3",
    "prettier-plugin-packagejson": "^2.5.3",
    "supertest": "^6.0.0",
    "ts-jest": "^26.1.0",
    "ts-node": "^10.9.1",
    "ts-node-dev": "^2.0.0",
    "tsc-alias": "^1.8.10",
    "typescript": "^5.6.3"
  }
}

================
File: apps/article/route.ts
================
import Router from 'express-promise-router';

import { auth, authRequired } from '@conduit/middleware';

import {
  addComment,
  createArticle,
  deleteArticle,
  deleteComment,
  favoriteArticle,
  getArticle,
  getArticleTags,
  getArticles,
  getComments,
  getFeedArticles,
  unfavoriteArticle,
  updateArticle
} from './controller';

export const router = Router();

router
  .route('/api/articles/:slug/comments')
  .get(auth, getComments)
  .post(authRequired, addComment);

router.delete('/api/articles/:slug/comments/:id', authRequired, deleteComment);

router
  .route('/api/articles/:slug/favorite')
  .post(authRequired, favoriteArticle)
  .delete(authRequired, unfavoriteArticle);

router.get('/api/articles/feed', authRequired, getFeedArticles);

router
  .route('/api/articles/:slug')
  .get(auth, getArticle)
  .put(authRequired, updateArticle)
  .delete(authRequired, deleteArticle);

router
  .route('/api/articles')
  .get(auth, getArticles)
  .post(authRequired, createArticle);

router.get('/api/tags', getArticleTags);

router
  .route('/api/articles/:slug/favorite')
  .post(authRequired, favoriteArticle)
  .delete(authRequired, unfavoriteArticle);

================
File: apps/article/schema/addCommentBody.ts
================
import Joi from 'joi';

export const addCommentBodySchema = Joi.object({
  comment: Joi.object({
    body: Joi.string()
      .description(
        'This field contains the text of the comment that you want to create.'
      )
      .required()
  }).required()
}).required();

================
File: apps/article/schema/createArticleBody.ts
================
import Joi from 'joi';

export const createArticleBodySchema = Joi.object({
  article: Joi.object({
    title: Joi.string()
      .description(
        'This field specifies the title of the article that you want to create.'
      )
      .required(),
    description: Joi.string()
      .description(
        'This field provides a brief summary or introduction to the article.'
      )
      .required(),
    body: Joi.string()
      .description(
        'This field contains the main content of the article, and should provides more detailed information on the topic.'
      )
      .required(),
    tagList: Joi.array()
      .items(Joi.string())
      .description(
        'One or more tags to help users find the article easily. Tags are specified as an array of strings.'
      )
      .empty(null)
      .default([])
  }).required()
}).required();

================
File: apps/article/schema/getArticleFeedQuery.ts
================
import Joi from 'joi';

export const getArticleFeedQuerySchema = Joi.object({
  limit: Joi.number().description('The numbers of items to return').default(20),
  offset: Joi.number()
    .description(
      'The number of items to skip before starting to collect the result set'
    )
    .default(0)
});

================
File: apps/article/schema/getArticlesQuery.ts
================
import Joi from 'joi';

export const getArticlesQuerySchema = Joi.object({
  limit: Joi.number().description('The numbers of items to return').default(20),
  offset: Joi.number()
    .description(
      'The number of items to skip before starting to collect the result set'
    )
    .default(0),
  tag: Joi.string()
    .description('A string representing the tag by which to filter the articles')
    .empty(null),
  author: Joi.string()
    .description(
      'A string representing the username of the author by which to filter the articles'
    )
    .empty(null),
  favorited: Joi.string()
    .description(
      'A string representing the username of the user who favorited the articles to be included in the result set'
    )
    .empty(null)
})
  .optional()
  .default({});

================
File: apps/article/schema/getCommentsQuery.ts
================
import Joi from 'joi';

export const getCommentsQuerySchema = Joi.object({
  limit: Joi.number().description('The numbers of items to return').default(10),
  offset: Joi.number()
    .description(
      'The number of items to skip before starting to collect the result set'
    )
    .default(0)
});

================
File: apps/article/schema/index.ts
================
export * from './addCommentBody';
export * from './createArticleBody';
export * from './getArticleFeedQuery';
export * from './getArticlesQuery';
export * from './updateArticleBody';
export * from './getCommentsQuery';

================
File: apps/article/schema/updateArticleBody.ts
================
import Joi from 'joi';

export const updateArticleBodySchema = Joi.object({
  article: Joi.object({
    title: Joi.string()
      .description(
        'This field specifies the title of the article that you want to create.'
      )
      .empty(null),
    description: Joi.string()
      .description(
        'This field provides a brief summary or introduction to the article.'
      )
      .empty(null),
    body: Joi.string()
      .description(
        'This field contains the main content of the article, and should provides more detailed information on the topic.'
      )
      .empty(null)
  }).required()
}).required();

================
File: apps/article/server.ts
================
import { configureLambda } from '@conduit/middleware';

import { app } from './app';

export const handler = configureLambda({ app });

================
File: apps/article/service/ApiAddComments/ApiAddComments.ts
================
import { ArticleNotFoundError, ArticleService } from '@conduit/core/service';
import {
  ApiErrorInternalServerError,
  ApiErrorNotFound,
  logger
} from '@conduit/utils';

import { DtoComment } from '../../dto';
import {
  ApiAddCommentsConstructor,
  ApiAddCommentsInput,
  ApiAddCommentsOutput
} from './types';

export class ApiAddComments {
  private articleService: ArticleService;

  constructor({ articleService }: ApiAddCommentsConstructor) {
    this.articleService = articleService;
  }

  async execute({ slug, body, userId }: ApiAddCommentsInput): ApiAddCommentsOutput {
    try {
      const article = await this.articleService.getArticleBySlug({
        slug
      });
      if (!article) {
        throw new ArticleNotFoundError({});
      }
      const commentId = await this.articleService.createArticleComment({
        articleId: article.id,
        body,
        userId
      });
      const comment = await this.articleService
        .getArticleCommentById({
          id: commentId
        })
        .then((row) => {
          if (!row) {
            return undefined;
          }
          return new DtoComment({
            id: row.id,
            body: row.body,
            createdAt: row.createdAt,
            updatedAt: row.updatedAt,
            author: {
              username: row.author.username,
              bio: row.author.bio,
              image: row.author.image,
              following: Boolean(row.author.following)
            }
          });
        });

      if (!comment) {
        throw new ApiErrorInternalServerError({});
      }
      return {
        comment
      };
    } catch (error) {
      throw this.convertErrorToApiError(error);
    }
  }

  private convertErrorToApiError(error: any) {
    if (error instanceof ArticleNotFoundError) {
      throw new ApiErrorNotFound({
        message: error.message,
        cause: error
      });
    }
    logger.error(error);
    return new ApiErrorInternalServerError({});
  }
}

================
File: apps/article/service/ApiAddComments/index.ts
================
export { ApiAddComments } from './ApiAddComments';

================
File: apps/article/service/ApiAddComments/types.ts
================
import { ArticleService } from '@conduit/core';

import { DtoComment } from '../../dto';

export interface ApiAddCommentsConstructor {
  articleService: ArticleService;
}

export interface ApiAddCommentsInput {
  slug: string;
  body: string;
  userId: string;
}

export type ApiAddCommentsOutput = Promise<{
  comment: DtoComment;
}>;

================
File: apps/article/service/ApiCreateArticle/ApiCreateArticle.ts
================
import { ArticleService, ArticleTitleAlreadyTakenError } from '@conduit/core';
import {
  ApiErrorConflict,
  ApiErrorInternalServerError,
  logger
} from '@conduit/utils';

import { DtoArticle } from '../../dto';
import {
  ApiCreateArticleConstructor,
  ApiCreateArticleInput,
  ApiCreateArticleOutput
} from './types';

export class ApiCreateArticle {
  private articleService: ArticleService;

  constructor({ articleService }: ApiCreateArticleConstructor) {
    this.articleService = articleService;
  }

  async execute({
    title,
    description,
    body,
    tagList,
    author
  }: ApiCreateArticleInput): ApiCreateArticleOutput {
    try {
      const articleId = await this.articleService.createArticle({
        title,
        description,
        body,
        userId: author.id
      });

      await this.articleService.createArticleTags({
        articleId,
        tagList
      });

      const article = await this.articleService.getArticleById({ id: articleId });

      if (!article) {
        throw new ApiErrorInternalServerError({});
      }

      const dtoArticle = new DtoArticle({
        slug: article.slug,
        title: article.title,
        description: article.description,
        body: article.body,
        tagList,
        createdAt: article.createdAt,
        updatedAt: article.updatedAt,
        favorited: false,
        favoritesCount: 0,
        author: {
          username: author.username,
          bio: author.bio,
          image: author.image,
          following: false
        }
      });
      return { article: dtoArticle };
    } catch (error) {
      throw this.convertErrorToApiError(error);
    }
  }

  private convertErrorToApiError(error: unknown) {
    if (error instanceof ArticleTitleAlreadyTakenError) {
      return new ApiErrorConflict({
        message: error.message,
        cause: error
      });
    }
    logger.error(error);
    return new ApiErrorInternalServerError({});
  }
}

================
File: apps/article/service/ApiCreateArticle/index.ts
================
export { ApiCreateArticle } from './ApiCreateArticle';
export { ApiCreateArticleInput, ApiCreateArticleOutput } from './types';

================
File: apps/article/service/ApiCreateArticle/types.ts
================
import { ArticleService, DbDtoUser } from '@conduit/core';

import { DtoArticle } from '../../dto';

export interface ApiCreateArticleConstructor {
  articleService: ArticleService;
}

export interface ApiCreateArticleInput {
  title: string;
  description: string;
  body: string;
  tagList: string[];
  author: DbDtoUser;
}

export type ApiCreateArticleOutput = Promise<{
  article: DtoArticle;
}>;

================
File: apps/article/service/ApiDeleteArticle/ApiDeleteArticle.ts
================
import { ArticleNotFoundError, ArticleService } from '@conduit/core/service';
import { logger } from '@conduit/utils';
import {
  ApiError,
  ApiErrorForbidden,
  ApiErrorInternalServerError,
  ApiErrorNotFound
} from '@conduit/utils/error';

import {
  ApiDeleteArticleConstructor,
  ApiDeleteArticleInput,
  ApiDeleteArticleOutput
} from './types';

export class ApiDeleteArticle {
  private articleService: ArticleService;

  constructor({ articleService }: ApiDeleteArticleConstructor) {
    this.articleService = articleService;
  }

  async execute({ slug, userId }: ApiDeleteArticleInput): ApiDeleteArticleOutput {
    try {
      const article = await this.articleService.getArticleBySlug({
        slug
      });
      if (!article) {
        throw new ArticleNotFoundError({ slug });
      }
      if (article.userId !== userId) {
        throw new ApiErrorForbidden({
          message: 'You are not able to delete article that do not belong to you.'
        });
      }
      await this.articleService.deleteArticleById({ id: article.id });
    } catch (error) {
      throw this.convertErrorToApiError(error);
    }
  }

  private convertErrorToApiError(error: any) {
    if (error instanceof ApiError) {
      return error;
    }
    if (error instanceof ArticleNotFoundError) {
      throw new ApiErrorNotFound({
        message: error.message,
        cause: error
      });
    }
    logger.error(error);
    return new ApiErrorInternalServerError({});
  }
}

================
File: apps/article/service/ApiDeleteArticle/index.ts
================
export { ApiDeleteArticle } from './ApiDeleteArticle';

================
File: apps/article/service/ApiDeleteArticle/types.ts
================
import { ArticleService } from '@conduit/core';

export interface ApiDeleteArticleConstructor {
  articleService: ArticleService;
}

export interface ApiDeleteArticleInput {
  slug: string;
  userId: string;
}

export type ApiDeleteArticleOutput = Promise<void>;

================
File: apps/article/service/ApiDeleteComment/ApiDeleteComment.ts
================
import { ArticleService } from '@conduit/core/service';
import {
  ApiError,
  ApiErrorForbidden,
  ApiErrorInternalServerError,
  ApiErrorNotFound
} from '@conduit/utils/error';

import {
  ApiDeleteCommentConstructor,
  ApiDeleteCommentInput,
  ApiDeleteCommentOutput
} from './types';

export class ApiDeleteComment {
  private articleService: ArticleService;

  constructor({ articleService }: ApiDeleteCommentConstructor) {
    this.articleService = articleService;
  }

  async execute({
    commentId,
    userId
  }: ApiDeleteCommentInput): ApiDeleteCommentOutput {
    try {
      const comment = await this.articleService.getArticleCommentById({
        id: commentId
      });

      if (!comment) {
        throw new ApiErrorNotFound({
          message: "The requested article's comment was not found."
        });
      }

      if (userId !== comment.author.id) {
        throw new ApiErrorForbidden({
          message: 'You are not able to delete comments that do not belong to you.'
        });
      }

      await this.articleService.deleteArticleById({ id: commentId });
    } catch (error) {
      throw this.convertErrorToApiError(error);
    }
  }

  private convertErrorToApiError(error: any) {
    if (error instanceof ApiError) {
      return error;
    }
    return new ApiErrorInternalServerError({});
  }
}

================
File: apps/article/service/ApiDeleteComment/index.ts
================
export { ApiDeleteComment } from './ApiDeleteComment';
export { ApiDeleteCommentInput, ApiDeleteCommentOutput } from './types';

================
File: apps/article/service/ApiDeleteComment/types.ts
================
import { ArticleService } from '@conduit/core/service';

export interface ApiDeleteCommentConstructor {
  articleService: ArticleService;
}

export interface ApiDeleteCommentInput {
  commentId: string;
  userId: string;
}

export type ApiDeleteCommentOutput = Promise<void>;

================
File: apps/article/service/ApiFavoriteArticle/ApiFavoriteArticle.ts
================
import {
  ArticleAlreadyFavoritedError,
  ArticleNotFoundError,
  ArticleService
} from '@conduit/core/service';
import {
  ApiError,
  ApiErrorBadRequest,
  ApiErrorInternalServerError,
  ApiErrorNotFound
} from '@conduit/utils/error';

import { DtoArticle } from '../../dto';
import {
  ApiFavoriteArticleConstructor,
  ApiFavoriteArticleInput,
  ApiFavoriteArticleOutput
} from './types';

export class ApiFavoriteArticle {
  private articleService: ArticleService;

  constructor({ articleService }: ApiFavoriteArticleConstructor) {
    this.articleService = articleService;
  }

  async execute({
    slug,
    userId
  }: ApiFavoriteArticleInput): ApiFavoriteArticleOutput {
    try {
      const article = await this.articleService.getArticleBySlug({
        slug,
        requestingUserId: userId
      });

      if (!article) {
        throw new ArticleNotFoundError({});
      }

      await this.articleService.favoriteArticle({
        userId,
        articleId: article.id
      });

      const tags = await this.articleService.getTagsByArticleId({
        articleId: article.id
      });

      const data = new DtoArticle({
        ...article,
        favoritesCount: article.favoritesCount + 1,
        tagList: tags.map((tag) => tag.tag),
        favorited: true
      });

      return { article: data };
    } catch (error) {
      throw this.convertErrorToApiError(error);
    }
  }

  private convertErrorToApiError(error: any) {
    if (error instanceof ApiError) {
      return error;
    }
    if (error instanceof ArticleNotFoundError) {
      return new ApiErrorNotFound({
        message: error.message,
        cause: error
      });
    }
    if (error instanceof ArticleAlreadyFavoritedError) {
      return new ApiErrorBadRequest({
        message: error.message,
        cause: error
      });
    }
    return new ApiErrorInternalServerError({});
  }
}

================
File: apps/article/service/ApiFavoriteArticle/index.ts
================
export { ApiFavoriteArticle } from './ApiFavoriteArticle';

================
File: apps/article/service/ApiFavoriteArticle/types.ts
================
import { ArticleService } from '@conduit/core';

import { DtoArticle } from '../../dto';

export interface ApiFavoriteArticleConstructor {
  articleService: ArticleService;
}

export interface ApiFavoriteArticleInput {
  slug: string;
  userId: string;
}

export type ApiFavoriteArticleOutput = Promise<{ article: DtoArticle }>;

================
File: apps/article/service/ApiFeedArticles/ApiFeedArticles.ts
================
import { ArticleService } from '@conduit/core/service';
import { ApiError, ApiErrorInternalServerError } from '@conduit/utils/error';

import { DtoArticle } from '../../dto';
import {
  ApiFeedArticlesConstructor,
  ApiFeedArticlesInput,
  ApiFeedArticlesOutput
} from './types';

export class ApiFeedArticles {
  private articleService: ArticleService;

  constructor({ articleService }: ApiFeedArticlesConstructor) {
    this.articleService = articleService;
  }

  async execute({
    limit,
    offset,
    userId
  }: ApiFeedArticlesInput): ApiFeedArticlesOutput {
    try {
      const count = await this.articleService.countArticles({
        followedBy: userId
      });

      if (count < 1) {
        return {
          articles: [],
          articlesCount: 0
        };
      }

      const articles = await this.articleService.getArticles({
        followedBy: userId,
        requestingUserId: userId,
        limit,
        offset
      });

      const tagLists = await this.articleService.getTagsByArticleIds({
        articleIds: articles.map((article) => article.id)
      });

      const data = articles.map((article) => {
        const tagList = tagLists[article.id] || [];
        return new DtoArticle({
          ...article,
          tagList: tagList.map((tag) => tag.tag)
        });
      });

      return {
        articles: data,
        articlesCount: count
      };
    } catch (error) {
      throw this.convertErrorToApiError(error);
    }
  }

  private convertErrorToApiError(error: any) {
    if (error instanceof ApiError) {
      return error;
    }
    return new ApiErrorInternalServerError({});
  }
}

================
File: apps/article/service/ApiFeedArticles/index.ts
================
export { ApiFeedArticles } from './ApiFeedArticles';

================
File: apps/article/service/ApiFeedArticles/types.ts
================
import { ArticleService } from '@conduit/core';

import { DtoArticle } from '../../dto';

export interface ApiFeedArticlesConstructor {
  articleService: ArticleService;
}

export interface ApiFeedArticlesInput {
  limit: number;
  offset: number;
  userId: string;
}

export type ApiFeedArticlesOutput = Promise<{
  articles: DtoArticle[];
  articlesCount: number;
}>;

================
File: apps/article/service/ApiGetArticle/ApiGetArticle.ts
================
import { ArticleNotFoundError, ArticleService } from '@conduit/core/service';
import {
  ApiError,
  ApiErrorInternalServerError,
  ApiErrorNotFound
} from '@conduit/utils/error';

import { DtoArticle } from '../../dto';
import {
  ApiGetArticleConstructor,
  ApiGetArticleInput,
  ApiGetArticleOutput
} from './types';

export class ApiGetArticle {
  private articleService: ArticleService;

  constructor({ articleService }: ApiGetArticleConstructor) {
    this.articleService = articleService;
  }

  async execute({ slug, userId }: ApiGetArticleInput): ApiGetArticleOutput {
    try {
      const article = await this.articleService.getArticleBySlug({
        slug,
        requestingUserId: userId
      });

      if (!article) {
        throw new ApiErrorNotFound({
          message: 'Invalid article'
        });
      }

      const tags = await this.articleService.getTagsByArticleId({
        articleId: article.id
      });

      const data = new DtoArticle({
        ...article,
        tagList: tags.map((tag) => tag.tag)
      });
      return { article: data };
    } catch (error) {
      throw this.convertErrorToApiError(error);
    }
  }

  private convertErrorToApiError(error: any) {
    if (error instanceof ApiError) {
      return error;
    }
    if (error instanceof ArticleNotFoundError) {
      throw new ApiErrorNotFound({
        message: error.message,
        cause: error
      });
    }
    return new ApiErrorInternalServerError({});
  }
}

================
File: apps/article/service/ApiGetArticle/index.ts
================
export { ApiGetArticle } from './ApiGetArticle';

================
File: apps/article/service/ApiGetArticle/types.ts
================
import { ArticleService } from '@conduit/core';

import { DtoArticle } from '../../dto';

export interface ApiGetArticleConstructor {
  articleService: ArticleService;
}

export interface ApiGetArticleInput {
  slug: string;
  userId?: string;
}

export type ApiGetArticleOutput = Promise<{
  article: DtoArticle;
}>;

================
File: apps/article/service/ApiGetComments/ApiGetComments.ts
================
import { ArticleService } from '@conduit/core/service';
import { logger } from '@conduit/utils';
import {
  ApiError,
  ApiErrorInternalServerError,
  ApiErrorNotFound
} from '@conduit/utils/error';

import { DtoComment } from '../../dto';
import {
  ApiGetCommentsConstructor,
  ApiGetCommentsInput,
  ApiGetCommentsOutput
} from './types';

export class ApiGetComments {
  private articleService: ArticleService;

  constructor({ articleService }: ApiGetCommentsConstructor) {
    this.articleService = articleService;
  }

  async execute({
    slug,
    userId,
    limit,
    offset
  }: ApiGetCommentsInput): ApiGetCommentsOutput {
    try {
      const article = await this.articleService.getArticleBySlug({
        slug
      });
      if (!article) {
        throw new ApiErrorNotFound({});
      }
      const { comments, count } =
        await this.articleService.getArticleCommentsByArticleId({
          articleId: article.id,
          requestingUserId: userId,
          limit,
          offset
        });
      return {
        comments: comments.map((comment) => new DtoComment(comment)),
        count
      };
    } catch (error) {
      logger.error(error);
      throw this.convertErrorToApiError(error);
    }
  }

  private convertErrorToApiError(error: any) {
    if (error instanceof ApiError) {
      return error;
    }
    return new ApiErrorInternalServerError({});
  }
}

================
File: apps/article/service/ApiGetComments/index.ts
================
export { ApiGetComments } from './ApiGetComments';

================
File: apps/article/service/ApiGetComments/types.ts
================
import { ArticleService } from '@conduit/core';

import { DtoComment } from '../../dto';

export interface ApiGetCommentsConstructor {
  articleService: ArticleService;
}

export interface ApiGetCommentsInput {
  slug: string;
  limit: number;
  offset: number;
  userId?: string;
}

export type ApiGetCommentsOutput = Promise<{
  comments: DtoComment[];
  count: number;
}>;

================
File: apps/article/service/ApiGetTags/ApiGetTags.ts
================
import { ArticleService } from '@conduit/core/service';
import { ApiErrorInternalServerError } from '@conduit/utils';

import { ApiGetTagsConstructor, ApiGetTagsOutput } from './types';

export class ApiGetTags {
  private articleService: ArticleService;

  constructor({ articleService }: ApiGetTagsConstructor) {
    this.articleService = articleService;
  }

  async execute(): ApiGetTagsOutput {
    try {
      const tags = await this.articleService.getAvailableTags();
      return { tags };
    } catch (error) {
      throw new ApiErrorInternalServerError({});
    }
  }
}

================
File: apps/article/service/ApiGetTags/index.ts
================
export { ApiGetTags } from './ApiGetTags';

================
File: apps/article/service/ApiGetTags/types.ts
================
import { ArticleService } from '@conduit/core';

export interface ApiGetTagsConstructor {
  articleService: ArticleService;
}

export type ApiGetTagsOutput = Promise<{
  tags: string[];
}>;

================
File: apps/article/service/ApiListArticles/ApiListArticles.ts
================
import { ArticleService } from '@conduit/core/service';
import { logger } from '@conduit/utils';
import { ApiError, ApiErrorInternalServerError } from '@conduit/utils/error';

import { DtoArticle } from '../../dto';
import {
  ApiListArticlesConstructor,
  ApiListArticlesInput,
  ApiListArticlesOutput
} from './types';

export class ApiListArticles {
  private articleService: ArticleService;

  constructor({ articleService }: ApiListArticlesConstructor) {
    this.articleService = articleService;
  }

  async execute({
    tag,
    author,
    favorited,
    limit,
    offset,
    userId
  }: ApiListArticlesInput): ApiListArticlesOutput {
    try {
      const count = await this.articleService.countArticles({
        tags: tag ? [tag] : undefined,
        author,
        favorited
      });

      if (count < 1) {
        return {
          articles: [],
          articlesCount: 0
        };
      }

      const articles = await this.articleService.getArticles({
        tags: tag ? [tag] : undefined,
        author,
        favorited,
        limit,
        offset,
        requestingUserId: userId
      });

      const tagLists = await this.articleService.getTagsByArticleIds({
        articleIds: articles.map((article) => article.id)
      });

      const data = articles.map((article) => {
        const tagList = tagLists[article.id] || [];
        return new DtoArticle({
          ...article,
          tagList: tagList.map((row) => row.tag)
        });
      });

      return {
        articles: data,
        articlesCount: count
      };
    } catch (error) {
      logger.error(error);
      throw this.convertErrorToApiError(error);
    }
  }

  private convertErrorToApiError(error: any) {
    if (error instanceof ApiError) {
      return error;
    }
    return new ApiErrorInternalServerError({});
  }
}

================
File: apps/article/service/ApiListArticles/index.ts
================
export { ApiListArticles } from './ApiListArticles';

================
File: apps/article/service/ApiListArticles/types.ts
================
import { ArticleService } from '@conduit/core/service';

import { DtoArticle } from '../../dto';

export interface ApiListArticlesConstructor {
  articleService: ArticleService;
}

export interface ApiListArticlesInput {
  tag?: string;
  author?: string;
  favorited?: string;
  offset: number;
  limit: number;
  userId?: string;
}

export type ApiListArticlesOutput = Promise<{
  articles: DtoArticle[];
  articlesCount: number;
}>;

================
File: apps/article/service/ApiUnfavoriteArticle/ApiUnfavoriteArticle.ts
================
import {
  ArticleNotFoundError,
  ArticleNotYetFavoritedError,
  ArticleService
} from '@conduit/core/service';
import {
  ApiError,
  ApiErrorBadRequest,
  ApiErrorInternalServerError,
  ApiErrorNotFound
} from '@conduit/utils/error';

import { DtoArticle } from '../../dto';
import {
  ApiUnfavoriteArticleConstructor,
  ApiUnfavoriteArticleInput,
  ApiUnfavoriteArticleOutput
} from './types';

export class ApiUnfavoriteArticle {
  private articleService: ArticleService;

  constructor({ articleService }: ApiUnfavoriteArticleConstructor) {
    this.articleService = articleService;
  }

  async execute({
    slug,
    userId
  }: ApiUnfavoriteArticleInput): Promise<ApiUnfavoriteArticleOutput> {
    try {
      const article = await this.articleService.getArticleBySlug({
        slug,
        requestingUserId: userId
      });

      if (!article) {
        throw new ArticleNotFoundError({});
      }

      await this.articleService.unfavoriteArticle({
        userId,
        articleId: article.id
      });

      const tags = await this.articleService.getTagsByArticleId({
        articleId: article.id
      });

      const data = new DtoArticle({
        ...article,
        favoritesCount: article.favoritesCount - 1,
        tagList: tags.map((tag) => tag.tag),
        favorited: false
      });

      return { article: data };
    } catch (error) {
      throw this.convertErrorToApiError(error);
    }
  }

  private convertErrorToApiError(error: any) {
    if (error instanceof ApiError) {
      return error;
    }
    if (error instanceof ArticleNotFoundError) {
      return new ApiErrorNotFound({
        message: error.message,
        cause: error
      });
    }
    if (error instanceof ArticleNotYetFavoritedError) {
      return new ApiErrorBadRequest({
        message: error.message,
        cause: error
      });
    }
    return new ApiErrorInternalServerError({});
  }
}

================
File: apps/article/service/ApiUnfavoriteArticle/index.ts
================
export { ApiUnfavoriteArticle } from './ApiUnfavoriteArticle';

================
File: apps/article/service/ApiUnfavoriteArticle/types.ts
================
import { ArticleService } from '@conduit/core';

import { DtoArticle } from '../../dto';

export interface ApiUnfavoriteArticleConstructor {
  articleService: ArticleService;
}

export interface ApiUnfavoriteArticleInput {
  slug: string;
  userId: string;
}

export type ApiUnfavoriteArticleOutput = Promise<{ article: DtoArticle }>;

================
File: apps/article/service/ApiUpdateArticle/ApiUpdateArticle.ts
================
import { isNil } from 'lodash';

import {
  ArticleService,
  ArticleTitleAlreadyTakenError
} from '@conduit/core/service';
import { logger } from '@conduit/utils';
import {
  ApiError,
  ApiErrorConflict,
  ApiErrorForbidden,
  ApiErrorInternalServerError,
  ApiErrorNotFound,
  ApiErrorUnprocessableEntity
} from '@conduit/utils/error';

import { DtoArticle } from '../../dto';
import { ApiGetArticle } from '../ApiGetArticle';
import {
  ApiUpdateArticleConstructor,
  ApiUpdateArticleInput,
  ApiUpdateArticleOutput,
  GetArticleBySlugInput,
  GetArticleBySlugOutput,
  GetUpdatedArticleInput,
  GetUpdatedArticleOutput,
  ValidateInputInput,
  ValidateInputOutput
} from './types';

export class ApiUpdateArticle {
  private articleService: ArticleService;
  private apiGetArticle: ApiGetArticle;

  constructor({ articleService }: ApiUpdateArticleConstructor) {
    this.articleService = articleService;
    this.apiGetArticle = new ApiGetArticle({ articleService });
  }

  async execute({
    slug,
    userId,
    title,
    description,
    body
  }: ApiUpdateArticleInput): ApiUpdateArticleOutput {
    try {
      const article = await this.getArticleBySlug({ slug });

      this.validateInput({
        userId,
        authorId: article.userId,
        title,
        description,
        body
      });

      await this.articleService.updateArticleById({
        id: article.id,
        title,
        description,
        body
      });

      const updated = await this.getUpdatedArticle({
        articleId: article.id
      });

      return {
        article: updated
      };
    } catch (error) {
      throw this.convertErrorToApiError(error);
    }
  }

  private async getUpdatedArticle({
    articleId
  }: GetUpdatedArticleInput): GetUpdatedArticleOutput {
    const article = await this.articleService.getArticleById({
      id: articleId
    });
    if (article === undefined) {
      throw new ApiErrorInternalServerError({});
    }
    const tags = await this.articleService.getTagsByArticleId({
      articleId: article.id
    });
    const data = new DtoArticle({
      ...article,
      tagList: tags.map((tag) => tag.tag)
    });
    return data;
  }

  private async getArticleBySlug({
    slug
  }: GetArticleBySlugInput): GetArticleBySlugOutput {
    const article = await this.articleService.getArticleBySlug({
      slug
    });
    if (article === undefined) {
      throw new ApiErrorNotFound({});
    }
    return article;
  }

  private validateInput({
    userId,
    authorId,
    title,
    description,
    body
  }: ValidateInputInput): ValidateInputOutput {
    if (userId !== authorId) {
      throw new ApiErrorForbidden({
        message: 'You are not able to update article that do not belong to you.'
      });
    }
    if (isNil(title) && isNil(description) && isNil(body)) {
      throw new ApiErrorUnprocessableEntity({
        message: 'At least one data field must be provided to update the article.'
      });
    }
  }

  private convertErrorToApiError(error: any) {
    if (error instanceof ApiError) {
      return error;
    }

    if (error instanceof ArticleTitleAlreadyTakenError) {
      throw new ApiErrorConflict({
        message: error.message,
        cause: error
      });
    }
    logger.error(error);
    return new ApiErrorInternalServerError({});
  }
}

================
File: apps/article/service/ApiUpdateArticle/index.ts
================
export { ApiUpdateArticle } from './ApiUpdateArticle';

================
File: apps/article/service/ApiUpdateArticle/types.ts
================
import { ArticleService, DbDtoArticle } from '@conduit/core';

import { DtoArticle } from '../../dto';

export interface ApiUpdateArticleConstructor {
  articleService: ArticleService;
}

export interface ApiUpdateArticleInput {
  slug: string;
  userId: string;
  title?: string;
  description?: string;
  body?: string;
}

export type ApiUpdateArticleOutput = Promise<{
  article: DtoArticle;
}>;

/**
 *
 * function: getArticleBySlug
 *
 */
export interface GetArticleBySlugInput {
  slug: string;
}

export type GetArticleBySlugOutput = Promise<DbDtoArticle>;

/**
 *
 * function: validateInput
 *
 */
export interface ValidateInputInput {
  authorId: string;
  userId: string;
  title?: string;
  description?: string;
  body?: string;
}

export type ValidateInputOutput = void;

/**
 *
 * function: getUpdatedArticle
 *
 */
export interface GetUpdatedArticleInput {
  articleId: string;
}

export type GetUpdatedArticleOutput = Promise<DtoArticle>;

================
File: apps/article/service/Factory.ts
================
import { ArticleService, ServiceFactory } from '@conduit/core';

import { ApiAddComments } from './ApiAddComments';
import { ApiCreateArticle } from './ApiCreateArticle';
import { ApiDeleteArticle } from './ApiDeleteArticle';
import { ApiDeleteComment } from './ApiDeleteComment';
import { ApiFavoriteArticle } from './ApiFavoriteArticle';
import { ApiFeedArticles } from './ApiFeedArticles';
import { ApiGetArticle } from './ApiGetArticle';
import { ApiGetComments } from './ApiGetComments';
import { ApiGetTags } from './ApiGetTags';
import { ApiListArticles } from './ApiListArticles';
import { ApiUnfavoriteArticle } from './ApiUnfavoriteArticle';
import { ApiUpdateArticle } from './ApiUpdateArticle';

export class Factory {
  private articleService: ArticleService;

  constructor() {
    const factory = new ServiceFactory();
    this.articleService = factory.newArticleService();
  }

  newApiAddComments(): ApiAddComments {
    return new ApiAddComments({ articleService: this.articleService });
  }

  newApiCreateArticle(): ApiCreateArticle {
    return new ApiCreateArticle({ articleService: this.articleService });
  }

  newApiDeleteArticle(): ApiDeleteArticle {
    return new ApiDeleteArticle({ articleService: this.articleService });
  }

  newApiDeleteComment(): ApiDeleteComment {
    return new ApiDeleteComment({ articleService: this.articleService });
  }

  newApiFavoriteArticle(): ApiFavoriteArticle {
    return new ApiFavoriteArticle({
      articleService: this.articleService
    });
  }

  newApiFeedArticles(): ApiFeedArticles {
    return new ApiFeedArticles({
      articleService: this.articleService
    });
  }

  newApiGetArticle(): ApiGetArticle {
    return new ApiGetArticle({ articleService: this.articleService });
  }

  newApiGetComments(): ApiGetComments {
    return new ApiGetComments({ articleService: this.articleService });
  }

  newApiGetTags(): ApiGetTags {
    return new ApiGetTags({ articleService: this.articleService });
  }

  newApiListArticles(): ApiListArticles {
    return new ApiListArticles({ articleService: this.articleService });
  }

  newApiUnfavoriteArticle(): ApiUnfavoriteArticle {
    return new ApiUnfavoriteArticle({
      articleService: this.articleService
    });
  }

  newApiUpdateArticle(): ApiUpdateArticle {
    return new ApiUpdateArticle({ articleService: this.articleService });
  }
}

================
File: apps/article/service/index.ts
================
export * from './ApiAddComments';
export * from './ApiCreateArticle';
export * from './ApiDeleteArticle';
export * from './ApiDeleteComment';
export * from './ApiFavoriteArticle';
export * from './ApiFeedArticles';
export * from './ApiGetArticle';
export * from './ApiGetComments';
export * from './ApiGetTags';
export * from './ApiListArticles';
export * from './ApiUnfavoriteArticle';
export * from './ApiUpdateArticle';

================
File: apps/article/tests/basic/create-article.spec.ts
================
import assert from 'assert';
import Chance from 'chance';
import supertest from 'supertest';

import { ServiceFactory, dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';

const request = supertest(app);

describe('POST /api/articles', () => {
  it('should be able to create an article', async () => {
    const { accessToken } = await setup();
    const response = await request
      .post('/api/articles')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({
        article: {
          title: 'How to train your dragon',
          description: 'Ever wonder how?',
          body: 'You have to believe',
          tagList: ['react.js', 'angular.js', 'dragons']
        }
      });
    expect(response.status).toBe(200);
    expect(response.body.article).toBeDefined();
    const { article } = response.body;
    expect(article.tagList).toHaveLength(3);
  });

  it("should return a status code of 401 - Unauthorized if the client doesn't provide auth headers", async () => {
    const response = await request.post('/api/articles').send({
      article: {
        title: 'How to train your dragon',
        description: 'Ever wonder how?',
        body: 'You have to believe',
        tagList: ['react.js', 'angular.js', 'dragons']
      }
    });
    expect(response.status).toBe(401);
  });

  it('should return a status code of 422 - Unprocessable Entity if the client provides invalid data', async () => {
    const { accessToken } = await setup();
    const response = await request
      .post('/api/articles')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ article: { title: 'How to train your dragon' } });
    expect(response.status).toBe(422);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const factory = new ServiceFactory();
  const userService = factory.newUserService();
  const authService = factory.newAuthService();
  const userId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const accessToken = authService.generateAccessToken({
    userId,
    loginId: chance.guid()
  });
  const user = await userService.getUserById({ id: userId });
  assert(user);
  return {
    userService,
    user,
    accessToken
  };
};

================
File: apps/article/tests/basic/delete-article.spec.ts
================
import assert from 'assert';
import Chance from 'chance';
import supertest from 'supertest';

import { ServiceFactory, dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';

const request = supertest(app);

describe('DELETE /api/articles/:slug', () => {
  it('should be able to delete an article', async () => {
    const { article, accessToken } = await setup();

    let response = await request
      .delete(`/api/articles/${article.slug}`)
      .set('Authorization', `Bearer ${accessToken}`)
      .send();

    expect(response.status).toBe(200);

    response = await request.get(`/api/articles/${article.slug}`).send();

    expect(response.status).toBe(404);
  });

  it('should return a status code of 403 - Forbidden if the user tries to delete an article that does not belong to them', async () => {
    const { article, userService, authService, chance } = await setup();

    const user = await userService.createUser({
      email: chance.email(),
      password: 'Abcd1234',
      username: chance.word()
    });

    const accessToken = authService.generateAccessToken({
      userId: user,
      loginId: chance.guid()
    });

    const response = await request
      .delete(`/api/articles/${article.slug}`)
      .set('Authorization', `Bearer ${accessToken}`)
      .send();

    expect(response.status).toBe(403);
  });

  it('should return a status code of 401 - Unauthorized if the client does not provide auth headers', async () => {
    const { article } = await setup();

    const response = await request.delete(`/api/articles/${article.slug}`).send();

    expect(response.status).toBe(401);
  });

  it('should return a status code of 404 - Not Found if the user tries to delete a deleted article', async () => {
    const { article, articleService, accessToken } = await setup();

    await articleService.deleteArticleById({ id: article.id });

    const response = await request
      .delete(`/api/articles/${article.slug}`)
      .set('Authorization', `Bearer ${accessToken}`)
      .send();

    expect(response.status).toBe(404);
  });

  it('should return a status code of 404 - Not Found if the targeted article does not exist', async () => {
    const { accessToken } = await setup();

    const response = await request
      .delete('/api/articles/NOT_EXIST_ARTICLE')
      .set('Authorization', `Bearer ${accessToken}`)
      .send();

    expect(response.status).toBe(404);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const factory = new ServiceFactory();
  const userService = factory.newUserService();
  const authService = factory.newAuthService();
  const articleService = factory.newArticleService();
  const userId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const accessToken = authService.generateAccessToken({
    userId,
    loginId: chance.guid()
  });
  const user = await userService.getUserById({ id: userId });
  assert(user);
  const articleId = await articleService.createArticle({
    userId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });
  const article = await articleService.getArticleById({ id: articleId });
  assert(article);
  return {
    chance,
    userService,
    articleService,
    authService,
    user,
    article,
    accessToken
  };
};

================
File: apps/article/tests/basic/feed-articles.spec.ts
================
import assert from 'assert';
import Chance from 'chance';
import supertest from 'supertest';

import { ServiceFactory, dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';

const request = supertest(app);

describe('GET /api/articles/feed', () => {
  it("should return an empty array if the user doesn't follow any user", async () => {
    const { accessTokenC } = await setup();

    const response = await request
      .get('/api/articles/feed')
      .set('Authorization', `Bearer ${accessTokenC}`)
      .send();

    expect(response.status).toBe(200);
    expect(response.body).toBeDefined();
    expect(response.body.articles).toBeInstanceOf(Array);
    expect(response.body.articles).toHaveLength(0);
    expect(response.body.articlesCount).toBe(0);
  });

  it('should be able to return multiple articles created by followed users, ordered by most recent first', async () => {
    const { userService, userA, userC, accessTokenC } = await setup();

    await userService.followUser({
      followerId: userC.id,
      followingUsername: userA.username
    });

    let response = await request
      .get('/api/articles/feed')
      .set('Authorization', `Bearer ${accessTokenC}`)
      .send();

    expect(response.status).toBe(200);
    expect(response.body).toBeDefined();
    expect(response.body.articles).toBeInstanceOf(Array);
    expect(response.body.articles).toHaveLength(2);
    expect(response.body.articlesCount).toBe(2);

    await userService.unfollowUser({
      followerId: userC.id,
      followingUsername: userA.username
    });

    response = await request
      .get('/api/articles/feed')
      .set('Authorization', `Bearer ${accessTokenC}`)
      .send();

    expect(response.status).toBe(200);
    expect(response.body).toBeDefined();
    expect(response.body.articles).toBeInstanceOf(Array);
    expect(response.body.articles).toHaveLength(0);
    expect(response.body.articlesCount).toBe(0);
  });

  it("should return a status code of 401 - Unauthorized if the client doesn't provide auth headers", async () => {
    await setup();

    const response = await request.get('/api/articles/feed').send();

    expect(response.status).toBe(401);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const factory = new ServiceFactory();
  const userService = factory.newUserService();
  const authService = factory.newAuthService();
  const articleService = factory.newArticleService();

  /**
   *
   * User A
   *
   */
  const userAId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const userA = await userService.getUserById({ id: userAId });
  assert(userA);
  const accessTokenA = authService.generateAccessToken({
    userId: userAId,
    loginId: chance.guid()
  });

  /**
   *
   * User B
   *
   */
  const userBId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const userB = await userService.getUserById({ id: userBId });
  assert(userB);
  const accessTokenB = authService.generateAccessToken({
    userId: userBId,
    loginId: chance.guid()
  });

  /**
   *
   * User C
   *
   */
  const userCId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const userC = await userService.getUserById({ id: userCId });
  assert(userC);
  const accessTokenC = authService.generateAccessToken({
    userId: userCId,
    loginId: chance.guid()
  });

  const articleIdAWithTagFromAuthorA = await articleService.createArticle({
    userId: userAId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });

  await articleService.createArticleTags({
    articleId: articleIdAWithTagFromAuthorA,
    tagList: ['TAG_A', 'TAG_B']
  });

  const articleIdBFromAuthorA = await articleService.createArticle({
    userId: userAId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });

  const articleIdCFromAuthorB = await articleService.createArticle({
    userId: userBId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });

  const articleIdDWithTagFromAuthorB = await articleService.createArticle({
    userId: userBId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });

  await articleService.createArticleTags({
    articleId: articleIdDWithTagFromAuthorB,
    tagList: ['TAG_A']
  });

  return {
    userService,
    articleService,
    userA,
    userB,
    userC,
    accessTokenA,
    accessTokenB,
    accessTokenC,
    articleIdAWithTagFromAuthorA,
    articleIdBFromAuthorA,
    articleIdCFromAuthorB,
    articleIdDWithTagFromAuthorB
  };
};

================
File: apps/article/tests/basic/get-article.spec.ts
================
import assert from 'assert';
import Chance from 'chance';
import supertest from 'supertest';

import { ServiceFactory, dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';
import { DtoArticle } from '../../dto';

const request = supertest(app);

describe('GET /api/articles/:slug', () => {
  it('should be able to get an article', async () => {
    const { article } = await setup();
    const response = await request.get(`/api/articles/${article.slug}`).send();
    expect(response.status).toBe(200);
    expect(response.body.article).toBeDefined();
    const dtoArticle: DtoArticle = response.body.article;
    expect(dtoArticle.slug).toBe(article.slug);
  });

  it('should return a status code of 404 - Not Found if the author of the targeted article had been deleted', async () => {
    const { articleService, article } = await setup();
    await articleService.deleteArticleById({ id: article.id });
    const response = await request.get(`/api/articles/${article.slug}`).send();
    expect(response.status).toBe(404);
  });

  it('should return a status code of 404 - Not Found if the targeted article does not exist', async () => {
    await setup();
    const response = await request.get('/api/articles/non-existent-article').send();
    expect(response.status).toBe(404);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const factory = new ServiceFactory();
  const userService = factory.newUserService();
  const authService = factory.newAuthService();
  const articleService = factory.newArticleService();
  const userId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const accessToken = authService.generateAccessToken({
    userId,
    loginId: chance.guid()
  });
  const user = await userService.getUserById({ id: userId });
  assert(user);
  const articleId = await articleService.createArticle({
    userId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });
  const article = await articleService.getArticleById({ id: articleId });
  assert(article);
  return {
    userService,
    articleService,
    user,
    article,
    accessToken
  };
};

================
File: apps/article/tests/basic/list-articles.spec.ts
================
import assert from 'assert';
import Chance from 'chance';
import supertest from 'supertest';

import { ServiceFactory, dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';

const request = supertest(app);

describe('GET /api/articles', () => {
  it('should be able to retrieve a list of all articles', async () => {
    await setup();

    const response = await request.get('/api/articles').send();

    expect(response.status).toBe(200);
    expect(response.body).toBeDefined();
    expect(response.body.articles).toBeInstanceOf(Array);
    expect(response.body.articles).toHaveLength(4);
    expect(response.body.articlesCount).toBe(4);
  });

  it('should be able to retrieve a list of all articles with access token', async () => {
    const { accessTokenC } = await setup();

    const response = await request
      .get('/api/articles')
      .set('Authorization', `Bearer ${accessTokenC}`)
      .send();

    expect(response.status).toBe(200);
    expect(response.body).toBeDefined();
    expect(response.body.articles).toBeInstanceOf(Array);
    expect(response.body.articles).toHaveLength(4);
    expect(response.body.articlesCount).toBe(4);
  });

  it('should be able to retrieve a list of articles filtered by tag', async () => {
    await setup();

    let response = await request.get('/api/articles').query({ tag: 'TAG_A' }).send();

    expect(response.status).toBe(200);
    expect(response.body.articles).toBeInstanceOf(Array);
    expect(response.body.articles).toHaveLength(2);
    expect(response.body.articlesCount).toBe(2);

    response = await request.get('/api/articles').query({ tag: 'TAG_B' }).send();

    expect(response.status).toBe(200);
    expect(response.body.articles).toBeInstanceOf(Array);
    expect(response.body.articles).toHaveLength(1);
    expect(response.body.articlesCount).toBe(1);
  });

  it('should be able to retrieve a list of articles filtered by author', async () => {
    const { userA } = await setup();

    const response = await request
      .get('/api/articles')
      .query({ author: userA.username })
      .send();

    expect(response.status).toBe(200);
    expect(response.body.articles).toBeInstanceOf(Array);
    expect(response.body.articles).toHaveLength(2);
    expect(response.body.articlesCount).toBe(2);
  });

  it('should be able to retrieve a list of articles filtered by limit and offset', async () => {
    await setup();
    const response = await request
      .get('/api/articles')
      .query({ limit: 1, offset: 0 })
      .send();

    expect(response.status).toBe(200);
    expect(response.body).toBeDefined();
    expect(response.body.articles).toBeInstanceOf(Array);
    expect(response.body.articles).toHaveLength(1);
    expect(response.body.articlesCount).toBe(4);
  });

  it('should return a status code of 422 - Unprocessable Entity if the client provides non-number parameters to offset and limit', async () => {
    await setup();
    const response = await request
      .get('/api/articles')
      .query({ limit: 'limit', offset: 'offset' })
      .send();
    expect(response.status).toBe(422);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const factory = new ServiceFactory();
  const userService = factory.newUserService();
  const authService = factory.newAuthService();
  const articleService = factory.newArticleService();

  /**
   *
   * User A
   *
   */
  const userAId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const userA = await userService.getUserById({ id: userAId });
  assert(userA);
  const accessTokenA = authService.generateAccessToken({
    userId: userAId,
    loginId: chance.guid()
  });

  /**
   *
   * User B
   *
   */
  const userBId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const userB = await userService.getUserById({ id: userBId });
  assert(userB);
  const accessTokenB = authService.generateAccessToken({
    userId: userBId,
    loginId: chance.guid()
  });

  /**
   *
   * User C
   *
   */
  const userCId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const userC = await userService.getUserById({ id: userCId });
  assert(userC);
  const accessTokenC = authService.generateAccessToken({
    userId: userCId,
    loginId: chance.guid()
  });

  const articleIdAWithTagFromAuthorA = await articleService.createArticle({
    userId: userAId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });

  await articleService.createArticleTags({
    articleId: articleIdAWithTagFromAuthorA,
    tagList: ['TAG_A', 'TAG_B']
  });

  const articleIdBFromAuthorA = await articleService.createArticle({
    userId: userAId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });

  const articleIdCFromAuthorB = await articleService.createArticle({
    userId: userBId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });

  const articleIdDWithTagFromAuthorB = await articleService.createArticle({
    userId: userBId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });

  await articleService.createArticleTags({
    articleId: articleIdDWithTagFromAuthorB,
    tagList: ['TAG_A']
  });

  return {
    userService,
    articleService,
    userA,
    userB,
    userC,
    accessTokenA,
    accessTokenB,
    accessTokenC,
    articleIdAWithTagFromAuthorA,
    articleIdBFromAuthorA,
    articleIdCFromAuthorB,
    articleIdDWithTagFromAuthorB
  };
};

================
File: apps/article/tests/basic/update-article.spec.ts
================
import assert from 'assert';
import Chance from 'chance';
import supertest from 'supertest';

import { ServiceFactory, dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';
import { DtoArticle } from '../../dto';

const request = supertest(app);

describe('PUT /api/articles/:slug', () => {
  it('should be able to update the article', async () => {
    const { article, accessToken } = await setup();
    const response = await request
      .put(`/api/articles/${article.slug}`)
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ article: { body: 'HELLO_WORLD' } });
    expect(response.status).toBe(200);
    expect(response.body.article).toBeDefined();
    const dtoArticle: DtoArticle = response.body.article;
    expect(dtoArticle.body).toBe('HELLO_WORLD');
  });

  it('should update the slug to reflect the new title when the title of an article is updated using the API. ', async () => {
    const { article, accessToken } = await setup();
    const response = await request
      .put(`/api/articles/${article.slug}`)
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ article: { title: 'UPDATED_TITLE' } });
    expect(response.status).toBe(200);
    expect(response.body.article).toBeDefined();
    const dtoArticle: DtoArticle = response.body.article;
    // The slug of the article should be updated
    expect(dtoArticle.slug).not.toBe(article.slug);
    expect(dtoArticle.title).toBe('UPDATED_TITLE');
  });

  it('should return a status code of 403 - Forbidden if the user tries to update an article that does not belong to them', async () => {
    const { article, guestAccessToken } = await setup();
    const response = await request
      .put(`/api/articles/${article.slug}`)
      .set('Authorization', `Bearer ${guestAccessToken}`)
      .send({ article: { title: 'UPDATED_TITLE' } });
    expect(response.status).toBe(403);
  });

  it("should return a status code of 401 - Unauthorized if the client doesn't provide auth headers", async () => {
    const { article } = await setup();
    const response = await request
      .put(`/api/articles/${article.slug}`)
      .send({ article: { title: 'UPDATED_TITLE' } });
    expect(response.status).toBe(401);
  });

  it('should return a status code of 404 - Not Found if the targeted article does not exist', async () => {
    const { accessToken } = await setup();
    const response = await request
      .put('/api/articles/non-existent-article')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ article: { body: 'HELLO_WORLD' } });
    expect(response.status).toBe(404);
  });

  it("should return a status code of 422 - Unprocessable Entity if the client doesn't provide any data fields", async () => {
    const { article, accessToken } = await setup();
    const response = await request
      .put(`/api/articles/${article.slug}`)
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ article: {} });
    expect(response.status).toBe(422);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const factory = new ServiceFactory();
  const userService = factory.newUserService();
  const authService = factory.newAuthService();
  const articleService = factory.newArticleService();
  const userId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const accessToken = authService.generateAccessToken({
    userId,
    loginId: chance.guid()
  });
  const user = await userService.getUserById({ id: userId });
  assert(user);
  const articleId = await articleService.createArticle({
    userId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });
  const article = await articleService.getArticleById({ id: articleId });
  assert(article);

  const guest = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const guestAccessToken = authService.generateAccessToken({
    userId: guest,
    loginId: chance.guid()
  });

  return {
    chance,
    userService,
    articleService,
    authService,
    user,
    article,
    accessToken,
    guest,
    guestAccessToken
  };
};

================
File: apps/article/tests/comments/add-comments.spec.ts
================
import assert from 'assert';
import Chance from 'chance';
import supertest from 'supertest';

import { ServiceFactory, dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';

const request = supertest(app);

describe('POST /api/articles/:slug/comments', () => {
  it('should be able to add a comment to the article', async () => {
    const { chance, userA, articleA, accessTokenA } = await setup();

    const response = await request
      .post(`/api/articles/${articleA.slug}/comments`)
      .set('Authorization', `Bearer ${accessTokenA}`)
      .send({
        comment: {
          body: chance.sentence()
        }
      });

    expect(response.status).toBe(200);
    expect(response.body.comment).toBeDefined();

    const { comment } = response.body;
    expect(comment.author.following).toBe(false);
    expect(comment.author.username).toBe(userA.username);
  });

  it('should return a status code of 401 - Unauthorized if the client does not provide auth headers', async () => {
    const { chance, articleA } = await setup();
    const response = await request
      .post(`/api/articles/${articleA.slug}/comments`)
      .send({
        comment: {
          body: chance.sentence()
        }
      });
    expect(response.status).toBe(401);
  });

  it('should return a status code of 404 - Not Found if the targeted article does not exist', async () => {
    const { chance, accessTokenB } = await setup();
    const response = await request
      .post('/api/articles/non-existent-article/comments')
      .set('Authorization', `Bearer ${accessTokenB}`)
      .send({
        comment: {
          body: chance.sentence()
        }
      });
    expect(response.status).toBe(404);
  });

  it('should return a status code of 422 - Unprocessable Entity if the client does not provide the required data fields', async () => {
    const { articleA, accessTokenB } = await setup();
    const response = await request
      .post(`/api/articles/${articleA.slug}/comments`)
      .set('Authorization', `Bearer ${accessTokenB}`)
      .send({ comment: {} });

    expect(response.status).toBe(422);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const factory = new ServiceFactory();
  const userService = factory.newUserService();
  const authService = factory.newAuthService();
  const articleService = factory.newArticleService();

  /**
   *
   * User A
   *
   */
  const userAId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const userA = await userService.getUserById({ id: userAId });
  assert(userA);
  const accessTokenA = authService.generateAccessToken({
    userId: userAId,
    loginId: chance.guid()
  });

  /**
   *
   * User B
   *
   */
  const userBId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const userB = await userService.getUserById({ id: userBId });
  assert(userB);
  const accessTokenB = authService.generateAccessToken({
    userId: userBId,
    loginId: chance.guid()
  });

  const articleIdAWithTagFromAuthorA = await articleService.createArticle({
    userId: userAId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });

  await articleService.createArticleTags({
    articleId: articleIdAWithTagFromAuthorA,
    tagList: ['TAG_A', 'TAG_B']
  });

  const articleA = await articleService.getArticleById({
    id: articleIdAWithTagFromAuthorA
  });
  assert(articleA);

  const articleIdDWithTagFromAuthorB = await articleService.createArticle({
    userId: userBId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });

  await articleService.createArticleTags({
    articleId: articleIdDWithTagFromAuthorB,
    tagList: ['TAG_A']
  });

  return {
    chance,
    userService,
    articleService,
    userA,
    userB,
    accessTokenA,
    accessTokenB,
    articleA,
    articleIdAWithTagFromAuthorA
  };
};

================
File: apps/article/tests/comments/delete-comment.spec.ts
================
import assert from 'assert';
import Chance from 'chance';
import supertest from 'supertest';

import { ServiceFactory, dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';

const request = supertest(app);

describe('DELETE /api/articles/:slug/comments', () => {
  it('should be able to delete comments from an article', async () => {
    const { article, commentId, accessToken } = await setup();

    const response = await request
      .delete(`/api/articles/${article.slug}/comments/${commentId}`)
      .set('Authorization', `Bearer ${accessToken}`)
      .send();

    expect(response.status).toBe(200);
  });

  it('should return a status code of 403 - Forbidden if user tries to delete comments from an article that do not belong to them', async () => {
    const { article, commentId, accessTokenB } = await setup();
    const response = await request
      .delete(`/api/articles/${article.slug}/comments/${commentId}`)
      .set('Authorization', `Bearer ${accessTokenB}`)
      .send();
    expect(response.status).toBe(403);
  });

  it('should return a status code of 401 - Unauthorized if the client does not provide auth headers', async () => {
    const { article, chance, commentId } = await setup();
    const response = await request
      .delete(`/api/articles/${article.slug}/comments/${commentId}`)
      .send({
        comment: {
          body: chance.sentence()
        }
      });
    expect(response.status).toBe(401);
  });

  it("should return a status code of 404 - Not Found if the targeted article's comment does not exist", async () => {
    const { chance, article, accessToken } = await setup();
    const response = await request
      .delete(
        `/api/articles/${article.slug}/comments/00000000-0000-0000-0000-000000`
      )
      .set('Authorization', `Bearer ${accessToken}`)
      .send({
        comment: {
          body: chance.sentence()
        }
      });
    expect(response.status).toBe(404);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const factory = new ServiceFactory();
  const userService = factory.newUserService();
  const authService = factory.newAuthService();
  const articleService = factory.newArticleService();

  const userId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const accessToken = authService.generateAccessToken({
    userId,
    loginId: chance.guid()
  });
  const user = await userService.getUserById({ id: userId });
  assert(user);

  const userBId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const accessTokenB = authService.generateAccessToken({
    userId: userBId,
    loginId: chance.guid()
  });

  const articleId = await articleService.createArticle({
    userId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });
  const article = await articleService.getArticleById({ id: articleId });
  assert(article);

  const commentId = await articleService.createArticleComment({
    articleId: article.id,
    userId,
    body: chance.sentence()
  });

  return {
    chance,
    userService,
    articleService,
    authService,
    user,
    article,
    accessToken,
    accessTokenB,
    commentId
  };
};

================
File: apps/article/tests/comments/get-comments.spec.ts
================
import assert from 'assert';
import Chance from 'chance';
import supertest from 'supertest';

import { ServiceFactory, dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';

const request = supertest(app);

describe('GET `/api/articles/:slug/comments', () => {
  it('should be able to get comments from an article', async () => {
    const { article } = await setup();
    const response = await request
      .get(`/api/articles/${article.slug}/comments`)
      .send();
    expect(response.status).toBe(200);
    expect(response.body.comments).toBeDefined();
    expect(response.body.comments).toBeInstanceOf(Array);
    expect(response.body.comments).toHaveLength(1);
  });

  it('should return a status code of 404 - Not Found if the article does not exist', async () => {
    const response = await request
      .get('/api/articles/00000000-0000-0000-0000-00000000/comments')
      .send();
    expect(response.status).toBe(404);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const factory = new ServiceFactory();
  const userService = factory.newUserService();
  const authService = factory.newAuthService();
  const articleService = factory.newArticleService();
  const userId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const accessToken = authService.generateAccessToken({
    userId,
    loginId: chance.guid()
  });
  const user = await userService.getUserById({ id: userId });
  assert(user);
  const articleId = await articleService.createArticle({
    userId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });
  const article = await articleService.getArticleById({ id: articleId });
  assert(article);

  const commentId = await articleService.createArticleComment({
    articleId: article.id,
    userId,
    body: chance.sentence()
  });

  return {
    chance,
    userService,
    articleService,
    authService,
    user,
    article,
    accessToken,
    commentId
  };
};

================
File: apps/article/tests/favorite/favorite-article.spec.ts
================
import assert from 'assert';
import Chance from 'chance';
import supertest from 'supertest';

import { ServiceFactory, dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';
import { DtoArticle } from '../../dto';

const request = supertest(app);

describe('Article - Favorite Article', () => {
  it('should able to favorite an article', async () => {
    const { article, accessToken } = await setup();

    const response = await request
      .post(`/api/articles/${article.slug}/favorite`)
      .set('Authorization', `Bearer ${accessToken}`)
      .send();

    expect(response.status).toBe(200);
    expect(response.body.article).toBeDefined();

    const favoritedArticle: DtoArticle = response.body.article;

    expect(favoritedArticle.favorited).toBe(true);
    expect(favoritedArticle.favoritesCount).toBe(1);
  });

  it('should return a status code of 400 - Bad Request if the client has already favorited the targeted article', async () => {
    const { articleService, user, article, accessToken } = await setup();

    await articleService.favoriteArticle({
      userId: user.id,
      articleId: article.id
    });

    const response = await request
      .post(`/api/articles/${article.slug}/favorite`)
      .set('Authorization', `Bearer ${accessToken}`)
      .send();

    expect(response.status).toBe(400);
  });

  it("should return a status code of 401 - Unauthorized if the client doesn't provide auth headers", async () => {
    const { article } = await setup();

    const response = await request
      .post(`/api/articles/${article.slug}/favorite`)
      .send();

    expect(response.status).toBe(401);
  });

  it('should return a status code of 404 - Not Found if the targeted article does not exist', async () => {
    const { accessToken } = await setup();

    const response = await request
      .post('/api/articles/non-existing-slug/favorite')
      .set('Authorization', `Bearer ${accessToken}`)
      .send();

    expect(response.status).toBe(404);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const factory = new ServiceFactory();
  const userService = factory.newUserService();
  const authService = factory.newAuthService();
  const articleService = factory.newArticleService();
  const userId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const accessToken = authService.generateAccessToken({
    userId,
    loginId: chance.guid()
  });
  const user = await userService.getUserById({ id: userId });
  assert(user);
  const articleId = await articleService.createArticle({
    userId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });
  const article = await articleService.getArticleById({ id: articleId });
  assert(article);

  const commentId = await articleService.createArticleComment({
    articleId: article.id,
    userId,
    body: chance.sentence()
  });

  return {
    chance,
    userService,
    articleService,
    authService,
    user,
    article,
    accessToken,
    commentId
  };
};

================
File: apps/article/tests/favorite/unfavorite-article.spec.ts
================
import assert from 'assert';
import Chance from 'chance';
import supertest from 'supertest';

import { ServiceFactory, dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';
import { DtoArticle } from '../../dto';

const request = supertest(app);

describe('Article - Unfavorite Article', () => {
  it('should able to unfavorite an article', async () => {
    const { article, accessToken, articleService, user } = await setup();

    await articleService.favoriteArticle({
      articleId: article.id,
      userId: user.id
    });

    const response = await request
      .delete(`/api/articles/${article.slug}/favorite`)
      .set('Authorization', `Bearer ${accessToken}`)
      .send();

    expect(response.status).toBe(200);
    expect(response.body.article).toBeDefined();

    const favoritedArticle: DtoArticle = response.body.article;

    expect(favoritedArticle.favorited).toBe(false);
    expect(favoritedArticle.favoritesCount).toBe(0);
  });

  it('should return a status code of 400 - Bad Request if the client does not favorite the targeted article', async () => {
    const { article, accessToken } = await setup();

    const response = await request
      .delete(`/api/articles/${article.slug}/favorite`)
      .set('Authorization', `Bearer ${accessToken}`)
      .send();
    expect(response.status).toBe(400);
  });

  it("should return a status code of 401 - Unauthorized if the client doesn't provide auth headers", async () => {
    const { article } = await setup();

    const response = await request
      .delete(`/api/articles/${article.slug}/favorite`)
      .send();

    expect(response.status).toBe(401);
  });

  it('should return a status code of 404 - Not Found if the targeted article does not exist', async () => {
    const { accessToken } = await setup();

    const response = await request
      .delete('/api/articles/hello-world/favorite')
      .set('Authorization', `Bearer ${accessToken}`)
      .send();

    expect(response.status).toBe(404);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const factory = new ServiceFactory();
  const userService = factory.newUserService();
  const authService = factory.newAuthService();
  const articleService = factory.newArticleService();
  const userId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const accessToken = authService.generateAccessToken({
    userId,
    loginId: chance.guid()
  });
  const user = await userService.getUserById({ id: userId });
  assert(user);
  const articleId = await articleService.createArticle({
    userId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });
  const article = await articleService.getArticleById({ id: articleId });
  assert(article);

  const commentId = await articleService.createArticleComment({
    articleId: article.id,
    userId,
    body: chance.sentence()
  });

  return {
    chance,
    userService,
    articleService,
    authService,
    user,
    article,
    accessToken,
    commentId
  };
};

================
File: apps/article/tests/tag/get-tags.spec.ts
================
import assert from 'assert';
import Chance from 'chance';
import supertest from 'supertest';

import { ServiceFactory, dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';

const request = supertest(app);

describe('GET /api/tags', () => {
  it('should be able to get the tags from article', async () => {
    await setup();
    const response = await request.get('/api/tags');
    expect(response.status).toBe(200);
    expect(response.body.tags).toBeInstanceOf(Array);
    expect(response.body.tags).toHaveLength(4);
  });

  it('should exclude tags from deleted articles', async () => {
    const { articleService, articleA } = await setup();
    await articleService.deleteArticleById({ id: articleA.id });
    const response = await request.get('/api/tags');
    expect(response.status).toBe(200);
    expect(response.body.tags).toBeInstanceOf(Array);
    expect(response.body.tags).toHaveLength(2);
  });

  beforeEach(() => dangerouslyResetDb());
});
const setup = async () => {
  const chance = new Chance();
  const factory = new ServiceFactory();
  const userService = factory.newUserService();
  const authService = factory.newAuthService();
  const articleService = factory.newArticleService();
  const userId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const accessToken = authService.generateAccessToken({
    userId,
    loginId: chance.guid()
  });
  const user = await userService.getUserById({ id: userId });
  assert(user);
  const articleAId = await articleService.createArticle({
    userId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });
  const articleA = await articleService.getArticleById({ id: articleAId });
  assert(articleA);

  const articleBId = await articleService.createArticle({
    userId,
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph()
  });
  const articleB = await articleService.getArticleById({ id: articleBId });
  assert(articleB);

  await articleService.createArticleTags({
    articleId: articleA.id,
    tagList: ['tagA', 'tagB']
  });

  await articleService.createArticleTags({
    articleId: articleB.id,
    tagList: ['tagC', 'tagD']
  });

  return {
    userService,
    articleService,
    user,
    articleA,
    articleB,
    accessToken
  };
};

================
File: apps/article/tsconfig.json
================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "@conduit/config/tsconfig.base.json",
  "compilerOptions": {
    "sourceMap": false
  },
  "include": ["./**/*.ts"]
}

================
File: apps/article/types/global.d.ts
================
import '@conduit/core/types/global';

================
File: apps/local/.eslintrc.js
================
const defaultConfig = require('@conduit/config/.eslintrc.json');

module.exports = {
  ...defaultConfig,
  parserOptions: {
    project: './tsconfig.json'
  },
  rules: {
    ...defaultConfig.rules,
    'import/no-extraneous-dependencies': 'off'
  }
};

================
File: apps/local/.prettierrc.cjs
================
module.exports = require('@conduit/config/.prettierrc.json');

================
File: apps/local/Dockerfile
================
#
# Base image for the server
#
FROM node:18 AS base

ARG WORKSPACE_SCOPE=@conduit/local

# Set working directory
WORKDIR /app
RUN yarn global add turbo

# Copy the project files
COPY . .

# Use the build argument in the turbo prune command
RUN turbo prune --scope=$WORKSPACE_SCOPE --docker

#
# Installer image
# Add lockfile and package.json's of isolated sub-workspace
#
FROM base AS installer

# Set working directory
WORKDIR /app

# Copy necessary files to the installer stage
COPY .gitignore .gitignore
COPY --from=base /app/out/json/ .
COPY --from=base /app/out/yarn.lock ./yarn.lock

# Install dependencies
RUN yarn install

# Build the project using the variable scope
COPY --from=base /app/out/full/ .
RUN turbo run build --filter=$WORKSPACE_SCOPE...

================
File: apps/local/local.ts
================
import 'dotenv/config';

import express from 'express';

import { app as appApp } from '@conduit/app/app';
import { app as articleApp } from '@conduit/article/app';
import {
  configureGlobalExceptionHandler,
  configureMiddlewares
} from '@conduit/middleware';
import { app as userApp } from '@conduit/user/app';
import { logger } from '@conduit/utils';

export const app = express();

configureMiddlewares({ app, skipOnLocal: false });

app.use(appApp);
app.use(articleApp);
app.use(userApp);

configureGlobalExceptionHandler({ app, skipOnLocal: false });

const port = process.env.PORT || 3100;

app.listen(port, () => {
  logger.info(`Server is running on http://localhost:${port}`);
});

================
File: apps/local/package.json
================
{
  "name": "@conduit/local",
  "version": "1.0.0",
  "private": true,
  "description": "",
  "license": "MIT",
  "author": {
    "name": "Ken Yip",
    "email": "ken20206@gmail.com",
    "url": "https://kenyip.cc"
  },
  "main": "index.js",
  "workspaces": [
    "../app",
    "../user",
    "../article",
    "../../packages/middleware",
    "../../packages/utils"
  ],
  "scripts": {
    "build": "tsc",
    "check-types": "tsc --skipLibCheck --noEmit",
    "dev": "NODE_CONFIG_DIR='../../config' NODE_ENV=ci ts-node-dev --no-notify --exit-child --respawn --transpile-only --ignore-watch node_modules ./local.ts",
    "lint": "eslint .",
    "lint:fix": "eslint --fix .",
    "prettify": "prettier --write .",
    "start": "NODE_CONFIG_DIR='../../config' node local.js",
    "start:ci": "NODE_CONFIG_DIR='../../config' pm2 start local.js"
  },
  "dependencies": {
    "@conduit/app": "*",
    "@conduit/article": "*",
    "@conduit/middleware": "*",
    "@conduit/user": "*",
    "@conduit/utils": "*",
    "dotenv": "^16.4.5",
    "express": "^4.21.1"
  },
  "devDependencies": {
    "eslint": "^8.19.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "eslint-config-airbnb-typescript": "^17.0.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-jest": "^26.5.3",
    "eslint-plugin-prettier": "^5.2.1",
    "pm2": "^5.3.0",
    "prettier": "^3.3.3",
    "prettier-plugin-packagejson": "^2.5.3",
    "ts-node": "^10.9.1",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.6.3"
  }
}

================
File: apps/local/tsconfig.json
================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "@conduit/config/tsconfig.base.json",
  "compilerOptions": {
    "sourceMap": false
  },
  "include": ["./**/*.ts"]
}

================
File: apps/local/types/global.d.ts
================
import '@conduit/core/types/global';

================
File: apps/user/.eslintrc.js
================
const defaultConfig = require('@conduit/config/.eslintrc.json');

module.exports = {
  ...defaultConfig,
  parserOptions: {
    project: './tsconfig.json'
  },
  rules: {
    ...defaultConfig.rules,
    'import/no-extraneous-dependencies': 'off'
  }
};

================
File: apps/user/.prettierrc.cjs
================
module.exports = require('@conduit/config/.prettierrc.json');

================
File: apps/user/app.ts
================
import express from 'express';

import {
  configureGlobalExceptionHandler,
  configureMiddlewares
} from '@conduit/middleware';

import { router } from './route';

export const app = express();

configureMiddlewares({ app });

app.use(router);

configureGlobalExceptionHandler({ app });

================
File: apps/user/constants/ErrorCodes.ts
================
export enum ErrorCodes {
  UnprocessableContent = 'general_unprocessable_content',
  PasswordRequirementsNotMet = 'auth_password_requirements_not_met'
}

================
File: apps/user/constants/index.ts
================
export * from './ErrorCodes';

================
File: apps/user/controller/followUser.ts
================
import { RequestHandler } from 'express';

import { ApiErrorInternalServerError } from '@conduit/utils';

import { Factory } from '../service';

const factory = new Factory();
const apiFollowUser = factory.newApiFollowUser();

export const followUser: RequestHandler<Params, unknown, unknown, unknown> = async (
  req,
  res
) => {
  const { user } = req;
  const { username } = req.params;

  if (username === undefined || user === undefined) {
    throw new ApiErrorInternalServerError({});
  }

  const response = await apiFollowUser.execute({ username, userId: user.id });
  res.json(response);
};

interface Params {
  username: string;
}

================
File: apps/user/controller/getCurrentUser.ts
================
import { RequestHandler } from 'express';

import { ApiErrorUnauthorized } from '@conduit/utils';

import { Factory } from '../service/Factory';

const factory = new Factory();
const apiGetCurrentUser = factory.newApiGetCurrentUser();

export const getCurrentUser: RequestHandler = async (req, res) => {
  const { user } = req;
  if (user === undefined) {
    throw new ApiErrorUnauthorized({});
  }
  const response = await apiGetCurrentUser.execute({ user });
  res.json(response);
};

================
File: apps/user/controller/getUserProfile.ts
================
import { RequestHandler } from 'express';

import { ApiErrorInternalServerError } from '@conduit/utils';

import { Factory } from '../service';

const factory = new Factory();
const apiGetUserProfile = factory.newApiGetProfile();

export const getUserProfile: RequestHandler<
  Params,
  unknown,
  unknown,
  unknown
> = async (req, res) => {
  const { user } = req;
  const { username } = req.params;

  if (username === undefined) {
    throw new ApiErrorInternalServerError({});
  }

  const response = await apiGetUserProfile.execute({ username, userId: user?.id });
  res.json(response);
};

interface Params {
  username: string;
}

================
File: apps/user/controller/index.ts
================
export * from './login';
export * from './registration';
export * from './updateUser';
export * from './getCurrentUser';
export * from './followUser';
export * from './unfollowUser';
export * from './getUserProfile';

================
File: apps/user/controller/login.ts
================
import { RequestHandler } from 'express';

import { ApiErrorUnprocessableEntity } from '@conduit/utils';

import { loginBodySchema } from '../schema';
import { Factory } from '../service/Factory';

const factory = new Factory();
const apiUserLogin = factory.newApiUserLogin();

export const login: RequestHandler<unknown, unknown, Body, unknown> = async (
  req,
  res
) => {
  const { value: input, error } = loginBodySchema.validate(req.body);

  if (error) {
    throw new ApiErrorUnprocessableEntity({
      message:
        'Invalid or missing data in the request body. Please ensure all required fields are included and in the correct format.',
      cause: error
    });
  }

  const response = await apiUserLogin.execute(input.user);
  res.json(response);
};

interface Body {
  user: {
    email: string;
    password: string;
  };
}

================
File: apps/user/controller/registration.ts
================
import { RequestHandler } from 'express';

import { ApiErrorUnprocessableEntity } from '@conduit/utils';

import { registrationBodySchema } from '../schema';
import { Factory } from '../service/Factory';

const factory = new Factory();
const apiRegistration = factory.newApiRegistration();

export const registration: RequestHandler<unknown, unknown, Body, unknown> = async (
  req,
  res
) => {
  const { value: input, error } = registrationBodySchema.validate(req.body);
  if (error) {
    throw new ApiErrorUnprocessableEntity({
      message:
        'Invalid or missing data in the request body. Please ensure all required fields are included and in the correct format.',
      cause: error
    });
  }
  const response = await apiRegistration.execute(input.user);
  res.json(response);
};

interface Body {
  user: {
    username: string;
    email: string;
    password: string;
  };
}

================
File: apps/user/controller/unfollowUser.ts
================
import { RequestHandler } from 'express';

import { ApiErrorInternalServerError } from '@conduit/utils';

import { Factory } from '../service';

const factory = new Factory();
const apiUnfollowUser = factory.newApiUnfollowUser();

export const unfollowUser: RequestHandler<
  Params,
  unknown,
  unknown,
  unknown
> = async (req, res) => {
  const { user } = req;
  const { username } = req.params;

  if (username === undefined || user === undefined) {
    throw new ApiErrorInternalServerError({});
  }

  const response = await apiUnfollowUser.execute({ username, userId: user.id });
  res.json(response);
};

interface Params {
  username: string;
}

================
File: apps/user/controller/updateUser.ts
================
import { RequestHandler } from 'express';

import {
  ApiErrorInternalServerError,
  ApiErrorUnprocessableEntity
} from '@conduit/utils';

import { updateUserBodySchema } from '../schema';
import { Factory } from '../service/Factory';

const factory = new Factory();
const apiUpdateUser = factory.newApiUpdateUser();

export const updateUser: RequestHandler<unknown, unknown, Body, unknown> = async (
  req,
  res
) => {
  const { value: input, error } = updateUserBodySchema.validate(req.body);
  if (error || Object.keys(input.user).length === 0) {
    throw new ApiErrorUnprocessableEntity({
      message:
        'Invalid or missing data in the request body. Please ensure all required fields are included and in the correct format.',
      cause: error
    });
  }

  const { user } = req;
  if (!user) {
    throw new ApiErrorInternalServerError({
      message: 'User not found in request object.'
    });
  }
  const userId = user.id;
  const { username, email, bio, image, password } = input.user;

  const response = await apiUpdateUser.execute({
    userId,
    username,
    email,
    bio,
    image,
    password
  });

  res.json(response);
};

interface Body {
  user: {
    username?: string;
    email?: string;
    bio?: string;
    image?: string;
    password?: string;
  };
}

================
File: apps/user/Dockerfile
================
#
# Base image for the server
#
FROM node:18 AS base

ARG WORKSPACE_SCOPE=@conduit/user

# Set working directory
WORKDIR /app
RUN yarn global add turbo

# Copy the project files
COPY . .

# Use the build argument in the turbo prune command
RUN turbo prune --scope=$WORKSPACE_SCOPE --docker

#
# Installer image
# Add lockfile and package.json's of isolated sub-workspace
#
FROM base AS installer

# Set working directory
WORKDIR /app

# Copy necessary files to the installer stage
COPY .gitignore .gitignore
COPY --from=base /app/out/json/ .
COPY --from=base /app/out/yarn.lock ./yarn.lock

# Install dependencies
RUN yarn install

# Build the project using the variable scope
COPY --from=base /app/out/full/ .
RUN turbo run build --filter=$WORKSPACE_SCOPE...

================
File: apps/user/dto/DtoProfile.ts
================
export class DtoProfile {
  username: string;
  bio?: string;
  image?: string;
  following: boolean;

  constructor({ username, bio, image, following }: DtoProfileConstructor) {
    this.username = username;
    this.bio = bio;
    this.image = image;
    this.following = following;
  }
}

interface DtoProfileConstructor {
  username: string;
  bio?: string;
  image?: string;
  following: boolean;
}

================
File: apps/user/dto/DtoUser.ts
================
export class DtoUser {
  username: string;
  email: string;
  bio?: string;
  image?: string;
  token?: string;

  constructor({ username, email, bio, image, token }: DtoUserConstructor) {
    this.username = username;
    this.email = email;
    this.bio = bio;
    this.image = image;
    this.token = token;
  }
}

interface DtoUserConstructor {
  username: string;
  email: string;
  bio?: string;
  image?: string;
  token?: string;
}

================
File: apps/user/dto/index.ts
================
export * from './DtoProfile';
export * from './DtoUser';

================
File: apps/user/jest.config.js
================
/** @type {import('jest').Config} */

module.exports = require('@conduit/config/jest.config');

================
File: apps/user/local.ts
================
import 'dotenv/config';

import { logger } from '@conduit/utils';

import { app } from './app';

app.listen(3300, () => {
  logger.info('User server is running on http://localhost:3300', { label: 'App' });
});

================
File: apps/user/package.json
================
{
  "name": "@conduit/user",
  "version": "1.0.0",
  "private": true,
  "description": "",
  "license": "MIT",
  "author": {
    "name": "Ken Yip",
    "email": "ken20206@gmail.com",
    "url": "https://kenyip.cc"
  },
  "main": "index.js",
  "workspaces": [
    "../../packages/config",
    "../../packages/core",
    "../../packages/utils",
    "../../packages/types",
    "../../packages/middleware"
  ],
  "scripts": {
    "build": "tsc",
    "check-types": "tsc --skipLibCheck --noEmit",
    "dev": "NODE_CONFIG_DIR='../../config' NODE_ENV=develop ts-node-dev --no-notify --exit-child --respawn --transpile-only --ignore-watch node_modules ./local.ts",
    "lint": "eslint .",
    "lint:fix": "eslint --fix .",
    "prettify": "prettier --write .",
    "test": "NODE_CONFIG_DIR='../../config' NODE_ENV=test jest tests/** --forceExit --maxWorkers=4 --detectOpenHandles",
    "test:coverage": "yarn test --coverage"
  },
  "dependencies": {
    "@conduit/config": "*",
    "@conduit/core": "*",
    "@conduit/middleware": "*",
    "@conduit/utils": "*",
    "express": "^4.21.1",
    "express-promise-router": "^4.1.1",
    "joi": "^17.13.3",
    "p-map": "4.0.0",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "@jest/types": "^29.6.3",
    "@types/aws-lambda": "^8.10.145",
    "@types/supertest": "^6.0.2",
    "@types/uuid": "^10.0.0",
    "better-sqlite3": "^11.3.0",
    "chance": "^1.1.12",
    "dotenv": "^16.4.5",
    "eslint": "^8.19.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "eslint-config-airbnb-typescript": "^17.0.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-jest": "^26.5.3",
    "eslint-plugin-prettier": "^5.2.1",
    "jest": "^26.2.0",
    "jest-when": "^3.6.0",
    "prettier": "^3.3.3",
    "prettier-plugin-packagejson": "^2.5.3",
    "supertest": "^6.0.0",
    "ts-jest": "^26.1.0",
    "ts-node": "^10.9.1",
    "ts-node-dev": "^2.0.0",
    "tsc-alias": "^1.8.10",
    "typescript": "^5.6.3"
  }
}

================
File: apps/user/route.ts
================
import Router from 'express-promise-router';

import { auth, authRequired } from '@conduit/middleware';

import {
  followUser,
  getCurrentUser,
  getUserProfile,
  login,
  registration,
  unfollowUser,
  updateUser
} from './controller';

export const router = Router();

router.post('/api/users/login', login);
router.post('/api/users', registration);

router
  .route('/api/user')
  .put(authRequired, updateUser)
  .get(authRequired, getCurrentUser);

router.get('/api/profiles/:username', auth, getUserProfile);

router
  .route('/api/profiles/:username/follow')
  .post(authRequired, followUser)
  .delete(authRequired, unfollowUser);

================
File: apps/user/schema/index.ts
================
export * from './loginBody';
export * from './registrationBody';
export * from './updateUserBody';

================
File: apps/user/schema/loginBody.ts
================
import Joi from 'joi';

export const loginBodySchema = Joi.object({
  user: Joi.object({
    email: Joi.string()
      .description("A string representing the user's username")
      .required(),
    password: Joi.string()
      .description("A string representing the user's password")
      .required()
  }).required()
}).required();

================
File: apps/user/schema/registrationBody.ts
================
import Joi from 'joi';

export const registrationBodySchema = Joi.object({
  user: Joi.object({
    username: Joi.string()
      .description("A string representing the user's desired username")
      .required(),
    email: Joi.string()
      .description("A string representing the user's email address")
      .required(),
    password: Joi.string()
      .description("A string representing the user's desired password")
      .required()
  }).required()
}).required();

================
File: apps/user/schema/updateUserBody.ts
================
import Joi from 'joi';

export const updateUserBodySchema = Joi.object({
  user: Joi.object({
    username: Joi.string()
      .description("A string representing the user's desired username")
      .empty(null),
    email: Joi.string()
      .email()
      .description("A string representing the user's email address")
      .empty(null),
    password: Joi.string()
      .description("A string representing the user's desired password")
      .empty(null),
    bio: Joi.string()
      .description("A string that represents the user's bio or description.")
      .empty(null),
    image: Joi.string()
      .description("A string that represents the user's profile image")
      .empty(null)
  }).required()
}).required();

================
File: apps/user/server.ts
================
import { configureLambda } from '@conduit/middleware';

import { app } from './app';

export const handler = configureLambda({ app });

================
File: apps/user/service/ApiFollowUser/ApiFollowUser.ts
================
import { InvalidFollowError, UserNotFoundError, UserService } from '@conduit/core';
import {
  ApiErrorBadRequest,
  ApiErrorInternalServerError,
  ApiErrorNotFound
} from '@conduit/utils';

import {
  ApiFollowUserConstructor,
  ApiFollowUserInput,
  ApiFollowUserOutput
} from './types';

export class ApiFollowUser {
  private userService: UserService;

  constructor({ userService }: ApiFollowUserConstructor) {
    this.userService = userService;
  }

  async execute({ userId, username }: ApiFollowUserInput): ApiFollowUserOutput {
    try {
      await this.userService.followUser({
        followerId: userId,
        followingUsername: username
      });

      const profile = await this.userService.getUserProfile({
        requestingUserId: userId,
        username
      });

      if (!profile) {
        throw new ApiErrorInternalServerError({
          cause: new Error(`Failed to get profile for username ${username}`)
        });
      }

      return {
        profile
      };
    } catch (error) {
      if (error instanceof UserNotFoundError) {
        throw new ApiErrorNotFound({ cause: error });
      }
      if (error instanceof InvalidFollowError) {
        throw new ApiErrorBadRequest({ cause: error });
      }
      throw error;
    }
  }
}

================
File: apps/user/service/ApiFollowUser/index.ts
================
export * from './ApiFollowUser';

================
File: apps/user/service/ApiFollowUser/types.ts
================
import { DbDtoProfile, UserService } from '@conduit/core';

export interface ApiFollowUserConstructor {
  userService: UserService;
}

export interface ApiFollowUserInput {
  username: string;
  userId: string;
}

export type ApiFollowUserOutput = Promise<{
  profile: DbDtoProfile;
}>;

================
File: apps/user/service/ApiGetCurrentUser/ApiGetCurrentUser.ts
================
import { UserStatus } from '@conduit/core';
import { ApiErrorForbidden } from '@conduit/utils';

import { DtoUser } from '../../dto';
import { ApiGetCurrentUserInput, ApiGetCurrentUserOutput } from './types';

export class ApiGetCurrentUser {
  async execute({ user }: ApiGetCurrentUserInput): ApiGetCurrentUserOutput {
    if (user.recordStatus === UserStatus.Banned) {
      throw new ApiErrorForbidden({
        message:
          'Sorry, your account has been banned. You can no longer access our services. If you think this is a mistake, please contact our support team. Thank you.'
      });
    }
    const dtoUser = new DtoUser({
      username: user.username,
      email: user.email,
      bio: user.bio,
      image: user.image
    });
    return {
      user: dtoUser
    };
  }
}

================
File: apps/user/service/ApiGetCurrentUser/index.ts
================
export { ApiGetCurrentUser } from './ApiGetCurrentUser';
export { ApiGetCurrentUserInput, ApiGetCurrentUserOutput } from './types';

================
File: apps/user/service/ApiGetCurrentUser/types.ts
================
import { DbDtoUser } from '@conduit/core';

import { DtoUser } from '../../dto';

export interface ApiGetCurrentUserInput {
  user: DbDtoUser;
}

export type ApiGetCurrentUserOutput = Promise<{ user: DtoUser }>;

================
File: apps/user/service/ApiGetProfile/ApiGetProfile.ts
================
import { UserService } from '@conduit/core';
import { ApiErrorNotFound } from '@conduit/utils';

import {
  ApiGetProfileConstructor,
  ApiGetProfileInput,
  ApiGetProfileOutput
} from './types';

export class ApiGetProfile {
  private userService: UserService;

  constructor({ userService }: ApiGetProfileConstructor) {
    this.userService = userService;
  }

  async execute({ userId, username }: ApiGetProfileInput): ApiGetProfileOutput {
    const profile = await this.userService.getUserProfile({
      requestingUserId: userId,
      username
    });
    if (!profile) {
      throw new ApiErrorNotFound({
        cause: new Error(`Username ${username} not found`)
      });
    }
    return {
      profile
    };
  }
}

================
File: apps/user/service/ApiGetProfile/index.ts
================
export * from './ApiGetProfile';

================
File: apps/user/service/ApiGetProfile/types.ts
================
import { UserService } from '@conduit/core';

import { DtoProfile } from '../../dto';

export interface ApiGetProfileConstructor {
  userService: UserService;
}

export interface ApiGetProfileInput {
  username: string;
  userId?: string;
}

export type ApiGetProfileOutput = Promise<{
  profile: DtoProfile;
}>;

================
File: apps/user/service/ApiRegistration/ApiRegistration.ts
================
import { v4 as uuid } from 'uuid';

import {
  AuthService,
  PasswordRequirementsNotMetError,
  UserExistError,
  UserService
} from '@conduit/core';
import {
  ApiErrorBadRequest,
  ApiErrorConflict,
  ApiErrorInternalServerError,
  logger
} from '@conduit/utils';

import { DtoUser } from '../../dto';
import {
  ApiRegistrationConstructor,
  ApiRegistrationInput,
  ApiRegistrationOutput
} from './types';

export class ApiRegistration {
  private readonly userService: UserService;
  private readonly authService: AuthService;

  constructor({ userService, authService }: ApiRegistrationConstructor) {
    this.userService = userService;
    this.authService = authService;
  }

  async execute({
    username,
    email,
    password,
    bio,
    image
  }: ApiRegistrationInput): ApiRegistrationOutput {
    const loginId = uuid();

    try {
      logger.info(`Creating user with email: ${email} and loginId: ${loginId}`, {
        label: 'ApiRegistration'
      });

      const userId = await this.userService.createUser({
        username,
        email,
        password,
        bio,
        image
      });
      const user = await this.userService.getUserById({ id: userId });

      if (!user) {
        throw new ApiErrorInternalServerError({});
      }

      const accessToken = this.authService.generateAccessToken({ userId, loginId });

      const dtoUser = new DtoUser({
        username: user.username,
        email: user.email,
        bio: user.bio,
        image: user.image,
        token: accessToken
      });

      return {
        user: dtoUser
      };
    } catch (error) {
      logger.error(
        `Error creating user with email: ${email} and loginId: ${loginId}. Error message: ${error instanceof Error ? error.message : error}`,
        { label: 'ApiRegistration' }
      );

      if (error instanceof PasswordRequirementsNotMetError) {
        throw new ApiErrorBadRequest({
          message:
            'Password requirements not met. Your password must be at least 6 characters long and contain at least one letter and one digit.',
          cause: error
        });
      }
      if (error instanceof UserExistError) {
        throw new ApiErrorConflict({
          message:
            'The provided email or username is already registered. Please use a different email or username.',
          cause: error
        });
      }
      throw error;
    }
  }
}

================
File: apps/user/service/ApiRegistration/index.ts
================
export { ApiRegistration } from './ApiRegistration';
export { ApiRegistrationInput, ApiRegistrationOutput } from './types';

================
File: apps/user/service/ApiRegistration/types.ts
================
import { AuthService, UserService } from '@conduit/core';

import { DtoUser } from '../../dto';

export interface ApiRegistrationConstructor {
  userService: UserService;
  authService: AuthService;
}

export interface ApiRegistrationInput {
  username: string;
  email: string;
  password: string;
  bio?: string;
  image?: string;
}

export type ApiRegistrationOutput = Promise<{
  user: DtoUser;
}>;

================
File: apps/user/service/ApiUnfollowUser/ApiUnfollowUser.ts
================
import { InvalidFollowError, UserNotFoundError, UserService } from '@conduit/core';
import {
  ApiErrorBadRequest,
  ApiErrorInternalServerError,
  ApiErrorNotFound
} from '@conduit/utils';

import {
  ApiUnfollowUserConstructor,
  ApiUnfollowUserInput,
  ApiUnfollowUserOutput
} from './types';

export class ApiUnfollowUser {
  private userService: UserService;

  constructor({ userService }: ApiUnfollowUserConstructor) {
    this.userService = userService;
  }

  async execute({ userId, username }: ApiUnfollowUserInput): ApiUnfollowUserOutput {
    try {
      await this.userService.unfollowUser({
        followerId: userId,
        followingUsername: username
      });

      const profile = await this.userService.getUserProfile({
        requestingUserId: userId,
        username
      });

      if (!profile) {
        throw new ApiErrorInternalServerError({
          cause: new Error(`Failed to get profile for username ${username}`)
        });
      }

      return {
        profile
      };
    } catch (error) {
      if (error instanceof UserNotFoundError) {
        throw new ApiErrorNotFound({ cause: error });
      }
      if (error instanceof InvalidFollowError) {
        throw new ApiErrorBadRequest({ cause: error });
      }
      throw error;
    }
  }
}

================
File: apps/user/service/ApiUnfollowUser/index.ts
================
export * from './ApiUnfollowUser';

================
File: apps/user/service/ApiUnfollowUser/types.ts
================
import { DbDtoProfile, UserService } from '@conduit/core';

export interface ApiUnfollowUserConstructor {
  userService: UserService;
}

export interface ApiUnfollowUserInput {
  username: string;
  userId: string;
}

export type ApiUnfollowUserOutput = Promise<{
  profile: DbDtoProfile;
}>;

================
File: apps/user/service/ApiUpdateUser/ApiUpdateUser.ts
================
import { PasswordRequirementsNotMetError, UserService } from '@conduit/core';
import {
  ApiErrorInternalServerError,
  ApiErrorUnprocessableEntity
} from '@conduit/utils';

import { ErrorCodes } from '../../constants';
import { DtoUser } from '../../dto';
import {
  ApiUpdateUserConstructor,
  ApiUpdateUserInput,
  ApiUpdateUserOutput
} from './types';

export class ApiUpdateUser {
  private readonly userService: UserService;

  constructor({ userService }: ApiUpdateUserConstructor) {
    this.userService = userService;
  }

  async execute({
    userId,
    username,
    email,
    bio,
    image,
    password
  }: ApiUpdateUserInput): ApiUpdateUserOutput {
    try {
      await this.userService.updateUserById({
        id: userId,
        username,
        email,
        bio,
        image,
        password
      });

      const user = await this.userService.getUserById({ id: userId });

      if (!user) {
        throw new Error('User not found in request object.');
      }

      const dtoUser = new DtoUser({
        username: user.username,
        email: user.email,
        bio: user.bio,
        image: user.image
      });

      return {
        user: dtoUser
      };
    } catch (error) {
      if (error instanceof PasswordRequirementsNotMetError) {
        throw new ApiErrorUnprocessableEntity({
          errorCode: ErrorCodes.PasswordRequirementsNotMet,
          message: 'Password does not meet the server requirements.'
        });
      }
      throw new ApiErrorInternalServerError({});
    }
  }
}

================
File: apps/user/service/ApiUpdateUser/index.ts
================
export { ApiUpdateUser } from './ApiUpdateUser';
export { ApiUpdateUserInput, ApiUpdateUserOutput } from './types';

================
File: apps/user/service/ApiUpdateUser/types.ts
================
import { UserService } from '@conduit/core';

import { DtoUser } from '../../dto';

export interface ApiUpdateUserConstructor {
  userService: UserService;
}

export interface ApiUpdateUserInput {
  userId: string;
  username?: string;
  email?: string;
  bio?: string;
  image?: string;
  password?: string;
}

export type ApiUpdateUserOutput = Promise<{ user: DtoUser }>;

================
File: apps/user/service/ApiUserLogin/ApiUserLogin.ts
================
import { v4 as uuid } from 'uuid';

import {
  AuthService,
  PasswordNotMatchError,
  UserService,
  UserStatus
} from '@conduit/core';
import {
  ApiErrorForbidden,
  ApiErrorInternalServerError,
  ApiErrorNotFound,
  ApiErrorUnauthorized
} from '@conduit/utils';

import { DtoUser } from '../../dto';
import {
  ApiUserLoginConstructor,
  ApiUserLoginInput,
  ApiUserLoginOutput,
  GetUserByEmailInput,
  GetUserByEmailOutput
} from './types';

export class ApiUserLogin {
  private authService: AuthService;
  private userService: UserService;

  constructor({ authService, userService }: ApiUserLoginConstructor) {
    this.authService = authService;
    this.userService = userService;
  }

  async execute({ email, password }: ApiUserLoginInput): ApiUserLoginOutput {
    const user = await this.getUserByEmail({ email });

    try {
      await this.authService.comparePassword({
        password,
        encryptedPassword: user!.hash
      });
    } catch (error) {
      if (error instanceof PasswordNotMatchError) {
        throw new ApiErrorUnauthorized({
          message:
            'Sorry, the password you entered is incorrect. Please double-check your password and try again.',
          cause: error
        });
      }
      throw new ApiErrorInternalServerError({
        cause: error instanceof Error ? error : undefined
      });
    }

    const loginId = uuid();

    const accessToken = this.authService.generateAccessToken({
      userId: user.id,
      loginId
    });

    const dtoUser = new DtoUser({
      username: user.username,
      email: user.email,
      bio: user.bio,
      image: user.image,
      token: accessToken
    });

    return {
      user: dtoUser
    };
  }

  private async getUserByEmail({
    email
  }: GetUserByEmailInput): GetUserByEmailOutput {
    const user = await this.userService.getUserByEmail({ email });

    if (user === undefined) {
      throw new ApiErrorNotFound({
        message:
          "We couldn't find your account. Please check your login information or create a new account."
      });
    }

    if (user.recordStatus === UserStatus.Banned) {
      throw new ApiErrorForbidden({
        message:
          'Sorry, your account has been banned. Please contact support for more information.'
      });
    }

    return user;
  }
}

================
File: apps/user/service/ApiUserLogin/index.ts
================
export { ApiUserLogin } from './ApiUserLogin';
export { ApiUserLoginInput, ApiUserLoginOutput } from './types';

================
File: apps/user/service/ApiUserLogin/types.ts
================
import { AuthService, DbDtoUser, UserService } from '@conduit/core';

import { DtoUser } from '../../dto';

export interface ApiUserLoginConstructor {
  authService: AuthService;
  userService: UserService;
}

export interface ApiUserLoginInput {
  email: string;
  password: string;
}

export type ApiUserLoginOutput = Promise<{
  user: DtoUser;
}>;

/**
 *
 * function: getUserByEmail
 *
 */
export interface GetUserByEmailInput {
  email: string;
}

export type GetUserByEmailOutput = Promise<DbDtoUser>;

================
File: apps/user/service/Factory.ts
================
import { AuthService, ServiceFactory, UserService } from '@conduit/core';

import { ApiFollowUser } from './ApiFollowUser';
import { ApiGetCurrentUser } from './ApiGetCurrentUser';
import { ApiGetProfile } from './ApiGetProfile';
import { ApiRegistration } from './ApiRegistration';
import { ApiUnfollowUser } from './ApiUnfollowUser';
import { ApiUpdateUser } from './ApiUpdateUser';
import { ApiUserLogin } from './ApiUserLogin';

export class Factory {
  private authService: AuthService;
  private userService: UserService;

  constructor() {
    const factory = new ServiceFactory();
    this.authService = factory.newAuthService();
    this.userService = factory.newUserService();
  }

  newApiRegistration(): ApiRegistration {
    return new ApiRegistration({
      userService: this.userService,
      authService: this.authService
    });
  }

  newApiUserLogin(): ApiUserLogin {
    return new ApiUserLogin({
      userService: this.userService,
      authService: this.authService
    });
  }

  newApiUpdateUser(): ApiUpdateUser {
    return new ApiUpdateUser({
      userService: this.userService
    });
  }

  newApiGetCurrentUser(): ApiGetCurrentUser {
    return new ApiGetCurrentUser();
  }

  newApiFollowUser(): ApiFollowUser {
    return new ApiFollowUser({
      userService: this.userService
    });
  }

  newApiUnfollowUser(): ApiUnfollowUser {
    return new ApiUnfollowUser({
      userService: this.userService
    });
  }

  newApiGetProfile(): ApiGetProfile {
    return new ApiGetProfile({
      userService: this.userService
    });
  }
}

================
File: apps/user/service/index.ts
================
export * from './ApiRegistration';
export * from './ApiUserLogin';

export { Factory } from './Factory';

================
File: apps/user/tests/basic/get-current-user.spec.ts
================
import assert from 'assert';
import Chance from 'chance';
import supertest from 'supertest';

import { ServiceFactory, dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';

const request = supertest(app);

describe('GET /api/user', () => {
  it('should be able to get the current user', async () => {
    const { user, accessToken } = await setup();
    const response = await request
      .get('/api/user')
      .set('Authorization', `Bearer ${accessToken}`)
      .send();
    expect(response.status).toBe(200);
    expect(response.body).toBeDefined();
    expect(response.body.user).toBeDefined();
    expect(response.body.user.email).toBe(user.email);
    expect(response.body.user.username).toBe(user.username);
  });

  it("should return a status code of 401 - Unauthorized if the client doesn't provide auth headers", async () => {
    const response = await request.get('/api/user').send();
    expect(response.status).toBe(401);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const factory = new ServiceFactory();
  const userService = factory.newUserService();
  const authService = factory.newAuthService();
  const userId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const accessToken = authService.generateAccessToken({
    userId,
    loginId: chance.guid()
  });
  const user = await userService.getUserById({ id: userId });
  assert(user);
  return {
    user,
    userService,
    accessToken
  };
};

================
File: apps/user/tests/basic/get-profile.spec.ts
================
import assert from 'assert';
import Chance from 'chance';
import supertest from 'supertest';

import { ServiceFactory, dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';

const request = supertest(app);

describe('GET /api/profiles/:username', () => {
  it('should be able to get the user profile', async () => {
    const { userB, accessTokenA } = await setup();
    const response = await request
      .get(`/api/profiles/${userB.username}`)
      .set('Authorization', `Bearer ${accessTokenA}`)
      .send();
    expect(response.status).toBe(200);
    expect(response.body).toBeDefined();
    expect(response.body.profile).toBeDefined();
    const { profile } = response.body;
    expect(profile.username).toBe(userB.username);
    expect(profile.bio).toBe(userB.bio);
    expect(profile.image).toBe(userB.image);
  });

  it('should return a status code of 404 - Not Found if the targeted user does not exist', async () => {
    const { accessTokenA } = await setup();
    const response = await request
      .get('/api/profiles/UN_EXIST_USERNAME')
      .set('Authorization', `Bearer ${accessTokenA}`)
      .send();
    expect(response.status).toBe(404);
  });

  it('should return a profile with the following attribute with a value of true if the requested user is following the targeted user', async () => {
    const { userService, userA, userB, accessTokenA } = await setup();
    await userService.followUser({
      followerId: userA.id,
      followingUsername: userB.username
    });
    const response = await request
      .get(`/api/profiles/${userB.username}`)
      .set('Authorization', `Bearer ${accessTokenA}`)
      .send();
    expect(response.status).toBe(200);
    expect(response.body).toBeDefined();
    expect(response.body.profile).toBeDefined();
    const { profile } = response.body;
    expect(profile.username).toBe(userB.username);

    expect(profile.bio).toBe(userB.bio);
    expect(profile.image).toBe(userB.image);
    expect(profile.following).toBe(true);
  });

  it('should return a profile with the following attribute with a value of false if the requested user is not following the targeted user', async () => {
    const { userB, accessTokenA } = await setup();
    const response = await request
      .get(`/api/profiles/${userB.username}`)
      .set('Authorization', `Bearer ${accessTokenA}`)
      .send();
    expect(response.status).toBe(200);
    expect(response.body).toBeDefined();
    expect(response.body.profile).toBeDefined();
    const { profile } = response.body;
    expect(profile.username).toBe(userB.username);

    expect(profile.bio).toBe(userB.bio);
    expect(profile.image).toBe(userB.image);
    expect(profile.following).toBe(false);
  });

  it('should return a profile with the following attribute with a value of false if the client does not provide a valid auth token', async () => {
    const { userB } = await setup();
    const response = await request.get(`/api/profiles/${userB.username}`).send();
    expect(response.status).toBe(200);
    expect(response.body).toBeDefined();
    expect(response.body.profile).toBeDefined();
    const { profile } = response.body;
    expect(profile.username).toBe(userB.username);

    expect(profile.bio).toBe(userB.bio);
    expect(profile.image).toBe(userB.image);
    expect(profile.following).toBe(false);
  });

  it('should return a status code of 401 - Unauthorized if the client provides an invalid auth header', async () => {
    const { userB, accessTokenA } = await setup();
    const response = await request
      .get(`/api/profiles/${userB.username}`)
      .set('Authorization', `Bearer ${accessTokenA}+InvalidToken`)
      .send();
    expect(response.status).toBe(401);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const factory = new ServiceFactory();
  const userService = factory.newUserService();
  const authService = factory.newAuthService();

  const userAId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const userA = await userService.getUserById({ id: userAId });
  assert(userA);
  const accessTokenA = authService.generateAccessToken({
    userId: userAId,
    loginId: chance.guid()
  });

  const userBId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const userB = await userService.getUserById({ id: userBId });
  assert(userB);
  const accessTokenB = authService.generateAccessToken({
    userId: userBId,
    loginId: chance.guid()
  });

  return {
    userService,
    userA,
    userB,
    accessTokenA,
    accessTokenB
  };
};

================
File: apps/user/tests/basic/login.spec.ts
================
import assert from 'assert';
import Chance from 'chance';
import supertest from 'supertest';

import { ServiceFactory, dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';

const request = supertest(app);

describe('POST /api/users/login', () => {
  it('should be able to login with a correct username and password', async () => {
    const { user } = await setup();
    const response = await request.post('/api/users/login').send({
      user: {
        email: user.email,
        password: 'Abcd1234'
      }
    });
    expect(response.status).toBe(200);
    expect(response.body).toBeDefined();
    expect(response.body.user).toBeDefined();
    expect(response.body.user.email).toBe(user.email);
    expect(response.body.user.token).toBeDefined();
    expect(response.body.user.username).toBe(user.username);
  });

  it('should throw an error if the password entered is incorrect', async () => {
    const { user } = await setup();
    const response = await request.post('/api/users/login').send({
      user: {
        email: user.email,
        password: 'jake1234'
      }
    });
    expect(response.status).toBe(401);
  });

  it('should throw an error if the user does not exist', async () => {
    const { user } = await setup();
    const response = await request.post('/api/users/login').send({
      user: {
        email: `${user.email}.jake`,
        password: 'Abcd1234'
      }
    });
    expect(response.status).toBe(404);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const factory = new ServiceFactory();
  const userService = factory.newUserService();

  const userId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const user = await userService.getUserById({ id: userId });
  assert(user);
  return { user };
};

================
File: apps/user/tests/basic/registration.spec.ts
================
import supertest, { Response } from 'supertest';

import { dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';

const request = supertest(app);

describe('POST /api/users', () => {
  it('should be able to register an user account', async () => {
    const response = await request.post('/api/users').send({
      user: {
        username: 'Jacob',
        email: 'jake@jake.jake',
        password: 'jake123'
      }
    });
    expect(response.status).toBe(200);
    expect(response.body.user).toBeDefined();
    expect(response.body.user.email).toBeDefined();
    expect(response.body.user.username).toBeDefined();
    expect(response.body.user.bio).toBeNull();
    expect(response.body.user.image).toBeNull();
    expect(response.body.user.token).toBeDefined();
  });

  it("should return a status code of 422 - Unprocessable Entity if the client doesn't provide the required data fields", async () => {
    const response = await request.post('/api/users').send({
      user: {
        username: 'Jacob'
      }
    });
    expect(response.status).toBe(422);
  });

  it('should return 409 - Conflict if the username or email has been used before', async () => {
    let response: Response | null = null;
    response = await request.post('/api/users').send({
      user: {
        username: 'Jacob',
        email: 'jake@jake.jake',
        password: 'jake123'
      }
    });
    expect(response.status).toBe(200);
    response = await request.post('/api/users').send({
      user: {
        username: 'Jacob',
        email: 'jake@jake.jake',
        password: 'jake123'
      }
    });
    expect(response.status).toBe(409);
  });

  it("should return 400 - Bad Request if the password doesn't match the policy", async () => {
    const response = await request.post('/api/users').send({
      user: {
        username: 'Jacob',
        email: 'jake@jake.jake',
        password: 'abcdef'
      }
    });
    expect(response.status).toBe(400);
  });

  beforeEach(() => dangerouslyResetDb());
});

================
File: apps/user/tests/basic/update-user.spec.ts
================
import assert from 'assert';
import Chance from 'chance';
import supertest from 'supertest';

import { ServiceFactory, dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';

const request = supertest(app);

describe('PUT /api/user', () => {
  it('should be able to update the user account', async () => {
    const { user, accessToken } = await setup();
    const response = await request
      .put('/api/user')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({
        user: {
          username: 'Ken',
          password: null
        }
      });
    expect(response.status).toBe(200);
    expect(response.body).toBeDefined();
    expect(response.body.user).toBeDefined();
    expect(response.body.user.email).toBe(user.email);
    expect(response.body.user.username).toBe('Ken');
    expect(response.body.user.image).toBe(user.image);
    expect(response.body.user.bio).toBe(user.bio);
  });

  it('should be able to update the user password', async () => {
    const { user, accessToken } = await setup();
    let response = await request
      .put('/api/user')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({
        user: {
          username: 'ken',
          password: 'abc94340634'
        }
      });
    expect(response.status).toBe(200);
    response = await request.post('/api/users/login').send({
      user: {
        email: user.email,
        password: 'abc94340634'
      }
    });
    expect(response.status).toBe(200);
  });

  it('should return a status code of 422 - Unprocessable Entity if the client provides invalid data type', async () => {
    const { accessToken } = await setup();
    const response = await request
      .put('/api/user')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({
        user: {
          username: 'ken',
          email: '123'
        }
      });
    expect(response.status).toBe(422);
  });

  it("should return a status code of 422 - Unprocessable Entity if the client doesn't provide the required data fields", async () => {
    const { accessToken } = await setup();
    const response = await request
      .put('/api/user')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ user: {} });
    expect(response.status).toBe(422);
  });

  it("should return a status code of 401 - Unauthorized if the client doesn't provide auth headers", async () => {
    await setup();
    const response = await request
      .put('/api/user')
      .send({ user: { username: 'ken' } });
    expect(response.status).toBe(401);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const factory = new ServiceFactory();
  const userService = factory.newUserService();
  const authService = factory.newAuthService();
  const userId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const accessToken = authService.generateAccessToken({
    userId,
    loginId: chance.guid()
  });
  const user = await userService.getUserById({ id: userId });
  assert(user);
  return {
    user,
    userService,
    accessToken
  };
};

================
File: apps/user/tests/follow/follow-user.spec.ts
================
import assert from 'assert';
import Chance from 'chance';
import supertest from 'supertest';

import { ServiceFactory, dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';

const request = supertest(app);

describe('POST /api/profiles/:username/follow', () => {
  it('should be able to follow a user', async () => {
    const { userB, accessTokenA } = await setup();
    const response = await request
      .post(`/api/profiles/${userB.username}/follow`)
      .set('Authorization', `Bearer ${accessTokenA}`)
      .send();
    expect(response.status).toBe(200);
    expect(response.body).toBeDefined();
    expect(response.body.profile).toBeDefined();
    const { profile } = response.body;
    expect(profile.username).toBe(userB.username);
    expect(profile.bio).toBe(userB.bio);
    expect(profile.image).toBe(userB.image);
    expect(profile.following).toBe(true);
  });

  it('should return a status code of 401 - Unauthorized if the client does not provide auth headers', async () => {
    const { userB } = await setup();
    const response = await request
      .post(`/api/profiles/${userB.username}/follow`)
      .send();
    expect(response.status).toBe(401);
  });

  it('should return a status code of 400 - Bad Request if the user has already followed the targeted user', async () => {
    const { userService, userA, userB, accessTokenA } = await setup();
    await userService.followUser({
      followerId: userA.id,
      followingUsername: userB.username
    });
    const response = await request
      .post(`/api/profiles/${userB.username}/follow`)
      .set('Authorization', `Bearer ${accessTokenA}`)
      .send();
    expect(response.status).toBe(400);
  });

  it('should return a status code of 400 - Bad Request if the user tries to follow themselves', async () => {
    const { userA, accessTokenA } = await setup();
    const response = await request
      .post(`/api/profiles/${userA.username}/follow`)
      .set('Authorization', `Bearer ${accessTokenA}`)
      .send();
    expect(response.status).toBe(400);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const factory = new ServiceFactory();
  const userService = factory.newUserService();
  const authService = factory.newAuthService();

  const userAId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const userA = await userService.getUserById({ id: userAId });
  assert(userA);
  const accessTokenA = authService.generateAccessToken({
    userId: userAId,
    loginId: chance.guid()
  });

  const userBId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const userB = await userService.getUserById({ id: userBId });
  assert(userB);
  const accessTokenB = authService.generateAccessToken({
    userId: userBId,
    loginId: chance.guid()
  });

  return {
    userService,
    userA,
    userB,
    accessTokenA,
    accessTokenB
  };
};

================
File: apps/user/tests/follow/unfollow-user.spec.ts
================
import assert from 'assert';
import Chance from 'chance';
import supertest from 'supertest';

import { ServiceFactory, dangerouslyResetDb } from '@conduit/core';

import { app } from '../../app';

const request = supertest(app);

describe('DELETE /api/profiles/:username/follow', () => {
  it('should be able to unfollow a user', async () => {
    const { userB, accessTokenA } = await setup();
    await request
      .post(`/api/profiles/${userB.username}/follow`)
      .set('Authorization', `Bearer ${accessTokenA}`)
      .send();
    const response = await request
      .delete(`/api/profiles/${userB.username}/follow`)
      .set('Authorization', `Bearer ${accessTokenA}`)
      .send();
    expect(response.status).toBe(200);
    expect(response.body).toBeDefined();
    expect(response.body.profile).toBeDefined();
    const { profile } = response.body;
    expect(profile.username).toBe(userB.username);
    expect(profile.bio).toBe(userB.bio);
    expect(profile.image).toBe(userB.image);
    expect(profile.following).toBe(false);
  });

  it('should return a status code of 401 - Unauthorized if the client does not provide auth headers', async () => {
    const { userB } = await setup();
    const response = await request
      .delete(`/api/profiles/${userB.username}/follow`)
      .send();
    expect(response.status).toBe(401);
  });

  it('should return a status code of 400 - Bad Request if the user does not follow the targeted user', async () => {
    const { accessTokenA, userB } = await setup();
    const response = await request
      .delete(`/api/profiles/${userB.username}/follow`)
      .set('Authorization', `Bearer ${accessTokenA}`)
      .send();
    expect(response.status).toBe(400);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const factory = new ServiceFactory();
  const userService = factory.newUserService();
  const authService = factory.newAuthService();

  const userAId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const userA = await userService.getUserById({ id: userAId });
  assert(userA);
  const accessTokenA = authService.generateAccessToken({
    userId: userAId,
    loginId: chance.guid()
  });

  const userBId = await userService.createUser({
    email: chance.email(),
    password: 'Abcd1234',
    username: chance.word()
  });
  const userB = await userService.getUserById({ id: userBId });
  assert(userB);
  const accessTokenB = authService.generateAccessToken({
    userId: userBId,
    loginId: chance.guid()
  });

  return {
    userService,
    userA,
    userB,
    accessTokenA,
    accessTokenB
  };
};

================
File: apps/user/tsconfig.json
================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "@conduit/config/tsconfig.base.json",
  "compilerOptions": {
    "sourceMap": false
  },
  "include": ["./**/*.ts"]
}

================
File: apps/user/types/global.d.ts
================
import '@conduit/core/types/global';

================
File: codecov.yml
================
codecov:
  branch: master

coverage:
  precision: 2
  round: nearest
  range: 80..100
  status:
    project:
      default:
        target: auto
        threshold: 0.1%
        if_not_found: success
        informational: false
        only_pulls: false
      core:
        paths:
          - ./packages/core/**
      user:
        paths:
          - ./apps/server/user/**
      article:
        paths:
          - ./apps/server/article/**

================
File: config/ci.json
================
{
  "nodeEnv": "ci",
  "mode": "local",
  "domain": "localhost",
  "auth": {
    "expiresIn": "1d",
    "jwtSecret": "how_do_you_turn_this_on"
  },
  "database": {
    "conduit": {
      "host": "localhost",
      "port": "3306",
      "user": "mysql",
      "password": "mysql",
      "database": "conduit"
    }
  }
}

================
File: config/custom-environment-variables.json
================
{
  "nodeEnv": "NODE_ENV",
  "domain": "DOMAIN",
  "auth": {
    "expiresIn": "AUTH_EXPIRES_IN",
    "jwtSecret": "AUTH_JWT_SECRET"
  },
  "database": {
    "conduit": {
      "host": "DATABASE_HOST",
      "port": "DATABASE_PORT",
      "user": "DATABASE_USER",
      "password": "DATABASE_PASSWORD",
      "database": "DATABASE_NAME"
    }
  }
}

================
File: config/default.json
================
{
  "mode": "lambda",
  "auth": {
    "expiresIn": "1d"
  },
  "database": {
    "conduit": {
      "port": "3306"
    }
  }
}

================
File: config/develop.json
================
{
  "nodeEnv": "develop"
}

================
File: config/prod.json
================
{
  "nodeEnv": "prod"
}

================
File: config/test.json
================
{
  "nodeEnv": "test",
  "auth": {
    "expiresIn": "1d",
    "jwtSecret": "how_do_you_turn_this_on"
  },
  "database": {
    "conduit": {
      "host": "db",
      "port": "3306",
      "user": "user",
      "password": "password",
      "database": "db"
    }
  }
}

================
File: docker-compose.yml
================
version: '3.8'

services:
  server:
    container_name: conduit-local
    build:
      context: .
      dockerfile: ./apps/local/Dockerfile
    ports:
      - "3100:3100"
    command: node apps/local/local.js
    environment:
      - NODE_ENV=develop
      - MODE=local
      - DOMAIN=localhost
      - AUTH_JWT_SECRET=how-do-you-turn-this-on-in-2024
      - AUTH_JWT_EXPIRES_IN=1d
      - DATABASE_HOST=conduit-mysql
      - DATABASE_PORT=3306
      - DATABASE_USER=conduit
      - DATABASE_PASSWORD=how-do-you-turn-this-on-twice
      - DATABASE_NAME=conduit-local
    depends_on:
      - mysql
      - db-migration

  mysql:
    image: mysql:8.0
    container_name: conduit-mysql
    environment:
      MYSQL_ROOT_PASSWORD: how-do-you-turn-this-on 
      MYSQL_DATABASE: conduit-local        
      MYSQL_USER: conduit
      MYSQL_PASSWORD: how-do-you-turn-this-on-twice      
    ports:
      - "3306:3306"

  db-migration:
    container_name: conduit-db-migration
    command: ["yarn", "db:migrate"]
    build:
      context: .
      dockerfile: ./packages/core/database/Dockerfile
    environment:
      - NODE_ENV=develop
      - DATABASE_HOST=conduit-mysql
      - DATABASE_PORT=3306
      - DATABASE_USER=conduit
      - DATABASE_PASSWORD=how-do-you-turn-this-on-twice
      - DATABASE_NAME=conduit-local
    depends_on:
      - mysql

================
File: infra/.eslintrc.json
================
{
  "extends": [
    "eslint:recommended",
    "eslint-config-airbnb-base",
    "airbnb-typescript",
    "plugin:@typescript-eslint/recommended",
    "prettier"
  ],
  "env": {
    "es2021": true,
    "node": true
  },
  "parser": "@typescript-eslint/parser",
  "plugins": ["@typescript-eslint", "prettier"],
  "rules": {
    "@typescript-eslint/no-unused-vars": "error",
    "import/prefer-default-export": "off",
    "no-tabs": ["off"],
    "max-len": ["off"],
    "no-await-in-loop": "off",
    "react/jsx-filename-extension": "off",
    "class-methods-use-this": "off",
    "no-new": "off",
    "no-param-reassign": "off",
    "@typescript-eslint/quotes": [
      "error",
      "single",
      {
        "avoidEscape": true
      }
    ],
    "@typescript-eslint/comma-dangle": ["error", "never"],
    "@typescript-eslint/no-namespace": "off",
    "@typescript-eslint/no-non-null-assertion": "off",
    "@typescript-eslint/no-use-before-define": "off",
    "@typescript-eslint/no-explicit-any": "off",
    "@typescript-eslint/lines-between-class-members": [
      "error",
      "always",
      {
        "exceptAfterSingleLine": true
      }
    ],
    "prettier/prettier": [
      "error",
      {
        "tabWidth": 2
      }
    ]
  },
  "overrides": [
    {
      "files": ["*.spec.{js,ts}"],
      "env": {
        "mocha": true,
        "node": true
      },
      "rules": {
        "no-unused-expressions": "off",
        "@typescript-eslint/no-unused-expressions": "off",
        "@typescript-eslint/no-throw-literal": "off"
      }
    }
  ],
  "parserOptions": {
    "project": "./tsconfig.json"
  },
  "ignorePatterns": [
    "dist",
    "node_modules",
    ".eslintrc.js",
    "jest.config.js",
    "cdk.out"
  ]
}

================
File: infra/.prettierignore
================
cdk.out

================
File: infra/.prettierrc.json
================
{
  "printWidth": 85,
  "tabWidth": 2,
  "useTabs": false,
  "semi": true,
  "singleQuote": true,
  "quoteProps": "as-needed",
  "jsxSingleQuote": false,
  "trailingComma": "none",
  "bracketSpacing": true,
  "jsxBracketSameLine": false,
  "arrowParens": "always",
  "proseWrap": "always",
  "plugins": [
    "prettier-plugin-packagejson",
    "@trivago/prettier-plugin-sort-imports"
  ],
  "importOrder": ["^dotenv/config$", "<THIRD_PARTY_MODULES>", "^[./]"],
  "importOrderSeparation": true,
  "importOrderSortSpecifiers": true,
  "importOrderCaseInsensitive": false
}

================
File: infra/cdk.json
================
{
  "app": "ts-node main.ts"
}

================
File: infra/config/custom-environment-variables.json
================
{
  "nodeEnv": "NODE_ENV",
  "aws": {
    "region": "AWS_REGION",
    "accountId": "AWS_ACCOUNT_ID",
    "arn": {
      "role": {
        "lambda": "AWS_ROLE_LAMBDA_ARN"
      }
    }
  },
  "github": {
    "repository": "GITHUB_REPOSITORY",
    "owner": "GITHUB_OWNER"
  }
}

================
File: infra/config/default.json
================
{
  "aws": {
    "region": "us-east-1"
  },
  "github": {
    "repository": "realworld-nodejs-example-app",
    "owner": "kenyipp"
  }
}

================
File: infra/config/develop.json
================
{
  "nodeEnv": "develop"
}

================
File: infra/config/prod.json
================
{
  "nodeEnv": "prod"
}

================
File: infra/constants/constants.ts
================
import { config } from '../utils';

const app = 'conduit-api';
const { accountId } = config.aws;

export const ResourcePrefix = `${app}-${config.nodeEnv}-${accountId}`;

================
File: infra/constants/index.ts
================
export * from './constants';
export * from './Lambdas';
export * from './Stacks';
export * from './Secrets';

================
File: infra/constants/Lambdas.ts
================
import { ResourcePrefix } from './constants';

export const Lambdas = {
  UserServerFunction: `${ResourcePrefix}-user-server-lambda`,
  AppServerFunction: `${ResourcePrefix}-app-server-lambda`,
  ArticleServerFunction: `${ResourcePrefix}-article-server-lambda`,
  TestingCron: `${ResourcePrefix}-testing-cron-lambda`
};

================
File: infra/constants/Secrets.ts
================
import { config } from '../utils';

export const Secrets = {
  GithubToken: 'conduit/github-token',
  DatabaseConfig: `conduit/${config.nodeEnv}/database`,
  JwtSecret: `conduit/${config.nodeEnv}/jwt-token`,
  DomainCert: `conduit/${config.nodeEnv}/acm-certificate`
};

================
File: infra/constants/Stacks.ts
================
import { ResourcePrefix } from './constants';

export const Stacks = {
  ApiGateway: `${ResourcePrefix}-api-gateway-stack`,
  Lambda: `${ResourcePrefix}-lambda-stack`
};

================
File: infra/main.ts
================
import 'dotenv/config';

import { CdkGraph, FilterPreset } from '@aws/pdk/cdk-graph';
import {
  CdkGraphDiagramPlugin,
  DiagramFormat
} from '@aws/pdk/cdk-graph-plugin-diagram';
import { App, Environment } from 'aws-cdk-lib';

import { Stacks } from './constants';
import { ApiGatewayStack, LambdaStack } from './stacks';
import { config } from './utils';

// eslint-disable-next-line no-void, func-names
void (async function () {
  const app = new App();

  const env: Environment = {
    region: config.aws.region,
    account: config.aws.accountId
  };

  const lambdaStack = new LambdaStack(app, Stacks.Lambda, {
    env,
    roleArn: config.aws.arn.role.lambda
  });

  new ApiGatewayStack(app, Stacks.ApiGateway, {
    env,
    userFunctionArn: lambdaStack.userServerFunction.functionArn,
    appFunctionArn: lambdaStack.appServerFunction.functionArn,
    articleServerFunctionArn: lambdaStack.articleServerFunction.functionArn
  });

  // Generate a diagram for the whole architecture
  const group = new CdkGraph(app, {
    plugins: [
      new CdkGraphDiagramPlugin({
        diagrams: [
          {
            name: 'conduit-api-stack-diagram',
            title: 'Conduit Api Stack Diagram',
            format: DiagramFormat.PNG,
            theme: 'light',
            filterPlan: {
              preset: FilterPreset.COMPACT
            }
          }
        ]
      })
    ]
  });

  app.synth();

  await group.report();
})();

================
File: infra/Makefile
================
qa:
	yarn prettify && yarn lint:fix

================
File: infra/package.json
================
{
  "name": "@conduit/lamba-infra",
  "version": "1.0.0",
  "description": "",
  "license": "ISC",
  "author": "ken.yip",
  "main": "main.ts",
  "scripts": {
    "cdk:list": "cdk list",
    "check-types": "tsc --skipLibCheck --noEmit",
    "deploy": "cdk deploy --require-approval never",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "prettify": "prettier --write .",
    "synth": "cdk synth"
  },
  "dependencies": {
    "@aws/pdk": "^0.25.0",
    "aws-cdk": "2.161.1",
    "aws-cdk-lib": "2.161.1",
    "config": "^3.3.12",
    "constructs": "^10.4.1",
    "dotenv": "^16.4.5"
  },
  "devDependencies": {
    "@trivago/prettier-plugin-sort-imports": "^4.3.0",
    "@types/config": "^3.3.5",
    "@types/node": "^22.7.5",
    "@typescript-eslint/eslint-plugin": "^5.30.7",
    "@typescript-eslint/parser": "^5.30.7",
    "eslint": "^8.19.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "eslint-config-airbnb-typescript": "^17.0.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-jest": "^26.5.3",
    "eslint-plugin-prettier": "^5.2.1",
    "prettier": "^3.3.3",
    "prettier-plugin-packagejson": "^2.5.3",
    "ts-node": "^10.9.1",
    "typescript": "^5.6.3"
  }
}

================
File: infra/stacks/ApiGatewayStack/ApiGatewayStack.ts
================
import { CfnOutput, Stack } from 'aws-cdk-lib';
import {
  CfnApiMapping,
  CfnDomainName,
  CorsHttpMethod,
  HttpApi,
  HttpMethod
} from 'aws-cdk-lib/aws-apigatewayv2';
import { HttpLambdaIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';
import { Function as LambdaFunction } from 'aws-cdk-lib/aws-lambda';
import { Secret } from 'aws-cdk-lib/aws-secretsmanager';
import { Construct } from 'constructs';

import { Secrets, Stacks } from '../../constants';
import { config } from '../../utils';
import {
  ApiGatewayStackProps,
  MapAppApiGatewayRoutesInput,
  MapAppApiGatewayRoutesOutput,
  SetupApiGatewayDomainInput,
  SetupApiGatewayDomainOutput,
  SetupAppApiGatewayOutput,
  SetupAppServerIntegrationInput,
  SetupAppServerIntegrationOutput,
  SetupArticleServerIntegrationInput,
  SetupArticleServerIntegrationOutput,
  SetupUserServerIntegrationInput,
  SetupUserServerIntegrationOutput
} from './types';

export class ApiGatewayStack extends Stack {
  constructor(scope: Construct, id: string, props: ApiGatewayStackProps) {
    super(scope, id, props);
    const { userFunctionArn, appFunctionArn, articleServerFunctionArn } = props;

    const appApiGateway = this.setupAppApiGateway();

    const userServerIntegration = this.setupUserServerIntegration({
      userFunctionArn
    });

    const appServerIntegration = this.setupAppServerIntegration({
      appFunctionArn
    });

    const articleServerIntegration = this.setupArticleServerIntegration({
      articleServerFunctionArn
    });

    this.mapAppApiGatewayRoutes({
      appApiGateway,
      appServerIntegration,
      userServerIntegration,
      articleServerIntegration
    });

    this.setupApiGatewayDomain({
      appApiGateway
    });
  }

  private mapAppApiGatewayRoutes({
    appApiGateway,
    appServerIntegration,
    articleServerIntegration,
    userServerIntegration
  }: MapAppApiGatewayRoutesInput): MapAppApiGatewayRoutesOutput {
    /**
     *
     * App Routes
     *
     */
    appApiGateway.addRoutes({
      path: '/',
      methods: [HttpMethod.GET],
      integration: appServerIntegration
    });

    appApiGateway.addRoutes({
      path: '/api/health-check',
      methods: [HttpMethod.GET],
      integration: appServerIntegration
    });

    appApiGateway.addRoutes({
      path: '/swagger.json',
      methods: [HttpMethod.GET],
      integration: appServerIntegration
    });

    /**
     *
     * User Routes
     *
     */
    appApiGateway.addRoutes({
      path: '/api/profiles/:username',
      methods: [HttpMethod.GET],
      integration: userServerIntegration
    });

    appApiGateway.addRoutes({
      path: '/api/users',
      methods: [HttpMethod.POST],
      integration: userServerIntegration
    });

    appApiGateway.addRoutes({
      path: '/api/users/login',
      methods: [HttpMethod.POST],
      integration: userServerIntegration
    });

    appApiGateway.addRoutes({
      path: '/api/profiles/:username/follow',
      methods: [HttpMethod.POST, HttpMethod.DELETE],
      integration: userServerIntegration
    });

    appApiGateway.addRoutes({
      path: '/api/user',
      methods: [HttpMethod.PUT, HttpMethod.GET],
      integration: userServerIntegration
    });

    /**
     *
     * Article Routes
     *
     */
    appApiGateway.addRoutes({
      path: '/api/articles',
      methods: [HttpMethod.GET, HttpMethod.POST],
      integration: articleServerIntegration
    });

    appApiGateway.addRoutes({
      path: '/api/articles/feed',
      methods: [HttpMethod.GET],
      integration: articleServerIntegration
    });

    appApiGateway.addRoutes({
      path: '/api/articles/:slug',
      methods: [HttpMethod.GET, HttpMethod.PUT, HttpMethod.DELETE],
      integration: articleServerIntegration
    });

    appApiGateway.addRoutes({
      path: '/api/articles/:slug/favorite',
      methods: [HttpMethod.POST, HttpMethod.DELETE],
      integration: articleServerIntegration
    });

    appApiGateway.addRoutes({
      path: '/api/articles/:slug/comments',
      methods: [HttpMethod.GET, HttpMethod.POST],
      integration: articleServerIntegration
    });

    appApiGateway.addRoutes({
      path: '/api/articles/:slug/comments/:id',
      methods: [HttpMethod.DELETE],
      integration: articleServerIntegration
    });

    appApiGateway.addRoutes({
      path: '/api/tags',
      methods: [HttpMethod.GET],
      integration: articleServerIntegration
    });
  }

  private setupUserServerIntegration({
    userFunctionArn
  }: SetupUserServerIntegrationInput): SetupUserServerIntegrationOutput {
    const lambdaFunction = LambdaFunction.fromFunctionArn(
      this,
      `${Stacks.ApiGateway}-user-server-function`,
      userFunctionArn
    );

    const integration = new HttpLambdaIntegration(
      `${Stacks.ApiGateway}-user-server-integration`,
      lambdaFunction
    );
    return integration;
  }

  private setupArticleServerIntegration({
    articleServerFunctionArn
  }: SetupArticleServerIntegrationInput): SetupArticleServerIntegrationOutput {
    const lambdaFunction = LambdaFunction.fromFunctionArn(
      this,
      `${Stacks.ApiGateway}-article-server-function`,
      articleServerFunctionArn
    );

    const integration = new HttpLambdaIntegration(
      `${Stacks.ApiGateway}-article-server-integration`,
      lambdaFunction
    );
    return integration;
  }

  private setupAppServerIntegration({
    appFunctionArn
  }: SetupAppServerIntegrationInput): SetupAppServerIntegrationOutput {
    const lambdaFunction = LambdaFunction.fromFunctionArn(
      this,
      `${Stacks.ApiGateway}-app-server-function`,
      appFunctionArn
    );

    const integration = new HttpLambdaIntegration(
      `${Stacks.ApiGateway}-app-server-integration`,
      lambdaFunction
    );
    return integration;
  }

  private setupApiGatewayDomain({
    appApiGateway
  }: SetupApiGatewayDomainInput): SetupApiGatewayDomainOutput {
    const domainArn = Secret.fromSecretNameV2(
      this,
      `${Stacks.ApiGateway}-domain-cert`,
      Secrets.DomainCert
    );

    const domain = new CfnDomainName(this, `${Stacks.ApiGateway}-domain-name`, {
      domainName: `conduit-api-${config.nodeEnv}.kenyip.cc`,
      domainNameConfigurations: [
        {
          certificateArn: domainArn.secretValue.toString(),
          endpointType: 'REGIONAL'
        }
      ]
    });

    new CfnApiMapping(this, `${Stacks.ApiGateway}-base-api-mapping`, {
      apiId: appApiGateway.apiId,
      domainName: domain.ref,
      stage: appApiGateway.defaultStage?.stageName || 'default'
    });
  }

  private setupAppApiGateway(): SetupAppApiGatewayOutput {
    const httpApi = new HttpApi(this, `${Stacks.ApiGateway}-app-api-gateway`, {
      apiName: `conduit-api-${config.nodeEnv}`,
      corsPreflight: {
        allowOrigins: ['*'],
        allowMethods: [
          CorsHttpMethod.GET,
          CorsHttpMethod.POST,
          CorsHttpMethod.PUT,
          CorsHttpMethod.DELETE,
          CorsHttpMethod.OPTIONS,
          CorsHttpMethod.PATCH
        ],
        allowHeaders: [
          'authorization',
          'x-requested-with',
          'content-type',
          'accept',
          'user-agent',
          'referer'
        ]
      }
    });

    new CfnOutput(this, 'AppApiGatewayEndpoint', { value: httpApi.apiEndpoint });

    return httpApi;
  }
}

================
File: infra/stacks/ApiGatewayStack/index.ts
================
export * from './ApiGatewayStack';

================
File: infra/stacks/ApiGatewayStack/types.ts
================
import { StackProps } from 'aws-cdk-lib';
import { HttpApi } from 'aws-cdk-lib/aws-apigatewayv2';
import { HttpLambdaIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';

export interface ApiGatewayStackProps extends StackProps {
  userFunctionArn: string;
  appFunctionArn: string;
  articleServerFunctionArn: string;
}

/**
 *
 * function: setupAppApiGateway
 *
 */
export type SetupAppApiGatewayOutput = HttpApi;

/**
 *
 * function: setupAppServerIntegration
 *
 */
export interface SetupAppServerIntegrationInput {
  appFunctionArn: string;
}

export type SetupAppServerIntegrationOutput = HttpLambdaIntegration;

/**
 *
 * function: setupArticleServerIntegration
 *
 */
export interface SetupArticleServerIntegrationInput {
  articleServerFunctionArn: string;
}

export type SetupArticleServerIntegrationOutput = HttpLambdaIntegration;

/**
 *
 * function: setupUserServerIntegration
 *
 */
export interface SetupUserServerIntegrationInput {
  userFunctionArn: string;
}

export type SetupUserServerIntegrationOutput = HttpLambdaIntegration;

/**
 *
 * function: mapAppApiGatewayRoutes
 *
 */
export interface MapAppApiGatewayRoutesInput {
  appApiGateway: HttpApi;
  appServerIntegration: HttpLambdaIntegration;
  userServerIntegration: HttpLambdaIntegration;
  articleServerIntegration: HttpLambdaIntegration;
}

export type MapAppApiGatewayRoutesOutput = void;

/**
 *
 * function: setupApiGatewayDomain
 *
 */
export interface SetupApiGatewayDomainInput {
  appApiGateway: HttpApi;
}

export type SetupApiGatewayDomainOutput = void;

================
File: infra/stacks/index.ts
================
export * from './LambdaStack';
export * from './ApiGatewayStack';

================
File: infra/stacks/LambdaStack/constants/FileExcludeList.ts
================
export const FileExcludeList = [
  '.cspell',
  '.cspell.json',
  '.env',
  '.prettierrc.cjs',
  '.eslintrc.json',
  '.prettierrc.json',
  'cdk.out',
  'infra',
  'scripts',
  '.editorconfig',
  '.turbo',
  '.gitignore',
  'LICENSE',
  'Makefile',
  'turbo.json',
  'tsconfig.json',
  '**/*.ts' // Exclude all TypeScript files from the bundle
];

================
File: infra/stacks/LambdaStack/constants/index.ts
================
export * from './FileExcludeList';

================
File: infra/stacks/LambdaStack/index.ts
================
export * from './LambdaStack';

================
File: infra/stacks/LambdaStack/LambdaStack.ts
================
import { Duration, Stack } from 'aws-cdk-lib';
import { Role, ServicePrincipal } from 'aws-cdk-lib/aws-iam';
import {
  Code,
  Function as LambdaFunction,
  Runtime,
  Tracing
} from 'aws-cdk-lib/aws-lambda';
import { Construct } from 'constructs';

import { Lambdas, Stacks } from '../../constants';
import { FileExcludeList } from './constants';
import {
  ConvertArnsToCdkResourcesInput,
  ConvertArnsToCdkResourcesOutput,
  CreateAppServerFunctionOutput,
  CreateArticleServerFunctionOutput,
  CreateUserServerFunctionOutput,
  GetGlobalFunctionPropsInput,
  GetGlobalFunctionPropsOutput,
  GlobalProps,
  LambdaStackProps
} from './types';
import { getEnvironmentVariables } from './utils';

export class LambdaStack extends Stack {
  public readonly appServerFunction: LambdaFunction;
  public readonly userServerFunction: LambdaFunction;
  public readonly articleServerFunction: LambdaFunction;
  private readonly globalProps: GlobalProps;

  constructor(scope: Construct, id: string, props: LambdaStackProps) {
    super(scope, id, props);
    const { roleArn } = props;

    const { role } = this.convertArnsToCdkResources({
      roleArn
    });

    this.globalProps = this.getGlobalFunctionPropsOutput({ role });

    this.appServerFunction = this.createAppServerFunction();
    this.userServerFunction = this.createUserServiceFunction();
    this.articleServerFunction = this.createArticleServiceFunction();
  }

  private createAppServerFunction(): CreateAppServerFunctionOutput {
    const appServerFunction = new LambdaFunction(this, Lambdas.AppServerFunction, {
      handler: 'apps/app/server.handler',
      description: 'The lambda function that handles all user related requests',
      ...this.globalProps
    });

    appServerFunction.grantInvoke(new ServicePrincipal('apigateway.amazonaws.com'));

    return appServerFunction;
  }

  private createUserServiceFunction(): CreateUserServerFunctionOutput {
    const userServerFunction = new LambdaFunction(this, Lambdas.UserServerFunction, {
      handler: 'apps/user/server.handler',
      description: 'The lambda function that handles all user related requests',
      ...this.globalProps
    });

    /**
     *
     * Grant the Api Gateway service permission to invoke this Lambda function
     *
     * Reference: https://repost.aws/knowledge-center/api-gateway-http-lambda-integrations
     *
     */
    userServerFunction.grantInvoke(new ServicePrincipal('apigateway.amazonaws.com'));

    return userServerFunction;
  }

  private createArticleServiceFunction(): CreateArticleServerFunctionOutput {
    const articleServerFunction = new LambdaFunction(
      this,
      Lambdas.ArticleServerFunction,
      {
        handler: 'apps/article/article.handler',
        description: 'The lambda function that handles all article related requests',
        ...this.globalProps
      }
    );

    articleServerFunction.grantInvoke(
      new ServicePrincipal('apigateway.amazonaws.com')
    );

    return articleServerFunction;
  }

  private getGlobalFunctionPropsOutput({
    role
  }: GetGlobalFunctionPropsInput): GetGlobalFunctionPropsOutput {
    return {
      runtime: Runtime.NODEJS_18_X,
      code: Code.fromAsset('../', {
        exclude: FileExcludeList
      }),
      role,
      timeout: Duration.seconds(30),
      memorySize: 256,
      tracing: Tracing.ACTIVE,
      environment: getEnvironmentVariables([
        'DATABASE_HOST',
        'DATABASE_NAME',
        'DATABASE_USER',
        'DATABASE_PASSWORD',
        'DATABASE_PORT',
        'AUTH_JWT_SECRET'
      ])
    };
  }

  private convertArnsToCdkResources({
    roleArn
  }: ConvertArnsToCdkResourcesInput): ConvertArnsToCdkResourcesOutput {
    const role = Role.fromRoleArn(this, `${Stacks.Lambda}-execution-role`, roleArn);
    return {
      role
    };
  }
}

================
File: infra/stacks/LambdaStack/types.ts
================
import { StackProps } from 'aws-cdk-lib';
import { IRole } from 'aws-cdk-lib/aws-iam';
import { FunctionProps, Function as LambdaFunction } from 'aws-cdk-lib/aws-lambda';

export interface LambdaStackProps extends StackProps {
  roleArn: string;
}

export type GlobalProps = Required<
  Pick<
    FunctionProps,
    | 'runtime'
    | 'code'
    | 'role'
    | 'timeout'
    | 'memorySize'
    | 'tracing'
    | 'environment'
  >
>;

/**
 *
 * function: getGlobalFunctionProps
 *
 */
export interface GetGlobalFunctionPropsInput {
  role: IRole;
}

export type GetGlobalFunctionPropsOutput = GlobalProps;

/**
 *
 * function: convertArnsToCdkResources
 *
 */
export interface ConvertArnsToCdkResourcesInput {
  roleArn: string;
}

export interface ConvertArnsToCdkResourcesOutput {
  role: IRole;
}

/**
 *
 * function: createAppServerFunction
 *
 */
export type CreateAppServerFunctionOutput = LambdaFunction;

/**
 *
 * function: createUserServerFunction
 *
 */
export type CreateUserServerFunctionOutput = LambdaFunction;

/**
 *
 * function: createArticleServerFunction
 *
 */
export type CreateArticleServerFunctionOutput = LambdaFunction;

================
File: infra/stacks/LambdaStack/utils/getEnvironmentVariables.ts
================
import { config } from '../../../utils';

export const getEnvironmentVariables = (vars: string[]) =>
  vars.reduce(
    (acc, curr) => {
      acc[curr] = process.env[curr];
      return acc;
    },
    {
      NODE_ENV: config.nodeEnv
    }
  );

================
File: infra/stacks/LambdaStack/utils/index.ts
================
export * from './getEnvironmentVariables';

================
File: infra/tsconfig.json
================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Default",
  "compilerOptions": {
    // Warn user if the code is provably unreachable due to the use of JavaScript syntax
    "allowUnreachableCode": false,
    // Ensures that your files are parsed in the ECMAScript strict mode, and emit ‚Äúuse strict‚Äù for each source file.
    "alwaysStrict": true,
    // With exactOptionalPropertyTypes enabled, TypeScript applies stricter rules around how it handles properties on type or interfaces which have a ? prefix.
    // "exactOptionalPropertyTypes": true,
    // Report errors for fallthrough cases in switch statements
    "noFallthroughCasesInSwitch": true,
    // TypeScript will issue an error whenever it would have inferred any
    "noImplicitAny": false,
    // Receive the error when override is missing
    "noImplicitOverride": false,
    // When enabled, TypeScript will check all code paths in a function to ensure they return a value.
    "noImplicitReturns": true,
    // Raise error on ‚Äòthis‚Äô expressions with an implied ‚Äòany‚Äô type.
    "noImplicitThis": true,
    // Raise an error because the unknown field uses dot syntax instead of indexed syntax
    "noPropertyAccessFromIndexSignature": false,
    // Add undefined to any un-declared field in the type
    "noUncheckedIndexedAccess": true,
    // Report errors on unused local variables
    // Disable on development
    "noUnusedLocals": false,
    // Disable because for express middleware function
    "noUnusedParameters": false,
    // When set, TypeScript will check that the built-in methods of functions call, bind, and apply
    // are invoked with correct argument for the underlying function
    "strictBindCallApply": true,
    // When enabled, this flag causes functions parameters to be checked more correctly.
    "strictFunctionTypes": true,
    // When strictNullChecks is true, null and undefined have their own distinct types
    // and you‚Äôll get a type error if you try to use them where a concrete value is expected.
    "strictNullChecks": true,
    // When set to true, TypeScript will raise an error when a class property was declared but not set in the constructor.
    // We should use "!" for property we have not declared
    "strictPropertyInitialization": false,
    // Set the type of error to unknown
    "useUnknownInCatchVariables": true,
    // Sets the module system for the program. See the Modules reference page for more information.
    // You very likely want "CommonJS" for node projects.
    "module": "CommonJS",
    // A series of entries which re-map imports to lookup locations relative to the baseUrl.
    "paths": {},
    // Allows importing modules with a ‚Äò.json‚Äô extension, which is a common practice in node projects.
    "resolveJsonModule": true,
    // Generate .d.ts files for every TypeScript or JavaScript file inside your project
    "declaration": false,
    // Offers a way to configure the root directory for where declaration files are emitted.
    // "declarationDir": "types"
    // Down leveling is TypeScript‚Äôs term for transpiling to an older version of JavaScript
    "downlevelIteration": true,
    // Only emit .d.ts files; do not emit .js files.
    "emitDeclarationOnly": false,
    // Helper functions are instead imported from the tslib module.
    "importHelpers": false,
    // Do not erase const enum declarations in generated code.
    "preserveConstEnums": true,
    // Enables the generation of sourcemap files.
    // These files allow debuggers and other tools to display the original TypeScript source code when actually working with the emitted JavaScript files.
    "sourceMap": true,
    // Do not emit declarations for code that has an @internal annotation in its JSDoc comment.
    "stripInternal": true,
    // Allow JavaScript files to be imported inside your project, instead of just .ts and .tsx files.
    "allowJs": true,
    // Allow import as default when the module does not explicitly specify a default export.
    "allowSyntheticDefaultImports": true,
    // Enables experimental support for emitting type metadata for decorators which works with the module reflect-metadata.
    "emitDecoratorMetadata": true,
    // Enables experimental support for decorators, which is in stage 2 of the TC39 standardization process.
    "experimentalDecorators": true,
    "lib": ["ES2022"],
    "generateCpuProfile": "profile.cpuprofile",
    "target": "ES2022",
    "moduleResolution": "node",
    "strict": true,
    "removeComments": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "exclude": [
    "node_modules",
    "build",
    ".next",
    "dist",
    "test.ts",
    "output",
    "coverage",
    "*.spec.ts",
    "cdk.out"
  ],
  "include": ["./**/*"]
}

================
File: infra/utils/config/config.ts
================
import nodeConfig from 'config';

import { Config } from './types';

export const config: Config = nodeConfig.util.toObject();

================
File: infra/utils/config/index.ts
================
export * from './config';

================
File: infra/utils/config/types.ts
================
export interface Config {
  nodeEnv: 'develop' | 'prod';
  aws: {
    region: string;
    accountId: string;
    arn: {
      role: {
        lambda: string;
      };
    };
  };
  github: {
    owner: string;
    repository: string;
  };
}

================
File: infra/utils/index.ts
================
export * from './config';

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Ken Yip

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

================
File: Makefile
================
test-build:
	yarn clean && yarn build 
	node ./apps/users/cron.js

qa:
	yarn prettify && yarn check-types && yarn lint:fix

size-check:
	echo "Installing the production dependencies..."
	yarn install --production --frozen-lockfile --silent
	du -sh node_modules/* | sort -hr
	echo "Installing the development dependencies..."
	yarn install --frozen-lockfile --silent

reset-head:
	git checkout develop
	git fetch origin
	git reset --hard origin/develop

spell-check:
	./node_modules/cspell/bin.mjs ./apps/* ./packages/* --no-progress -u

================
File: package.json
================
{
  "name": "conduit",
  "version": "1.0.0",
  "private": true,
  "description": "Example Node (Express + Knex) codebase containing real world examples that adheres to the RealWorld API spec",
  "main": "index.js",
  "scripts": {
    "start": "turbo start",
    "start:ci": "turbo start:ci",
    "build": "turbo build",
    "test": "turbo test --parallel",
    "test:coverage": "turbo test:coverage --parallel",
    "check-types": "turbo check-types",
    "dev": "turbo dev --filter=@conduit/local",
    "deploy": "cd ./infra && yarn deploy",
    "clean": "./scripts/clean.sh",
    "merge-coverage": "istanbul-merge --out .nyc_output/coverage.json ./**/**/coverage/coverage-final.json && nyc report --reporter=lcov --reporter=text",
    "prettify": "turbo prettify",
    "lint": "turbo lint",
    "lint:fix": "turbo lint:fix",
    "db:migrate": "turbo db:migrate",
    "spell-check": "cspell \"**\" --no-progress"
  },
  "author": {
    "name": "Ken Yip",
    "email": "ken20206@gmail.com",
    "url": "https://kenyip.cc"
  },
  "license": "ISC",
  "packageManager": "yarn@1.22.19",
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "devDependencies": {
    "cspell": "^8.15.2",
    "istanbul-merge": "^2.0.0",
    "nyc": "^17.1.0",
    "turbo": "^2.2.3"
  }
}

================
File: packages/config/.eslintrc.json
================
{
  "extends": [
    "eslint:recommended",
    "eslint-config-airbnb-base",
    "airbnb-typescript",
    "plugin:@typescript-eslint/recommended",
    "prettier"
  ],
  "env": {
    "es2021": true,
    "node": true
  },
  "parser": "@typescript-eslint/parser",
  "plugins": ["@typescript-eslint", "prettier"],
  "rules": {
    "@typescript-eslint/no-unused-vars": "error",
    "import/prefer-default-export": "off",
    "no-tabs": ["off"],
    "max-len": ["off"],
    "no-await-in-loop": "off",
    "react/jsx-filename-extension": "off",
    "class-methods-use-this": "off",
    "no-param-reassign": "off",
    "@typescript-eslint/quotes": [
      "error",
      "single",
      {
        "avoidEscape": true
      }
    ],
    "@typescript-eslint/comma-dangle": ["error", "never"],
    "@typescript-eslint/no-namespace": "off",
    "@typescript-eslint/no-non-null-assertion": "off",
    "@typescript-eslint/no-use-before-define": "off",
    "@typescript-eslint/no-explicit-any": "off",
    "@typescript-eslint/lines-between-class-members": [
      "error",
      "always",
      {
        "exceptAfterSingleLine": true
      }
    ],
    "prettier/prettier": [
      "error",
      {
        "tabWidth": 2
      }
    ]
  },
  "overrides": [
    {
      "files": ["*.spec.{js,ts}"],
      "env": {
        "mocha": true,
        "node": true
      },
      "rules": {
        "no-unused-expressions": "off",
        "@typescript-eslint/no-unused-expressions": "off",
        "@typescript-eslint/no-throw-literal": "off"
      }
    }
  ],
  "parserOptions": {
    "project": "./tsconfig.base.json"
  },
  "ignorePatterns": ["dist", "node_modules", ".eslintrc.js", "jest.config.js"]
}

================
File: packages/config/.prettierrc.json
================
{
  "printWidth": 85,
  "tabWidth": 2,
  "useTabs": false,
  "semi": true,
  "singleQuote": true,
  "quoteProps": "as-needed",
  "jsxSingleQuote": false,
  "trailingComma": "none",
  "bracketSpacing": true,
  "jsxBracketSameLine": false,
  "arrowParens": "always",
  "proseWrap": "always",
  "plugins": [
    "prettier-plugin-packagejson",
    "@trivago/prettier-plugin-sort-imports"
  ],
  "importOrder": [
    "^dotenv/config$",
    "<THIRD_PARTY_MODULES>",
    "^@conduit/(.*)$",
    "^[./]"
  ],
  "importOrderSeparation": true,
  "importOrderSortSpecifiers": true,
  "importOrderCaseInsensitive": false
}

================
File: packages/config/jest.config.js
================
/** @type {import('jest').Config} */

const config = {
  preset: 'ts-jest',
  verbose: false,
  modulePathIgnorePatterns: ['<rootDir>/aws/scripts/', '<rootDir>/node_modules/'],
  testEnvironment: 'node'
};

module.exports = config;

================
File: packages/config/package.json
================
{
  "name": "@conduit/config",
  "version": "1.0.0",
  "private": true,
  "description": "The config module of this monorepository contains various configurations, including TypeScript, ESLint, Jest, and others.",
  "keywords": [
    "conduit",
    "config"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/kenyipp/realworld-nodejs-example-app/tree/master/packages/config"
  },
  "license": "MIT",
  "author": {
    "name": "Ken Yip",
    "email": "ken20206@gmail.com",
    "url": "https://kenyip.cc"
  },
  "scripts": {
    "prettify": "prettier --write ."
  },
  "devDependencies": {
    "@jest/types": "^29.6.3",
    "@trivago/prettier-plugin-sort-imports": "^4.3.0",
    "@typescript-eslint/eslint-plugin": "^5.30.7",
    "@typescript-eslint/parser": "^5.30.7",
    "eslint": "^8.19.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "eslint-config-airbnb-typescript": "^17.0.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-jest": "^26.5.3",
    "eslint-plugin-prettier": "^5.2.1",
    "prettier": "^3.3.3",
    "prettier-plugin-packagejson": "^2.5.3"
  }
}

================
File: packages/config/tsconfig.base.json
================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Default",
  "compilerOptions": {
    // Warn user if the code is provably unreachable due to the use of JavaScript syntax
    "allowUnreachableCode": false,
    // Ensures that your files are parsed in the ECMAScript strict mode, and emit ‚Äúuse strict‚Äù for each source file.
    "alwaysStrict": true,
    // With exactOptionalPropertyTypes enabled, TypeScript applies stricter rules around how it handles properties on type or interfaces which have a ? prefix.
    // "exactOptionalPropertyTypes": true,
    // Report errors for fallthrough cases in switch statements
    "noFallthroughCasesInSwitch": true,
    // TypeScript will issue an error whenever it would have inferred any
    "noImplicitAny": false,
    // Receive the error when override is missing
    "noImplicitOverride": false,
    // When enabled, TypeScript will check all code paths in a function to ensure they return a value.
    "noImplicitReturns": true,
    // Raise error on ‚Äòthis‚Äô expressions with an implied ‚Äòany‚Äô type.
    "noImplicitThis": true,
    // Raise an error because the unknown field uses dot syntax instead of indexed syntax
    "noPropertyAccessFromIndexSignature": false,
    // Add undefined to any un-declared field in the type
    "noUncheckedIndexedAccess": true,
    // Report errors on unused local variables
    // Disable on development
    "noUnusedLocals": false,
    // Disable because for express middleware function
    "noUnusedParameters": false,
    // When set, TypeScript will check that the built-in methods of functions call, bind, and apply
    // are invoked with correct argument for the underlying function
    "strictBindCallApply": true,
    // When enabled, this flag causes functions parameters to be checked more correctly.
    "strictFunctionTypes": true,
    // When strictNullChecks is true, null and undefined have their own distinct types
    // and you‚Äôll get a type error if you try to use them where a concrete value is expected.
    "strictNullChecks": true,
    // When set to true, TypeScript will raise an error when a class property was declared but not set in the constructor.
    // We should use "!" for property we have not declared
    "strictPropertyInitialization": false,
    // Set the type of error to unknown
    "useUnknownInCatchVariables": true,
    // Sets the module system for the program. See the Modules reference page for more information.
    // You very likely want "CommonJS" for node projects.
    "module": "CommonJS",
    // A series of entries which re-map imports to lookup locations relative to the baseUrl.
    "paths": {},
    // Allows importing modules with a ‚Äò.json‚Äô extension, which is a common practice in node projects.
    "resolveJsonModule": true,
    // Generate .d.ts files for every TypeScript or JavaScript file inside your project
    "declaration": false,
    // Offers a way to configure the root directory for where declaration files are emitted.
    // "declarationDir": "types"
    // Down leveling is TypeScript‚Äôs term for transpiling to an older version of JavaScript
    "downlevelIteration": true,
    // Only emit .d.ts files; do not emit .js files.
    "emitDeclarationOnly": false,
    // Helper functions are instead imported from the tslib module.
    "importHelpers": false,
    // Do not erase const enum declarations in generated code.
    "preserveConstEnums": true,
    // Enables the generation of sourcemap files.
    // These files allow debuggers and other tools to display the original TypeScript source code when actually working with the emitted JavaScript files.
    "sourceMap": true,
    // Do not emit declarations for code that has an @internal annotation in its JSDoc comment.
    "stripInternal": true,
    // Allow JavaScript files to be imported inside your project, instead of just .ts and .tsx files.
    "allowJs": true,
    // Allow import as default when the module does not explicitly specify a default export.
    "allowSyntheticDefaultImports": true,
    // Enables experimental support for emitting type metadata for decorators which works with the module reflect-metadata.
    "emitDecoratorMetadata": true,
    // Enables experimental support for decorators, which is in stage 2 of the TC39 standardization process.
    "experimentalDecorators": true,
    "lib": ["ES2022"],
    "generateCpuProfile": "profile.cpuprofile",
    "target": "ES2022",
    "moduleResolution": "node",
    "strict": true,
    "removeComments": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "exclude": [
    "node_modules",
    "build",
    ".next",
    "dist",
    "test.ts",
    "output",
    "coverage",
    "**/*.spec.ts",
    "jest.config.js"
  ]
}

================
File: packages/core/.eslintrc.js
================
const defaultConfig = require('@conduit/config/.eslintrc.json');

module.exports = {
  ...defaultConfig,
  parserOptions: {
    project: './tsconfig.json'
  },
  rules: {
    ...defaultConfig.rules,
    'import/no-extraneous-dependencies': 'off'
  }
};

================
File: packages/core/.prettierrc.cjs
================
module.exports = require('@conduit/config/.prettierrc.json');

================
File: packages/core/database/DbArticle/DbArticle.ts
================
import { groupBy, indexOf, sortBy } from 'lodash';

import { RecordStatus, UserStatus } from '@conduit/core/types';
import { getObjectId } from '@conduit/core/utils';

import { knex } from '../knex';
import {
  DbDtoArticle,
  DbDtoArticleComment,
  DbDtoArticleCommentWithProfile,
  DbDtoArticleTag
} from './dto';
import {
  CountArticleCommentsByArticleIdInput,
  CountArticleCommentsByArticleIdOutput,
  CountArticlesInput,
  CountArticlesOutput,
  CreateArticleCommentInput,
  CreateArticleCommentOutput,
  CreateArticleInput,
  CreateArticleOutput,
  CreateTagsForArticleInput,
  CreateTagsForArticleOutput,
  DeleteArticleByIdInput,
  DeleteArticleByIdOutput,
  DeleteArticleCommentByIdInput,
  DeleteArticleCommentByIdOutput,
  FavoriteArticleInput,
  FavoriteArticleOutput,
  GetArticleCommentsByArticleIdInput,
  GetArticleCommentsByArticleIdOutput,
  GetArticleCommentsByIdsInput,
  GetArticleCommentsByIdsOutput,
  GetArticleQueryByFiltersInput,
  GetArticleQueryByFiltersOutput,
  GetArticlesInput,
  GetArticlesOutput,
  GetAvailableTagsOutput,
  GetTagsByArticleIdsInput,
  GetTagsByArticleIdsOutput,
  UnfavoriteArticleInput,
  UnfavoriteArticleOutput,
  UpdateArticleByIdInput,
  UpdateArticleByIdOutput
} from './types';

export class DbArticle {
  async createArticle({
    title,
    slug,
    description,
    body,
    userId
  }: CreateArticleInput): CreateArticleOutput {
    const articleId = getObjectId();
    await knex
      .insert({
        article_id: articleId,
        slug,
        title,
        description,
        body,
        user_id: userId,
        created_at: new Date(),
        updated_at: new Date()
      })
      .into('article');
    return articleId;
  }

  async createTagsForArticle({
    articleId,
    tags
  }: CreateTagsForArticleInput): CreateTagsForArticleOutput {
    await knex
      .insert(
        tags.map((tag) => ({
          article_tag_id: getObjectId(),
          tag,
          article_id: articleId,
          record_status: RecordStatus.Active
        }))
      )
      .into('article_tag')
      .onConflict(['tag', 'article_id'])
      .merge(['record_status']);
  }

  async createArticleComment({
    articleId,
    body,
    userId
  }: CreateArticleCommentInput): CreateArticleCommentOutput {
    const commentId = getObjectId();
    await knex.table('article_comment').insert({
      article_comment_id: commentId,
      article_id: articleId,
      body,
      user_id: userId
    });
    return commentId;
  }

  async updateArticleById({
    id,
    title,
    slug,
    description,
    body
  }: UpdateArticleByIdInput): UpdateArticleByIdOutput {
    if (!title && !description && !body) {
      return;
    }
    // Create an empty object to store the updates
    const updates = {
      title,
      slug,
      description,
      body
    };
    // Update the article in the database with the new values
    await knex.table('article').update(updates).where('article_id', id);
  }

  async getArticles({
    ids,
    slugs,
    tags,
    author,
    favorited,
    followedBy,
    limit,
    offset,
    requestingUserId
  }: GetArticlesInput): GetArticlesOutput {
    let query = this.getArticleQueryByFilters({
      ids,
      slugs,
      tags,
      author,
      favorited,
      followedBy
    });
    if (limit !== undefined) {
      query = query.limit(limit);
    }
    if (offset !== undefined) {
      query = query.offset(offset * (limit ?? 1));
    }
    const articles = await query
      .select({
        id: 'article.article_id',
        title: 'article.title',
        slug: 'article.slug',
        description: 'article.description',
        body: 'article.body',
        userId: 'article.user_id',
        recordStatus: 'article.record_status',
        createdAt: 'article.created_at',
        updatedAt: 'article.updated_at',
        favoritesCount: knex
          .count('article_favorite_id')
          .from('article_favorite')
          .where('article_id', knex.raw('article.article_id'))
          .where('record_status', RecordStatus.Active),
        favorited: knex
          .count('article_favorite_id')
          .from('article_favorite')
          .where(function () {
            this.where('article_id', knex.raw('article.article_id'));
            this.where('record_status', RecordStatus.Active);
            if (requestingUserId) {
              this.where('user_id', knex.raw('?', [requestingUserId]));
            }
          }),
        authorId: 'article.user_id',
        authorUsername: 'user.username',
        authorBio: 'user.bio',
        authorImage: 'user.image',
        isFollowing: knex.raw(
          '(CASE WHEN user_follow_id IS NULL THEN FALSE ELSE TRUE END)'
        )
      })
      .leftJoin('user', 'article.user_id', 'user.user_id')
      .leftJoin('user_follow', function () {
        this.on('user_follow.following_id', '=', 'user.user_id');
        this.on(
          'user_follow.record_status',
          '=',
          knex.raw('?', [RecordStatus.Active])
        );
        if (requestingUserId) {
          this.andOn(
            'user_follow.follower_id',
            '=',
            knex.raw('?', [requestingUserId])
          );
        }
      })
      .then((rows) =>
        rows.map((row) => {
          const {
            id,
            title,
            slug,
            description,
            body,
            userId,
            recordStatus,
            createdAt,
            updatedAt,
            favoritesCount,
            favorited: isFavorited,
            authorId,
            authorUsername,
            authorBio,
            authorImage,
            isFollowing
          } = row;
          return new DbDtoArticle({
            id,
            title,
            slug,
            description,
            body,
            userId,
            recordStatus,
            createdAt,
            updatedAt,
            favoritesCount,
            favorited: isFavorited > 0,
            author: {
              id: authorId,
              username: authorUsername,
              bio: authorBio,
              image: authorImage,
              following: isFollowing
            }
          });
        })
      );
    return articles;
  }

  async getArticleCommentsByArticleId({
    articleId,
    limit,
    offset,
    requestingUserId
  }: GetArticleCommentsByArticleIdInput): GetArticleCommentsByArticleIdOutput {
    const query = knex
      .select({
        id: 'article_comment.article_comment_id',
        body: 'article_comment.body',
        createdAt: 'article_comment.created_at',
        updatedAt: 'article_comment.updated_at',
        authorId: 'article_comment.user_id',
        authorUsername: 'user.username',
        authorBio: 'user.bio',
        authorImage: 'user.image',
        isFollowing: knex.raw(
          '(CASE WHEN user_follow_id IS NULL THEN FALSE ELSE TRUE END)'
        )
      })
      .from('article_comment')
      .leftJoin('user', 'article_comment.user_id', 'user.user_id')
      // eslint-disable-next-line func-names
      .leftJoin('user_follow', function () {
        this.on('user_follow.following_id', '=', 'user.user_id');
        if (requestingUserId) {
          this.andOn(
            'user_follow.follower_id',
            '=',
            knex.raw('?', [requestingUserId])
          );
        }
      })
      .where('article_comment.article_id', articleId)
      .where('article_comment.record_status', RecordStatus.Active)
      .orderBy('article_comment.created_at', 'asc')
      .limit(limit)
      .offset(offset * limit);
    const comments = await query.then((rows) =>
      rows.map((row) => {
        const {
          id,
          body,
          createdAt,
          updatedAt,
          authorId,
          authorUsername,
          authorBio,
          authorImage,
          isFollowing
        } = row;

        const author = {
          id: authorId,
          username: authorUsername,
          bio: authorBio,
          image: authorImage,
          following: isFollowing
        };
        return new DbDtoArticleCommentWithProfile({
          id,
          body,
          createdAt,
          updatedAt,
          author
        });
      })
    );
    return comments;
  }

  async countArticleCommentsByArticleId({
    articleId
  }: CountArticleCommentsByArticleIdInput): CountArticleCommentsByArticleIdOutput {
    const count = await knex
      .table('article_comment')
      .count<{ count: number }[]>('*', { as: 'count' })
      .where('article_id', articleId)
      .where('record_status', RecordStatus.Active)
      .then((response) => response[0]?.count ?? 0);
    return count;
  }

  async getTagsByArticleIds({
    articleIds
  }: GetTagsByArticleIdsInput): GetTagsByArticleIdsOutput {
    if (articleIds.length < 1) {
      return {};
    }
    const tags = await knex
      .select({
        id: 'article_tag.article_tag_id',
        articleId: 'article_tag.article_id',
        tag: 'article_tag.tag',
        recordStatus: 'article_tag.record_status',
        createdAt: 'article_tag.created_at',
        updatedAt: 'article_tag.updated_at'
      })
      .from('article_tag')
      .whereIn('article_id', articleIds)
      .where('record_status', RecordStatus.Active)
      .then((rows) => rows.map((row) => new DbDtoArticleTag(row)));
    const result = groupBy(tags, 'articleId');
    return result;
  }

  async countArticles(filters: CountArticlesInput): CountArticlesOutput {
    const count = await this.getArticleQueryByFilters(filters)
      .count<{ count: number }[]>('*', { as: 'count' })
      .then((response) => response[0]?.count ?? 0);
    return count;
  }

  async deleteArticleById({ id }: DeleteArticleByIdInput): DeleteArticleByIdOutput {
    await knex
      .table('article')
      .update({ record_status: RecordStatus.Deleted })
      .where('article_id', id);
  }

  async deleteArticleCommentById({
    id
  }: DeleteArticleCommentByIdInput): DeleteArticleCommentByIdOutput {
    await knex
      .table('article_comment')
      .update({ record_status: RecordStatus.Deleted })
      .where('article_comment_id', id);
  }

  private getArticleQueryByFilters({
    ids,
    slugs,
    tags,
    author,
    favorited,
    followedBy
  }: GetArticleQueryByFiltersInput): GetArticleQueryByFiltersOutput {
    let query = knex
      .table('article')
      .where('article.record_status', RecordStatus.Active); // Retrieve only active articles

    if (ids) {
      query = query.whereIn('article.article_id', ids);
    }

    if (slugs) {
      query = query.whereIn('article.slug', slugs);
    }

    if (tags && tags.length > 0) {
      query = query.whereIn(
        'article.article_id',
        knex
          .select('article_id')
          .from('article_tag')
          .whereIn('tag', tags)
          .where('record_status', RecordStatus.Active)
      );
    }

    if (author) {
      query = query.whereIn(
        'article.user_id',
        knex
          .select('user_id')
          .from('user')
          .where('username', author)
          .where('record_status', UserStatus.Active)
      );
    }

    if (favorited) {
      query = query.whereIn(
        'article.article_id',
        knex
          .select('article_id')
          .from('article_favorite')
          .where('record_status', RecordStatus.Active)
          .whereIn(
            'user_id',
            knex
              .select('user_id')
              .from('user')
              .where('username', favorited)
              .where('record_status', UserStatus.Active)
          )
      );
    }

    if (followedBy) {
      query = query.whereIn(
        'article.user_id',
        knex
          .select('following_id')
          .from('user_follow')
          .where('follower_id', followedBy)
          .where('record_status', RecordStatus.Active)
      );
    }

    return query;
  }

  async getAvailableTags(): GetAvailableTagsOutput {
    const tags = await knex
      .distinct<{ tag: string }[]>('tag')
      .from('article_tag')
      .whereIn(
        'article_id',
        knex
          .select('article_id')
          .from('article')
          .where('record_status', RecordStatus.Active)
      )
      .then((rows) => rows.map((row) => row.tag));
    return tags;
  }

  async getArticleCommentsByIds({
    ids,
    requestingUserId
  }: GetArticleCommentsByIdsInput): GetArticleCommentsByIdsOutput {
    const comments = await knex
      .select({
        id: 'article_comment.article_comment_id',
        body: 'article_comment.body',
        userId: 'article_comment.user_id',
        userName: 'user.username',
        userBio: 'user.bio',
        userImage: 'user.image',
        isFollowing: knex.raw(
          '(CASE WHEN user_follow_id IS NULL THEN FALSE ELSE TRUE END)'
        ),
        recordStatus: 'article_comment.record_status',
        createdAt: 'article_comment.created_at',
        updatedAt: 'article_comment.updated_at'
      })
      .from('article_comment')
      .leftJoin('user', 'article_comment.user_id', 'user.user_id')
      .leftJoin('user_follow', function () {
        this.on('user_follow.following_id', '=', 'user.user_id');
        if (requestingUserId) {
          this.andOn('user_follow.follower_id', '=', requestingUserId);
        }
      })
      .where('article_comment.record_status', RecordStatus.Active)
      .whereIn('article_comment_id', ids)
      .then((rows) => rows.map((row) => new DbDtoArticleComment(row as any)));
    return sortBy(comments, (comment) => indexOf(ids, comment.id));
  }

  /**
   *
   *
   * Feature: Favorite Articles
   *
   */

  async favoriteArticle({
    articleId,
    userId
  }: FavoriteArticleInput): FavoriteArticleOutput {
    const id = getObjectId();
    await knex
      .insert({
        article_favorite_id: id,
        user_id: userId,
        article_id: articleId
      })
      .into('article_favorite')
      .onConflict(['user_id', 'article_id'])
      .merge(['record_status']);
  }

  async unfavoriteArticle({
    articleId,
    userId
  }: UnfavoriteArticleInput): UnfavoriteArticleOutput {
    await knex
      .table('article_favorite')
      .update({ record_status: RecordStatus.Deleted })
      .where('user_id', userId)
      .where('article_id', articleId);
  }
}

================
File: packages/core/database/DbArticle/dto/DbDtoArticle.ts
================
import { DbDtoProfile } from '@conduit/core/database';
import { RecordStatus } from '@conduit/core/types';

export class DbDtoArticle {
  id: string;
  title: string;
  slug: string;
  description: string;
  body: string;
  userId: string;
  recordStatus: RecordStatus;
  createdAt: Date;
  favoritesCount: number;
  favorited: boolean;
  updatedAt: Date;
  author: DbDtoProfile;

  constructor({
    id,
    title,
    slug,
    description,
    body,
    userId,
    recordStatus,
    favoritesCount,
    favorited,
    createdAt,
    updatedAt,
    author
  }: DbDtoArticleConstructor) {
    this.id = id;
    this.title = title;
    this.slug = slug;
    this.description = description;
    this.body = body;
    this.userId = userId;
    this.recordStatus = recordStatus;
    this.favoritesCount = favoritesCount;
    this.favorited = favorited || false;
    this.author = new DbDtoProfile({
      id: author.id,
      username: author.username,
      bio: author.bio,
      image: author.image,
      following: author.following
    });
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
}

interface DbDtoArticleConstructor {
  id: string;
  title: string;
  slug: string;
  description: string;
  body: string;
  userId: string;
  recordStatus: RecordStatus;
  favoritesCount: number;
  favorited?: boolean;
  createdAt: Date;
  updatedAt: Date;
  author: {
    id: string;
    username: string;
    bio?: string;
    image?: string;
    following: boolean;
  };
}

================
File: packages/core/database/DbArticle/dto/DbDtoArticleComment.ts
================
import { RecordStatus } from '@conduit/core/types';

export class DbDtoArticleComment {
  id: string;
  body: string;
  author: {
    id: string;
    username: string;
    bio?: string;
    image?: string;
    following: boolean;
  };

  recordStatus: RecordStatus;
  createdAt: Date;
  updatedAt: Date;

  constructor({
    id,
    body,
    userId,
    userName,
    userBio,
    userImage,
    isFollowing,
    recordStatus,
    createdAt,
    updatedAt
  }: DbDtoArticleCommentConstructor) {
    this.id = id;
    this.body = body;
    this.author = {
      id: userId,
      username: userName,
      bio: userBio,
      image: userImage,
      following: isFollowing
    };
    this.recordStatus = recordStatus;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
}

interface DbDtoArticleCommentConstructor {
  id: string;
  body: string;
  userId: string;
  userName: string;
  userBio?: string;
  userImage?: string;
  isFollowing: boolean;
  recordStatus: RecordStatus;
  createdAt: Date;
  updatedAt: Date;
}

================
File: packages/core/database/DbArticle/dto/DbDtoArticleCommentWithProfile.ts
================
import { DbDtoProfile } from '@conduit/core/database';

export class DbDtoArticleCommentWithProfile {
  id: string;
  createdAt: Date;
  updatedAt: Date;
  body: string;
  author: DbDtoProfile;

  constructor({
    id,
    createdAt,
    updatedAt,
    body,
    author
  }: DbDtoArticleCommentWithProfileConstructor) {
    this.id = id;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.body = body;
    this.author = new DbDtoProfile(author);
  }
}

interface DbDtoArticleCommentWithProfileConstructor {
  id: string;
  createdAt: Date;
  updatedAt: Date;
  body: string;
  author: {
    id: string;
    username: string;
    bio?: string;
    image?: string;
    following: boolean;
  };
}

================
File: packages/core/database/DbArticle/dto/DbDtoArticleTag.ts
================
import { RecordStatus } from '@conduit/core/types';

export class DbDtoArticleTag {
  id: string;
  articleId: string;
  tag: string;
  recordStatus: RecordStatus;
  createdAt: Date;
  updatedAt: Date;

  constructor({
    id,
    articleId,
    tag,
    recordStatus,
    createdAt,
    updatedAt
  }: DbDtoArticleTagConstructor) {
    this.id = id;
    this.articleId = articleId;
    this.tag = tag;
    this.recordStatus = recordStatus;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
}

interface DbDtoArticleTagConstructor {
  id: string;
  articleId: string;
  tag: string;
  recordStatus: RecordStatus;
  createdAt: Date;
  updatedAt: Date;
}

================
File: packages/core/database/DbArticle/dto/index.ts
================
export * from './DbDtoArticle';
export * from './DbDtoArticleComment';
export * from './DbDtoArticleTag';
export * from './DbDtoArticleCommentWithProfile';

================
File: packages/core/database/DbArticle/index.ts
================
export { DbArticle } from './DbArticle';
export * from './dto';

================
File: packages/core/database/DbArticle/types.ts
================
import { Knex } from 'knex';
import { Dictionary } from 'lodash';

import {
  DbDtoArticle,
  DbDtoArticleComment,
  DbDtoArticleCommentWithProfile,
  DbDtoArticleTag
} from './dto';

/**
 *
 * function: createArticle
 *
 */
export interface CreateArticleInput {
  title: string;
  slug: string;
  description: string;
  body: string;
  userId: string;
}

export type CreateArticleOutput = Promise<string>;

/**
 *
 * function: createTagsForArticle
 *
 */
export interface CreateTagsForArticleInput {
  articleId: string;
  tags: string[];
}

export type CreateTagsForArticleOutput = Promise<void>;

/**
 *
 * function: getTagsByArticleIds
 *
 */
export interface GetTagsByArticleIdsInput {
  articleIds: string[];
}

export type GetTagsByArticleIdsOutput = Promise<Dictionary<DbDtoArticleTag[]>>;

/**
 *
 * function: updateArticleById
 *
 */
export interface UpdateArticleByIdInput {
  id: string;
  title?: string;
  slug?: string;
  description?: string;
  body?: string;
}

export type UpdateArticleByIdOutput = Promise<void>;

/**
 *
 * function: getArticles
 *
 */
export interface ArticleFilters {
  ids?: string[];
  slugs?: string[];
  tags?: string[];
  author?: string;
  favorited?: string;
  followedBy?: string;
  requestingUserId?: string;
}

export type GetArticlesInput = ArticleFilters & {
  limit?: number;
  offset?: number;
};

export type GetArticlesOutput = Promise<DbDtoArticle[]>;

/**
 *
 * function: countArticles
 *
 */
export type CountArticlesInput = ArticleFilters;

export type CountArticlesOutput = Promise<number>;

/**
 *
 * function: deleteArticleById
 *
 */
export interface DeleteArticleByIdInput {
  id: string;
}

export type DeleteArticleByIdOutput = Promise<void>;

/**
 *
 * function: createArticleComment
 *
 */
export interface CreateArticleCommentInput {
  articleId: string;
  userId: string;
  body: string;
}

export type CreateArticleCommentOutput = Promise<string>;

/**
 *
 * function: getArticleQueryByFilters
 *
 */
export type GetArticleQueryByFiltersInput = ArticleFilters;

export type GetArticleQueryByFiltersOutput = Knex.QueryBuilder;

/**
 *
 * function: deleteArticleCommentById
 *
 */
export interface DeleteArticleCommentByIdInput {
  id: string;
}

export type DeleteArticleCommentByIdOutput = Promise<void>;

/**
 *
 * function: getAvailableTags
 *
 */
export type GetAvailableTagsOutput = Promise<string[]>;

/**
 *
 * function: getArticleCommentsByArticleId
 *
 */
export interface GetArticleCommentsByArticleIdInput {
  articleId: string;
  limit: number;
  offset: number;
  requestingUserId?: string;
}

export type GetArticleCommentsByArticleIdOutput = Promise<
  DbDtoArticleCommentWithProfile[]
>;

/**
 *
 * function: countArticleCommentsByArticleId
 *
 */
export interface CountArticleCommentsByArticleIdInput {
  articleId: string;
}

export type CountArticleCommentsByArticleIdOutput = Promise<number>;

/**
 *
 * function: getArticleCommentsByIds
 *
 */
export interface GetArticleCommentsByIdsInput {
  ids: string[];
  requestingUserId?: string;
}

export type GetArticleCommentsByIdsOutput = Promise<DbDtoArticleComment[]>;

/**
 *
 * function: favoriteArticle
 *
 */
export interface FavoriteArticleInput {
  articleId: string;
  userId: string;
}

export type FavoriteArticleOutput = Promise<void>;

/**
 *
 * function: unfavoriteArticle
 *
 */
export interface UnfavoriteArticleInput {
  articleId: string;
  userId: string;
}

export type UnfavoriteArticleOutput = Promise<void>;

================
File: packages/core/database/DbFactory.ts
================
import { DbArticle } from './DbArticle';
import { DbUser } from './DbUser';

/**
 *
 * A factory for creating new instances of database entities.
 *
 */
export class DbFactory {
  newDbUser(): DbUser {
    const dbUser = new DbUser();
    return dbUser;
  }

  newDbArticle(): DbArticle {
    const dbArticle = new DbArticle();
    return dbArticle;
  }
}

================
File: packages/core/database/DbUser/DbUser.ts
================
import { isUndefined } from 'lodash';

import { RecordStatus } from '../../types';
import { getObjectId } from '../../utils';
import { knex } from '../knex';
import { DbDtoProfile, DbDtoUser } from './dto';
import {
  CreateUserInput,
  CreateUserOutput,
  FollowUserInput,
  FollowUserOutput,
  GetIsUserExistsInput,
  GetIsUserExistsOutput,
  GetUserProfilesInput,
  GetUserProfilesOutput,
  GetUsersInput,
  GetUsersOutput,
  UnfollowUserInput,
  UnfollowUserOutput,
  UpdateUserByIdInput,
  UpdateUserByIdOutput
} from './types';

export class DbUser {
  async createUser({
    username,
    email,
    bio,
    image,
    hash
  }: CreateUserInput): CreateUserOutput {
    const userId = getObjectId();
    await knex
      .insert({
        user_id: userId,
        username,
        email,
        bio,
        image,
        hash
      })
      .into('user');
    return userId;
  }

  async updateUser({
    id,
    email,
    username,
    hash,
    image,
    bio
  }: UpdateUserByIdInput): UpdateUserByIdOutput {
    if (!email && !username && !hash && !image && !bio) {
      return;
    }
    const updates = {
      email,
      username,
      hash,
      image,
      bio
    };
    await knex.table('user').update(updates).where('user_id', id);
  }

  async getIsUserExists({
    userId,
    email,
    username
  }: GetIsUserExistsInput): GetIsUserExistsOutput {
    const rows = await knex
      .select({
        id: 'user_id',
        email: 'email',
        username: 'username'
      })
      .where(function () {
        this.where(function () {
          this.where('email', email).orWhere('username', username);
        });
        if (userId) {
          this.andWhere('user_id', '<>', knex.raw('?', [userId]));
        }
      })
      .from('user');
    const emailExists = rows.some((row) => row.email === email);
    const usernameExists = rows.some((row) => row.username === username);
    return {
      exists: emailExists || usernameExists,
      emailExists,
      usernameExists
    };
  }

  async getUsers({ ids, emails, usernames }: GetUsersInput): GetUsersOutput {
    // Return empty array if all ids, emails, and usernames are undefined
    if (!ids?.length && !emails?.length && !usernames?.length) {
      return [];
    }
    const query = knex
      .select({
        id: 'user_id',
        email: 'email',
        username: 'username',
        bio: 'bio',
        image: 'image',
        hash: 'hash',
        recordStatus: 'record_status',
        createdAt: 'created_at',
        updatedAt: 'updated_at'
      })
      .from('user');
    if (!isUndefined(ids)) {
      query.whereIn('user_id', ids);
    }
    if (!isUndefined(emails)) {
      query.whereIn('email', emails);
    }
    if (!isUndefined(usernames)) {
      query.whereIn('username', usernames);
    }
    return query.then((rows) => rows.map((row) => new DbDtoUser(row)));
  }

  async followUser({ followerId, followingId }: FollowUserInput): FollowUserOutput {
    await knex
      .insert({
        user_follow_id: getObjectId(),
        follower_id: followerId,
        following_id: followingId
      })
      .into('user_follow');
  }

  async unfollowUser({
    followerId,
    followingId
  }: UnfollowUserInput): UnfollowUserOutput {
    await knex
      .update({ record_status: RecordStatus.Deleted })
      .from('user_follow')
      .where('follower_id', followerId)
      .where('following_id', followingId);
  }

  async getUserProfiles({
    usernames,
    requestingUserId
  }: GetUserProfilesInput): GetUserProfilesOutput {
    const profiles = await knex
      .select({
        id: 'user_id',
        username: 'username',
        bio: 'bio',
        image: 'image',
        following: knex.raw(
          '(CASE WHEN user_follow_id IS NULL THEN FALSE ELSE TRUE END)'
        )
      })
      .from('user')
      // eslint-disable-next-line func-names
      .leftJoin('user_follow', function () {
        this.on('user_follow.following_id', '=', 'user.user_id');
        this.on(
          'user_follow.record_status',
          '=',
          knex.raw('?', [RecordStatus.Active])
        );
        if (requestingUserId) {
          this.andOn(
            'user_follow.follower_id',
            '=',
            knex.raw('?', [requestingUserId])
          );
        }
      })
      .whereIn('user.username', usernames)
      .then((docs) => docs.map((doc) => new DbDtoProfile(doc)));
    return profiles;
  }
}

================
File: packages/core/database/DbUser/dto/DbDtoProfile.ts
================
export class DbDtoProfile {
  id: string;
  username: string;
  bio?: string;
  image?: string;
  following: boolean;

  constructor({ id, username, bio, image, following }: DbDtoProfileConstructor) {
    this.id = id;
    this.username = username;
    this.bio = bio;
    this.image = image;
    this.following = typeof following === 'number' ? following > 0 : following;
  }
}

export interface DbDtoProfileConstructor {
  id: string;
  username: string;
  bio?: string;
  image?: string;
  following: boolean | number;
}

================
File: packages/core/database/DbUser/dto/DbDtoUser.ts
================
import { UserStatus } from '@conduit/core/types';

export class DbDtoUser {
  id: string;
  username: string;
  email: string;
  bio?: string;
  image?: string;
  hash: string;
  recordStatus: UserStatus;
  createdAt: Date;
  updatedAt: Date;

  constructor({
    id,
    username,
    email,
    bio,
    image,
    hash,
    recordStatus,
    createdAt,
    updatedAt
  }: DbDtoUserConstructor) {
    this.id = id;
    this.username = username;
    this.email = email;
    this.bio = bio;
    this.image = image;
    this.hash = hash;
    this.recordStatus = recordStatus;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
}

interface DbDtoUserConstructor {
  id: string;
  username: string;
  email: string;
  bio?: string;
  image?: string;
  hash: string;
  recordStatus: UserStatus;
  createdAt: Date;
  updatedAt: Date;
}

================
File: packages/core/database/DbUser/dto/index.ts
================
export * from './DbDtoProfile';
export * from './DbDtoUser';

================
File: packages/core/database/DbUser/index.ts
================
export { DbUser } from './DbUser';
export * from './dto';

================
File: packages/core/database/DbUser/types.ts
================
import { DbDtoProfile, DbDtoUser } from './dto';

/**
 *
 * function: createUser
 *
 */
export interface CreateUserInput {
  username: string;
  email: string;
  bio?: string;
  image?: string;
  hash: string;
}

export type CreateUserOutput = Promise<string>;

/**
 *
 * function: getIsUserExists
 *
 */
export interface GetIsUserExistsInput {
  userId?: string;
  email: string;
  username: string;
}

export type GetIsUserExistsOutput = Promise<{
  exists: boolean;
  emailExists: boolean;
  usernameExists: boolean;
}>;

/**
 *
 * function: getUsers
 *
 */
export interface GetUsersInput {
  ids?: string[];
  emails?: string[];
  usernames?: string[];
}

export type GetUsersOutput = Promise<DbDtoUser[]>;

/**
 *
 * function: updateUserById
 *
 */
export interface UpdateUserByIdInput {
  id: string;
  email?: string;
  username?: string;
  hash?: string;
  image?: string;
  bio?: string;
}

export type UpdateUserByIdOutput = Promise<void>;

/**
 *
 * function: followUser
 *
 */
export interface FollowUserInput {
  followerId: string;
  followingId: string;
}

export type FollowUserOutput = Promise<void>;

/**
 *
 * function: unfollowUser
 *
 */
export interface UnfollowUserInput {
  followerId: string;
  followingId: string;
}

export type UnfollowUserOutput = Promise<void>;

/**
 *
 * function: getUserProfiles
 *
 */
export interface GetUserProfilesInput {
  usernames: string[];
  requestingUserId?: string;
}

export type GetUserProfilesOutput = Promise<DbDtoProfile[]>;

================
File: packages/core/database/Dockerfile
================
FROM node:18

# Set working directory
WORKDIR /app
RUN yarn global add turbo

COPY . .

RUN yarn install

================
File: packages/core/database/index.ts
================
export { DbFactory } from './DbFactory';
export * from './DbUser';
export * from './DbArticle';
export { dangerouslyResetDb } from './knex';

================
File: packages/core/database/knex/index.ts
================
export * from './knex';

================
File: packages/core/database/knex/knex.ts
================
import Knex from 'knex';

import { NodeEnv } from '@conduit/types';
import { config } from '@conduit/utils';

import { knexConfig as KnexConfig } from './knexfile';

const knexConfig = KnexConfig[config.nodeEnv ?? NodeEnv.Test];

if (!knexConfig) {
  throw new Error(`Invalid node environment - ${config.nodeEnv}`);
}

export const knex = Knex(knexConfig);

export const dangerouslyResetDb = async () => {
  if (config.nodeEnv !== NodeEnv.Test && config.nodeEnv !== NodeEnv.CI) {
    throw new Error(
      `This function should only be called in the test or CI environment (current: ${config.nodeEnv})`
    );
  }
  await knex.migrate.rollback(undefined, true);
  await knex.migrate.latest();
  await knex.seed.run();
};

================
File: packages/core/database/knex/knexfile.ts
================
import 'dotenv/config';

import path from 'path';

import { config } from '@conduit/utils';

import { KnexConfig } from './types';

export const knexConfig: KnexConfig = {
  test: {
    client: 'better-sqlite3',
    connection: {
      filename: ':memory:'
    },
    useNullAsDefault: true,
    migrations: {
      directory: path.join(__dirname, './migrations')
    },
    seeds: {
      directory: path.join(__dirname, './seeds')
    }
  },
  ci: {
    client: 'mysql2',
    connection: config.database.conduit
  },
  develop: {
    client: 'mysql2',
    connection: config.database.conduit
  },
  prod: {
    client: 'mysql2',
    connection: config.database.conduit
  }
};

export default knexConfig;

================
File: packages/core/database/knex/migrations/0001_create-user-table.ts
================
import { type Knex } from 'knex';

export async function up(knex: Knex): Promise<void> {
  return knex.schema.createTable('user', (table) => {
    table.string('user_id', 64).primary();
    table.string('username', 64).unique().notNullable();
    table.string('email', 250).unique().notNullable();
    table.text('bio');
    table.text('image');
    table.string('hash', 64).notNullable();
    table
      .enum('record_status', ['active', 'banned'])
      .notNullable()
      .defaultTo('active');
    table.timestamps(true, true);
  });
}

export async function down(knex: Knex): Promise<void> {
  await knex.schema.dropTable('user');
}

================
File: packages/core/database/knex/migrations/0002_create-task-table.ts
================
import { type Knex } from 'knex';

export async function up(knex: Knex): Promise<void> {
  return knex.schema.createTable('task', (table) => {
    table
      .string('agent_id', 64)
      .comment(
        'The ID of the user who triggered the activity exists only if the process was triggered via the admin portal.'
      );
    table
      .integer('progress')
      .comment(
        'The progress of the activity processing. It may not be available for all types of activities.'
      );
    table.string('message').comment('The message returned by the task processing.');
    table
      .string('failed_reason')
      .comment(
        'The reason for the task processing failure. It is empty if the task was successful.'
      );
    table.text('return_data').comment('The data returned by the task processing.');
    table
      .timestamp('processed_at')
      .nullable()
      .comment('The date and time when the activity was processed.');
    table
      .timestamp('finished_at')
      .nullable()
      .comment(
        'The date and time when the activity was finished. No matter if it was successful or failed.'
      );
    table
      .string('type')
      .notNullable()
      .index()
      .comment('The type of activity that was triggered.');
    table
      .json('payload')
      .comment(
        'The request payload of the activity can vary depending on the activity type.'
      );
    table
      .string('process_status')
      .notNullable()
      .defaultTo('pending')
      .index()
      .comment('The status of the activity processing.');
    table
      .string('record_status')
      .notNullable()
      .defaultTo('active')
      .comment('The status of the record.')
      .index();
    // Add timestamps for created_at and updated_at
    table.timestamps(true, true);
  });
}

export async function down(knex: Knex): Promise<void> {
  return knex.schema.dropTable('task');
}

================
File: packages/core/database/knex/migrations/0003_create-user-follow-table.ts
================
import { type Knex } from 'knex';

export async function up(knex: Knex): Promise<void> {
  return knex.schema.createTable('user_follow', (table) => {
    table
      .string('user_follow_id', 64)
      .comment('Unique identifier for each following record')
      .primary();
    table.string('follower_id', 64).comment('ID of the user who is following');
    table.string('following_id', 64).comment('ID of the user who is being followed');
    table.string('record_status', 10).defaultTo('active');
    table.timestamps(true, true);
    table.unique(['follower_id', 'following_id'], {
      indexName: 'UX-user_following-follower_id-following_id'
    });
  });
}

export async function down(knex: Knex): Promise<void> {
  await knex.schema.dropTable('user_follow');
}

================
File: packages/core/database/knex/migrations/0004_create-article-table.ts
================
import { type Knex } from 'knex';

export async function up(knex: Knex): Promise<void> {
  return knex.schema.createTable('article', (table) => {
    table.string('article_id', 64).primary();
    table.string('title', 120);
    table.string('slug', 120).unique().index('UX-article-slug');
    table.string('description', 250);
    table.text('body');
    table
      .string('user_id', 64)
      .references('user_id')
      .inTable('user')
      .index('FK-article-user_id-user-user_id');
    table.string('record_status', 10).defaultTo('active');
    table.timestamps(true, true);
  });
}

export async function down(knex: Knex): Promise<void> {
  await knex.schema.dropTable('article');
}

================
File: packages/core/database/knex/migrations/0005_create-article-comment-table.ts
================
import { type Knex } from 'knex';

export async function up(knex: Knex): Promise<void> {
  return knex.schema.createTable('article_comment', (table) => {
    table.string('article_comment_id', 64).primary();
    table
      .string('article_id', 64)
      .references('article_id')
      .inTable('article')
      .index('FK-article_comment-article_id-article-article_id');
    table.text('body');
    table
      .string('user_id', 64)
      .references('user_id')
      .inTable('user')
      .index('FK-article_comment-user_id-user-user_id');
    table.string('record_status', 10).defaultTo('active');
    table.timestamps(true, true);
  });
}

export async function down(knex: Knex): Promise<void> {
  await knex.schema.dropTable('article_comment');
}

================
File: packages/core/database/knex/migrations/0006_create-article-favorite-table.ts
================
import { type Knex } from 'knex';

export async function up(knex: Knex): Promise<void> {
  return knex.schema.createTable('article_favorite', (table) => {
    table.string('article_favorite_id', 64).primary();
    table
      .string('user_id', 64)
      .references('user_id')
      .inTable('user')
      .index('FK-article_favorite-user_id-user-user_id');
    table
      .string('article_id', 64)
      .references('article_id')
      .inTable('article')
      .index('FK-article_favorite-article_id-article-article_id');
    table.string('record_status', 10).defaultTo('active');
    table.timestamps(true, true);
    table.unique(['user_id', 'article_id'], {
      indexName: 'UX-article_favorite-user_id-article_id'
    });
  });
}

export async function down(knex: Knex): Promise<void> {
  await knex.schema.dropTable('article_favorite');
}

================
File: packages/core/database/knex/migrations/0007_create-article-tag-table.ts
================
import { type Knex } from 'knex';

export async function up(knex: Knex): Promise<void> {
  return knex.schema.createTable('article_tag', (table) => {
    table.string('article_tag_id', 64).primary();
    table.string('article_id', 64);
    table.string('tag', 150).index('IX-article_tag_tag');
    table.string('record_status', 10).defaultTo('active');
    table.timestamps(true, true);

    table.unique(['article_id', 'tag']);
  });
}

export async function down(knex: Knex): Promise<void> {
  await knex.schema.dropTable('article_tag');
}

================
File: packages/core/database/knex/types.ts
================
import type { Knex } from 'knex';

export type KnexConfig = Record<string, Knex.Config>;

================
File: packages/core/index.ts
================
export * from './service';
export * from './utils';
export * from './types';
export * from './database';

================
File: packages/core/jest.config.js
================
/** @type {import('jest').Config} */

module.exports = require('@conduit/config/jest.config');

================
File: packages/core/package.json
================
{
  "name": "@conduit/core",
  "version": "1.0.0",
  "private": true,
  "description": "The core module of this project encapsulates the main business logic and is reusable across multiple applications",
  "keywords": [
    "conduit",
    "core"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/kenyipp/realworld-nodejs-example-app/tree/master/packages/core"
  },
  "license": "MIT",
  "author": {
    "name": "Ken Yip",
    "email": "ken20206@gmail.com",
    "url": "https://kenyip.cc"
  },
  "scripts": {
    "build": "tsc && tsc-alias",
    "check-types": "tsc --skipLibCheck --noEmit",
    "db:migrate": "NODE_CONFIG_DIR='../../../../config' knex migrate:latest --knexfile ./database/knex/knexfile",
    "dev": "NODE_ENV=dev ts-node-dev -r tsconfig-paths/register --no-deprecation --no-notify --exit-child --respawn --transpile-only --ignore-watch node_modules ./test.ts",
    "lint": "eslint .",
    "lint:fix": "eslint --fix .",
    "prettify": "prettier --write .",
    "test": "NODE_CONFIG_DIR='../../config' NODE_ENV=test jest tests/** --forceExit --maxWorkers=4 --detectOpenHandles",
    "test:coverage": "yarn test --coverage"
  },
  "dependencies": {
    "@conduit/config": "*",
    "@conduit/types": "*",
    "@conduit/utils": "*",
    "bcryptjs": "^2.4.3",
    "dotenv": "^16.4.5",
    "fast-json-stable-stringify": "^2.1.0",
    "jsonwebtoken": "^9.0.2",
    "knex": "^3.1.0",
    "lodash": "^4.17.21",
    "md5": "^2.3.0",
    "moment": "^2.30.1",
    "mysql2": "^3.11.3",
    "serialize-error": "8.1.0",
    "slugify": "^1.6.6",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "@jest/types": "^29.6.3",
    "@trivago/prettier-plugin-sort-imports": "^4.3.0",
    "@types/bcryptjs": "^2.4.6",
    "@types/chance": "^1.1.6",
    "@types/jest": "^29.5.13",
    "@types/jsonwebtoken": "^9.0.7",
    "@types/lodash": "^4.17.10",
    "@types/moment": "^2.13.0",
    "@types/sinon": "^17.0.3",
    "@types/uuid": "^10.0.0",
    "@typescript-eslint/eslint-plugin": "^5.30.7",
    "@typescript-eslint/parser": "^5.30.7",
    "bcryptjs": "^2.4.3",
    "better-sqlite3": "^11.3.0",
    "chance": "^1.1.12",
    "eslint": "^8.19.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "eslint-config-airbnb-typescript": "^17.0.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-jest": "^26.5.3",
    "eslint-plugin-prettier": "^5.2.1",
    "jest": "^26.2.0",
    "jest-when": "^3.6.0",
    "prettier": "^3.3.3",
    "prettier-plugin-packagejson": "^2.5.3",
    "sinon": "17.0.1",
    "ts-jest": "^26.1.0",
    "tsc-alias": "^1.8.10",
    "typescript": "^5.6.3"
  }
}

================
File: packages/core/repository/index.ts
================
export * from './RepoUser';
export * from './RepoArticle';

export { RepoFactory } from './RepoFactory';

================
File: packages/core/repository/RepoArticle/index.ts
================
export * from './RepoArticle';

================
File: packages/core/repository/RepoArticle/RepoArticle.ts
================
import { DbArticle } from '@conduit/core/database';

import {
  CountArticleCommentsByArticleIdInput,
  CountArticleCommentsByArticleIdOutput,
  CountArticlesInput,
  CountArticlesOutput,
  CreateArticleCommentInput,
  CreateArticleCommentOutput,
  CreateArticleInput,
  CreateArticleOutput,
  CreateTagsForArticleInput,
  CreateTagsForArticleOutput,
  DeleteArticleByIdInput,
  DeleteArticleByIdOutput,
  DeleteArticleCommentByIdInput,
  DeleteArticleCommentByIdOutput,
  FavoriteArticleInput,
  FavoriteArticleOutput,
  GetArticleByIdInput,
  GetArticleByIdOutput,
  GetArticleBySlugInput,
  GetArticleBySlugOutput,
  GetArticleCommentByIdInput,
  GetArticleCommentByIdOutput,
  GetArticleCommentsByArticleIdInput,
  GetArticleCommentsByArticleIdOutput,
  GetArticleCommentsByIdsInput,
  GetArticleCommentsByIdsOutput,
  GetArticlesInput,
  GetArticlesOutput,
  GetAvailableTagsOutput,
  GetTagsByArticleIdInput,
  GetTagsByArticleIdOutput,
  GetTagsByArticleIdsInput,
  GetTagsByArticleIdsOutput,
  RepoArticleConstructor,
  UnfavoriteArticleInput,
  UnfavoriteArticleOutput,
  UpdateArticleByIdInput,
  UpdateArticleByIdOutput
} from './types';

export class RepoArticle {
  private dbArticle: DbArticle;

  constructor({ dbArticle }: RepoArticleConstructor) {
    this.dbArticle = dbArticle;
  }

  async createArticle(input: CreateArticleInput): CreateArticleOutput {
    return this.dbArticle.createArticle(input);
  }

  async createTagsForArticle({
    articleId,
    tags
  }: CreateTagsForArticleInput): CreateTagsForArticleOutput {
    if (tags.length < 1) {
      return;
    }
    await this.dbArticle.createTagsForArticle({ articleId, tags });
  }

  async createArticleComment(
    input: CreateArticleCommentInput
  ): CreateArticleCommentOutput {
    return this.dbArticle.createArticleComment(input);
  }

  async getArticles(input: GetArticlesInput): GetArticlesOutput {
    return this.dbArticle.getArticles(input);
  }

  async getArticleById({
    id,
    requestingUserId
  }: GetArticleByIdInput): GetArticleByIdOutput {
    const [article] = await this.dbArticle.getArticles({
      ids: [id],
      requestingUserId
    });
    return article;
  }

  async getArticleBySlug({ slug }: GetArticleBySlugInput): GetArticleBySlugOutput {
    const [article] = await this.dbArticle.getArticles({ slugs: [slug] });
    return article;
  }

  async deleteArticleById({ id }: DeleteArticleByIdInput): DeleteArticleByIdOutput {
    await this.dbArticle.deleteArticleById({ id });
  }

  async deleteArticleCommentById({
    id
  }: DeleteArticleCommentByIdInput): DeleteArticleCommentByIdOutput {
    await this.dbArticle.deleteArticleCommentById({ id });
  }

  async getTagsByArticleIds({
    articleIds
  }: GetTagsByArticleIdsInput): GetTagsByArticleIdsOutput {
    return this.dbArticle.getTagsByArticleIds({ articleIds });
  }

  async getAvailableTags(): GetAvailableTagsOutput {
    return this.dbArticle.getAvailableTags();
  }

  async getArticleCommentsByArticleId(
    input: GetArticleCommentsByArticleIdInput
  ): GetArticleCommentsByArticleIdOutput {
    return this.dbArticle.getArticleCommentsByArticleId(input);
  }

  async countArticleCommentsByArticleId(
    input: CountArticleCommentsByArticleIdInput
  ): CountArticleCommentsByArticleIdOutput {
    return this.dbArticle.countArticleCommentsByArticleId(input);
  }

  async getArticleCommentById({
    id,
    requestingUserId
  }: GetArticleCommentByIdInput): GetArticleCommentByIdOutput {
    const [comment] = await this.dbArticle.getArticleCommentsByIds({
      ids: [id],
      requestingUserId
    });
    return comment;
  }

  async updateArticleById(input: UpdateArticleByIdInput): UpdateArticleByIdOutput {
    await this.dbArticle.updateArticleById(input);
  }

  async getArticleCommentsByIds(
    input: GetArticleCommentsByIdsInput
  ): GetArticleCommentsByIdsOutput {
    return this.dbArticle.getArticleCommentsByIds(input);
  }

  async countArticles(input: CountArticlesInput): CountArticlesOutput {
    return this.dbArticle.countArticles(input);
  }

  async favoriteArticle(input: FavoriteArticleInput): FavoriteArticleOutput {
    return this.dbArticle.favoriteArticle(input);
  }

  async unfavoriteArticle(input: UnfavoriteArticleInput): UnfavoriteArticleOutput {
    return this.dbArticle.unfavoriteArticle(input);
  }

  async getTagsByArticleId({
    articleId
  }: GetTagsByArticleIdInput): GetTagsByArticleIdOutput {
    const response = await this.dbArticle.getTagsByArticleIds({
      articleIds: [articleId]
    });
    return response[articleId] ?? [];
  }
}

================
File: packages/core/repository/RepoArticle/types.ts
================
import {
  DbArticle,
  DbDtoArticle,
  DbDtoArticleComment,
  DbDtoArticleTag
} from '@conduit/core/database';

export interface RepoArticleConstructor {
  dbArticle: DbArticle;
}

export {
  CreateArticleInput,
  CreateArticleOutput,
  CreateTagsForArticleInput,
  CreateTagsForArticleOutput,
  DeleteArticleByIdInput,
  DeleteArticleByIdOutput,
  GetTagsByArticleIdsInput,
  GetTagsByArticleIdsOutput,
  GetAvailableTagsOutput,
  CreateArticleCommentInput,
  CreateArticleCommentOutput,
  UpdateArticleByIdInput,
  UpdateArticleByIdOutput,
  GetArticleCommentsByArticleIdInput,
  GetArticleCommentsByArticleIdOutput,
  CountArticleCommentsByArticleIdInput,
  CountArticleCommentsByArticleIdOutput,
  GetArticleCommentsByIdsInput,
  GetArticleCommentsByIdsOutput,
  CountArticlesInput,
  CountArticlesOutput,
  GetArticlesInput,
  GetArticlesOutput,
  FavoriteArticleInput,
  FavoriteArticleOutput,
  UnfavoriteArticleInput,
  UnfavoriteArticleOutput,
  DeleteArticleCommentByIdInput,
  DeleteArticleCommentByIdOutput
} from '@conduit/core/database/DbArticle/types';

/**
 *
 * function: getArticleBySlug
 *
 */
export interface GetArticleBySlugInput {
  slug: string;
  requestingUserId?: string;
}

export type GetArticleBySlugOutput = Promise<DbDtoArticle | undefined>;

/**
 *
 * function: getArticleById
 *
 */
export interface GetArticleByIdInput {
  id: string;
  requestingUserId?: string;
}

export type GetArticleByIdOutput = Promise<DbDtoArticle | undefined>;

/**
 *
 * function: getArticleCommentsById
 *
 */
export interface GetArticleCommentByIdInput {
  id: string;
  requestingUserId?: string;
}

export type GetArticleCommentByIdOutput = Promise<DbDtoArticleComment | undefined>;

/**
 *
 * function: getTagsByArticleIdInput
 *
 */
export interface GetTagsByArticleIdInput {
  articleId: string;
}

export type GetTagsByArticleIdOutput = Promise<DbDtoArticleTag[]>;

================
File: packages/core/repository/RepoFactory.ts
================
import { DbFactory } from '@conduit/core/database';

import { RepoArticle } from './RepoArticle';
import { RepoUser } from './RepoUser';

/**
 *
 * A factory for creating new instances of repository classes.
 *
 */
export class RepoFactory {
  private dbFactory: DbFactory = new DbFactory();

  newRepoUser(): RepoUser {
    const dbUser = this.dbFactory.newDbUser();
    return new RepoUser({ dbUser });
  }

  newRepoArticle(): RepoArticle {
    const dbArticle = this.dbFactory.newDbArticle();
    return new RepoArticle({ dbArticle });
  }
}

================
File: packages/core/repository/RepoUser/index.ts
================
export * from './RepoUser';

================
File: packages/core/repository/RepoUser/RepoUser.ts
================
import { DbUser } from '@conduit/core/database';

import {
  CreateUserInput,
  CreateUserOutput,
  FollowUserInput,
  FollowUserOutput,
  GetIsUserExistsInput,
  GetIsUserExistsOutput,
  GetUserByEmailInput,
  GetUserByEmailOutput,
  GetUserByIdInput,
  GetUserByIdOutput,
  GetUserProfileInput,
  GetUserProfileOutput,
  RepoUserConstructor,
  UnfollowUserInput,
  UnfollowUserOutput,
  UpdateUserByIdInput,
  UpdateUserByIdOutput
} from './types';

export class RepoUser {
  private readonly dbUser: DbUser;

  constructor({ dbUser }: RepoUserConstructor) {
    this.dbUser = dbUser;
  }

  async createUser(input: CreateUserInput): CreateUserOutput {
    return this.dbUser.createUser(input);
  }

  async getIsUserExists(input: GetIsUserExistsInput): GetIsUserExistsOutput {
    return this.dbUser.getIsUserExists(input);
  }

  async getUserById({ id }: GetUserByIdInput): GetUserByIdOutput {
    const [user] = await this.dbUser.getUsers({ ids: [id] });
    return user;
  }

  async getUserByEmail({ email }: GetUserByEmailInput): GetUserByEmailOutput {
    const [user] = await this.dbUser.getUsers({ emails: [email] });
    return user;
  }

  async updateUserById(input: UpdateUserByIdInput): UpdateUserByIdOutput {
    return this.dbUser.updateUser(input);
  }

  async getUserProfile({
    username,
    requestingUserId
  }: GetUserProfileInput): GetUserProfileOutput {
    const [profile] = await this.dbUser.getUserProfiles({
      usernames: [username],
      requestingUserId
    });
    return profile;
  }

  async followUser(input: FollowUserInput): FollowUserOutput {
    return this.dbUser.followUser(input);
  }

  async unfollowUser(input: UnfollowUserInput): UnfollowUserOutput {
    return this.dbUser.unfollowUser(input);
  }
}

================
File: packages/core/repository/RepoUser/types.ts
================
import { DbDtoProfile, DbDtoUser, DbUser } from '@conduit/core/database';

export interface RepoUserConstructor {
  dbUser: DbUser;
}

export {
  CreateUserInput,
  CreateUserOutput,
  GetIsUserExistsInput,
  GetIsUserExistsOutput,
  UpdateUserByIdInput,
  UpdateUserByIdOutput,
  FollowUserInput,
  FollowUserOutput,
  UnfollowUserInput,
  UnfollowUserOutput
} from '@conduit/core/database/DbUser/types';

/**
 *
 * function: getUserById
 *
 */
export interface GetUserByIdInput {
  id: string;
}

export type GetUserByIdOutput = Promise<DbDtoUser | undefined>;

/**
 *
 * function: getUserByEmail
 *
 */
export interface GetUserByEmailInput {
  email: string;
}

export type GetUserByEmailOutput = Promise<DbDtoUser | undefined>;

/**
 *
 * function: getUserProfile
 *
 */
export interface GetUserProfileInput {
  username: string;
  requestingUserId?: string;
}

export type GetUserProfileOutput = Promise<DbDtoProfile | undefined>;

================
File: packages/core/service/article/ArticleService.ts
================
import { RepoArticle } from '@conduit/core/repository';

import {
  CreateArticleCommentHandler,
  CreateArticleCommentInput,
  CreateArticleCommentOutput,
  CreateArticleHandler,
  CreateArticleInput,
  CreateArticleOutput,
  CreateArticleTagsHandler,
  CreateTagsForArticleInput,
  CreateTagsForArticleOutput,
  FavoriteArticleHandler,
  FavoriteArticleInput,
  FavoriteArticleOutput,
  GetArticleCommentsByArticleIdInput,
  GetArticleCommentsByArticleIdOutput,
  GetArticleCommentsHandler,
  UnfavoriteArticleInput,
  UnfavoriteArticleOutput,
  UpdateArticleByIdInput,
  UpdateArticleByIdOutput,
  UpdateArticleHandler
} from './implementations';
import {
  ArticleServiceConstructor,
  CountArticlesInput,
  CountArticlesOutput,
  DeleteArticleByIdInput,
  DeleteArticleByIdOutput,
  DeleteArticleCommentByIdInput,
  DeleteArticleCommentByIdOutput,
  GetArticleByIdInput,
  GetArticleByIdOutput,
  GetArticleBySlugInput,
  GetArticleBySlugOutput,
  GetArticleCommentByIdInput,
  GetArticleCommentByIdOutput,
  GetArticlesInput,
  GetArticlesOutput,
  GetAvailableTagsOutput,
  GetTagsByArticleIdInput,
  GetTagsByArticleIdOutput,
  GetTagsByArticleIdsInput,
  GetTagsByArticleIdsOutput
} from './types';

export class ArticleService {
  private readonly repoArticle: RepoArticle;
  private readonly updateArticleHandler: UpdateArticleHandler;
  private readonly favoriteArticleHandler: FavoriteArticleHandler;
  private readonly createArticleHandler: CreateArticleHandler;
  private readonly createArticleTagsHandler: CreateArticleTagsHandler;
  private readonly createArticleCommentHandler: CreateArticleCommentHandler;
  private readonly getArticleCommentsHandler: GetArticleCommentsHandler;

  constructor({ repoArticle }: ArticleServiceConstructor) {
    this.repoArticle = repoArticle;
    this.createArticleHandler = new CreateArticleHandler({ repoArticle });
    this.createArticleTagsHandler = new CreateArticleTagsHandler({ repoArticle });
    this.createArticleCommentHandler = new CreateArticleCommentHandler({
      repoArticle
    });
    this.getArticleCommentsHandler = new GetArticleCommentsHandler({ repoArticle });
    this.favoriteArticleHandler = new FavoriteArticleHandler({ repoArticle });
    this.updateArticleHandler = new UpdateArticleHandler({ repoArticle });
  }

  async getArticles(input: GetArticlesInput): GetArticlesOutput {
    return this.repoArticle.getArticles(input);
  }

  async getArticleById({
    id,
    requestingUserId
  }: GetArticleByIdInput): GetArticleByIdOutput {
    const article = await this.repoArticle.getArticleById({ id, requestingUserId });
    return article;
  }

  async getArticleBySlug({
    slug,
    requestingUserId
  }: GetArticleBySlugInput): GetArticleBySlugOutput {
    const article = await this.repoArticle.getArticleBySlug({
      slug,
      requestingUserId
    });
    return article;
  }

  async countArticles(input: CountArticlesInput): CountArticlesOutput {
    return this.repoArticle.countArticles(input);
  }

  async createArticle(input: CreateArticleInput): CreateArticleOutput {
    return this.createArticleHandler.execute(input);
  }

  async createArticleComment(
    input: CreateArticleCommentInput
  ): CreateArticleCommentOutput {
    const commentId = await this.createArticleCommentHandler.execute(input);
    return commentId;
  }

  async createArticleTags(
    input: CreateTagsForArticleInput
  ): CreateTagsForArticleOutput {
    await this.createArticleTagsHandler.execute(input);
  }

  async updateArticleById(input: UpdateArticleByIdInput): UpdateArticleByIdOutput {
    await this.updateArticleHandler.execute(input);
  }

  async deleteArticleById({ id }: DeleteArticleByIdInput): DeleteArticleByIdOutput {
    await this.repoArticle.deleteArticleById({ id });
  }

  async getTagsByArticleId(
    input: GetTagsByArticleIdInput
  ): GetTagsByArticleIdOutput {
    return this.repoArticle.getTagsByArticleId(input);
  }

  async getTagsByArticleIds(
    input: GetTagsByArticleIdsInput
  ): GetTagsByArticleIdsOutput {
    return this.repoArticle.getTagsByArticleIds(input);
  }

  async getAvailableTags(): GetAvailableTagsOutput {
    return this.repoArticle.getAvailableTags();
  }

  async getArticleCommentsByArticleId(
    input: GetArticleCommentsByArticleIdInput
  ): GetArticleCommentsByArticleIdOutput {
    return this.getArticleCommentsHandler.execute(input);
  }

  async getArticleCommentById(
    input: GetArticleCommentByIdInput
  ): GetArticleCommentByIdOutput {
    return this.repoArticle.getArticleCommentById(input);
  }

  async favoriteArticle(input: FavoriteArticleInput): FavoriteArticleOutput {
    return this.favoriteArticleHandler.favorite(input);
  }

  async unfavoriteArticle(input: UnfavoriteArticleInput): UnfavoriteArticleOutput {
    return this.favoriteArticleHandler.unfavorite(input);
  }

  async deleteArticleCommentById(
    input: DeleteArticleCommentByIdInput
  ): DeleteArticleCommentByIdOutput {
    return this.repoArticle.deleteArticleCommentById(input);
  }
}

================
File: packages/core/service/article/constants/ArticleErrorCodes.ts
================
export enum ArticleErrorCodes {
  Generic = 'ARTICLE_GENERIC',
  ArticleTitleTaken = 'ARTICLE_TITLE_TAKEN',
  ArticleNotFound = 'ARTICLE_NOT_FOUND',
  ArticleCommentNotFound = 'ARTICLE_COMMENT_NOT_FOUND',
  ArticleAlreadyFavorited = 'ARTICLE_ALREADY_FAVORITED',
  ArticleNotYetFavorited = 'ARTICLE_NOT_YET_FAVORITED'
}

================
File: packages/core/service/article/constants/index.ts
================
export * from './ArticleErrorCodes';

================
File: packages/core/service/article/errors/ArticleAlreadyFavoritedError.ts
================
import { ArticleErrorCodes } from '../constants';
import { ArticleError } from './ArticleError';

export class ArticleAlreadyFavoritedError extends ArticleError {
  constructor({ userId, articleId }: ArticleAlreadyFavoritedErrorConstructor) {
    super({
      code: ArticleErrorCodes.ArticleAlreadyFavorited,
      message: 'Article is already favorited by the user',
      details: [userId, articleId]
    });
  }
}

interface ArticleAlreadyFavoritedErrorConstructor {
  userId: string;
  articleId: string;
}

================
File: packages/core/service/article/errors/ArticleError.ts
================
import { AppError } from '../../../utils';
import { ArticleErrorCodes } from '../constants';

export class ArticleError extends AppError {
  constructor({
    code = ArticleErrorCodes.Generic,
    message,
    details,
    cause
  }: ArticleErrorConstructor) {
    super({
      code,
      message,
      details,
      cause
    });
  }
}

export interface ArticleErrorConstructor {
  message?: string;
  code?: ArticleErrorCodes;
  details?: any[];
  cause?: Error;
}

================
File: packages/core/service/article/errors/ArticleNotFoundError.ts
================
import { ArticleErrorCodes } from '../constants';
import { ArticleError } from './ArticleError';

export class ArticleNotFoundError extends ArticleError {
  constructor({ slug }: ArticleNotFoundErrorConstructor) {
    super({
      code: ArticleErrorCodes.ArticleNotFound,
      message: 'The requested article was not found.',
      details: slug ? [slug] : []
    });
  }
}

interface ArticleNotFoundErrorConstructor {
  slug?: string;
}

================
File: packages/core/service/article/errors/ArticleNotYetFavoritedError.ts
================
import { ArticleErrorCodes } from '../constants';
import { ArticleError } from './ArticleError';

export class ArticleNotYetFavoritedError extends ArticleError {
  constructor({ userId, articleId }: ArticleNotYetFavoritedErrorConstructor) {
    super({
      code: ArticleErrorCodes.ArticleNotYetFavorited,
      message: 'Article is not yet favorited by the user',
      details: [userId, articleId]
    });
  }
}

interface ArticleNotYetFavoritedErrorConstructor {
  userId: string;
  articleId: string;
}

================
File: packages/core/service/article/errors/ArticleTitleAlreadyTakenError.ts
================
import { ArticleErrorCodes } from '../constants';
import { ArticleError } from './ArticleError';

export class ArticleTitleAlreadyTakenError extends ArticleError {
  constructor({ title }: ArticleTitleAlreadyTakenErrorConstructor) {
    super({
      code: ArticleErrorCodes.ArticleTitleTaken,
      message: `The title "${title}" is already taken. Please choose a different title.`,
      details: [title]
    });
  }
}

interface ArticleTitleAlreadyTakenErrorConstructor {
  title: string;
}

================
File: packages/core/service/article/errors/index.ts
================
export * from './ArticleError';
export * from './ArticleNotFoundError';
export * from './ArticleTitleAlreadyTakenError';
export * from './ArticleNotYetFavoritedError';
export * from './ArticleAlreadyFavoritedError';

================
File: packages/core/service/article/implementations/CreateArticleCommentHandler/CreateArticleCommentHandler.ts
================
import { RepoArticle } from '@conduit/core/repository';

import { ArticleNotFoundError } from '../../errors';
import {
  CreateArticleCommentHandlerConstructor,
  CreateArticleCommentInput,
  CreateArticleCommentOutput,
  ValidateArticleInput,
  ValidateArticleOutput
} from './types';

export class CreateArticleCommentHandler {
  private repoArticle: RepoArticle;

  constructor({ repoArticle }: CreateArticleCommentHandlerConstructor) {
    this.repoArticle = repoArticle;
  }

  async execute({
    articleId,
    body,
    userId
  }: CreateArticleCommentInput): CreateArticleCommentOutput {
    await this.validateArticle({ articleId });
    const commentId = await this.repoArticle.createArticleComment({
      articleId,
      body,
      userId
    });
    return commentId;
  }

  private async validateArticle({
    articleId
  }: ValidateArticleInput): ValidateArticleOutput {
    const article = await this.repoArticle.getArticleById({
      id: articleId
    });
    if (!article) {
      throw new ArticleNotFoundError({});
    }
  }
}

================
File: packages/core/service/article/implementations/CreateArticleCommentHandler/index.ts
================
export { CreateArticleCommentHandler } from './CreateArticleCommentHandler';
export { CreateArticleCommentInput, CreateArticleCommentOutput } from './types';

================
File: packages/core/service/article/implementations/CreateArticleCommentHandler/types.ts
================
import { RepoArticle } from '@conduit/core/repository';

export interface CreateArticleCommentHandlerConstructor {
  repoArticle: RepoArticle;
}

export interface CreateArticleCommentInput {
  articleId: string;
  body: string;
  userId: string;
}

export type CreateArticleCommentOutput = Promise<string>;

/**
 *
 * function: validateArticle
 *
 */
export interface ValidateArticleInput {
  articleId: string;
}

export type ValidateArticleOutput = Promise<void>;

================
File: packages/core/service/article/implementations/CreateArticleHandler/CreateArticleHandler.ts
================
import slugify from 'slugify';

import { RepoArticle } from '@conduit/core/repository';

import { ArticleTitleAlreadyTakenError } from '../../errors';
import {
  CreateArticleHandlerConstructor,
  CreateArticleInput,
  CreateArticleOutput,
  ValidateIfArticleExistInput,
  ValidateIfArticleExistOutput
} from './types';

export class CreateArticleHandler {
  private repoArticle: RepoArticle;

  constructor({ repoArticle }: CreateArticleHandlerConstructor) {
    this.repoArticle = repoArticle;
  }

  async execute({
    title,
    description,
    body,
    userId
  }: CreateArticleInput): CreateArticleOutput {
    await this.validateIfArticleExist({ title });
    const slug = slugify(title);
    const articleId = await this.repoArticle.createArticle({
      title,
      slug,
      description,
      body,
      userId
    });
    return articleId;
  }

  private async validateIfArticleExist({
    title
  }: ValidateIfArticleExistInput): ValidateIfArticleExistOutput {
    const slug = slugify(title);
    const article = await this.repoArticle.getArticleBySlug({ slug });
    if (article) {
      throw new ArticleTitleAlreadyTakenError({ title });
    }
  }
}

================
File: packages/core/service/article/implementations/CreateArticleHandler/index.ts
================
export { CreateArticleHandler } from './CreateArticleHandler';
export { CreateArticleInput, CreateArticleOutput } from './types';

================
File: packages/core/service/article/implementations/CreateArticleHandler/types.ts
================
import { RepoArticle } from '@conduit/core/repository';

export interface CreateArticleHandlerConstructor {
  repoArticle: RepoArticle;
}

export interface CreateArticleInput {
  title: string;
  description: string;
  body: string;
  userId: string;
}

export type CreateArticleOutput = Promise<string>;

/**
 *
 * function: validateIfArticleExist
 *
 */
export interface ValidateIfArticleExistInput {
  title: string;
}

export type ValidateIfArticleExistOutput = Promise<void>;

================
File: packages/core/service/article/implementations/CreateArticleTagsHandler/CreateArticleTagsHandler.ts
================
import { RepoArticle } from '@conduit/core/repository';

import { ArticleNotFoundError } from '../../errors';
import {
  CreateArticleTagsHandlerConstructor,
  CreateTagsForArticleInput,
  CreateTagsForArticleOutput,
  ValidateArticleIdInput,
  ValidateArticleIdOutput
} from './types';

export class CreateArticleTagsHandler {
  private repoArticle: RepoArticle;

  constructor({ repoArticle }: CreateArticleTagsHandlerConstructor) {
    this.repoArticle = repoArticle;
  }

  async execute({
    articleId,
    tagList
  }: CreateTagsForArticleInput): CreateTagsForArticleOutput {
    if (tagList.length < 1) {
      return;
    }
    await this.validateArticleId({ articleId });
    await this.repoArticle.createTagsForArticle({ articleId, tags: tagList });
  }

  private async validateArticleId({
    articleId
  }: ValidateArticleIdInput): ValidateArticleIdOutput {
    const article = await this.repoArticle.getArticleById({
      id: articleId
    });
    if (!article) {
      throw new ArticleNotFoundError({});
    }
  }
}

================
File: packages/core/service/article/implementations/CreateArticleTagsHandler/index.ts
================
export { CreateArticleTagsHandler } from './CreateArticleTagsHandler';
export { CreateTagsForArticleInput, CreateTagsForArticleOutput } from './types';

================
File: packages/core/service/article/implementations/CreateArticleTagsHandler/types.ts
================
import { RepoArticle } from '@conduit/core/repository';

export interface CreateArticleTagsHandlerConstructor {
  repoArticle: RepoArticle;
}

/**
 *
 * function: createTagsForArticle
 *
 */
export interface CreateTagsForArticleInput {
  articleId: string;
  tagList: string[];
}

export type CreateTagsForArticleOutput = Promise<void>;

/**
 *
 * function: validateArticleId
 *
 */
export interface ValidateArticleIdInput {
  articleId: string;
}

export type ValidateArticleIdOutput = Promise<void>;

================
File: packages/core/service/article/implementations/FavoriteArticleHandler/FavoriteArticleHandler.ts
================
import { RepoArticle } from '@conduit/core/repository';

import {
  ArticleAlreadyFavoritedError,
  ArticleNotFoundError,
  ArticleNotYetFavoritedError
} from '../../errors';
import {
  FavoriteArticleHandlerConstructor,
  FavoriteArticleInput,
  FavoriteArticleOutput,
  UnfavoriteArticleInput,
  UnfavoriteArticleOutput
} from './types';

export class FavoriteArticleHandler {
  private repoArticle: RepoArticle;

  constructor({ repoArticle }: FavoriteArticleHandlerConstructor) {
    this.repoArticle = repoArticle;
  }

  async favorite({
    userId,
    articleId
  }: FavoriteArticleInput): FavoriteArticleOutput {
    const article = await this.repoArticle.getArticleById({
      id: articleId,
      requestingUserId: userId
    });
    if (!article) {
      throw new ArticleNotFoundError({});
    }
    if (article.favorited) {
      throw new ArticleAlreadyFavoritedError({ userId, articleId });
    }
    await this.repoArticle.favoriteArticle({ userId, articleId });
  }

  async unfavorite({
    userId,
    articleId
  }: UnfavoriteArticleInput): UnfavoriteArticleOutput {
    const article = await this.repoArticle.getArticleById({
      id: articleId,
      requestingUserId: userId
    });
    if (!article) {
      throw new ArticleNotFoundError({});
    }
    if (!article.favorited) {
      throw new ArticleNotYetFavoritedError({ userId, articleId });
    }
    await this.repoArticle.unfavoriteArticle({ articleId, userId });
  }
}

================
File: packages/core/service/article/implementations/FavoriteArticleHandler/index.ts
================
export { FavoriteArticleHandler } from './FavoriteArticleHandler';
export {
  FavoriteArticleInput,
  FavoriteArticleOutput,
  UnfavoriteArticleInput,
  UnfavoriteArticleOutput
} from './types';

================
File: packages/core/service/article/implementations/FavoriteArticleHandler/types.ts
================
import { RepoArticle } from '@conduit/core/repository';

export interface FavoriteArticleHandlerConstructor {
  repoArticle: RepoArticle;
}

/**
 *
 * function: favoriteArticle
 *
 */
export interface FavoriteArticleInput {
  userId: string;
  articleId: string;
}

export type FavoriteArticleOutput = Promise<void>;

/**
 *
 * function: unfavoriteArticle
 *
 */
export interface UnfavoriteArticleInput {
  userId: string;
  articleId: string;
}

export type UnfavoriteArticleOutput = Promise<void>;

================
File: packages/core/service/article/implementations/GetArticleCommentsHandler/GetArticleCommentsHandler.ts
================
import { RepoArticle } from '@conduit/core/repository';

import {
  GetArticleCommentsByArticleIdInput,
  GetArticleCommentsByArticleIdOutput,
  GetArticleCommentsHandlerConstructor
} from './types';

export class GetArticleCommentsHandler {
  private repoArticle: RepoArticle;

  constructor({ repoArticle }: GetArticleCommentsHandlerConstructor) {
    this.repoArticle = repoArticle;
  }

  async execute({
    articleId,
    limit,
    offset,
    requestingUserId
  }: GetArticleCommentsByArticleIdInput): GetArticleCommentsByArticleIdOutput {
    const comments = await this.repoArticle.getArticleCommentsByArticleId({
      articleId,
      limit,
      offset,
      requestingUserId
    });
    const count = await this.repoArticle.countArticleCommentsByArticleId({
      articleId
    });
    return {
      comments,
      count
    };
  }
}

================
File: packages/core/service/article/implementations/GetArticleCommentsHandler/index.ts
================
export { GetArticleCommentsHandler } from './GetArticleCommentsHandler';
export {
  GetArticleCommentsByArticleIdInput,
  GetArticleCommentsByArticleIdOutput
} from './types';

================
File: packages/core/service/article/implementations/GetArticleCommentsHandler/types.ts
================
import { DbDtoArticleCommentWithProfile } from '@conduit/core/database';
import { RepoArticle } from '@conduit/core/repository';

export interface GetArticleCommentsHandlerConstructor {
  repoArticle: RepoArticle;
}

export interface GetArticleCommentsByArticleIdInput {
  articleId: string;
  limit: number;
  offset: number;
  requestingUserId?: string;
}

export type GetArticleCommentsByArticleIdOutput = Promise<{
  comments: DbDtoArticleCommentWithProfile[];
  count: number;
}>;

================
File: packages/core/service/article/implementations/index.ts
================
export * from './CreateArticleCommentHandler';
export * from './CreateArticleHandler';
export * from './CreateArticleTagsHandler';
export * from './GetArticleCommentsHandler';
export * from './FavoriteArticleHandler';
export * from './UpdateArticleHandler';

================
File: packages/core/service/article/implementations/UpdateArticleHandler/index.ts
================
export { UpdateArticleHandler } from './UpdateArticleHandler';
export { UpdateArticleByIdInput, UpdateArticleByIdOutput } from './types';

================
File: packages/core/service/article/implementations/UpdateArticleHandler/types.ts
================
import { RepoArticle } from '@conduit/core/repository';

export interface UpdateArticleHandlerConstructor {
  repoArticle: RepoArticle;
}

export interface UpdateArticleByIdInput {
  id: string;
  title?: string;
  description?: string;
  body?: string;
}

export type UpdateArticleByIdOutput = Promise<void>;

/**
 *
 * function: validateIfArticleExist
 *
 */
export interface ValidateIfArticleExistInput {
  title: string;
}

export type ValidateIfArticleExistOutput = Promise<void>;

================
File: packages/core/service/article/implementations/UpdateArticleHandler/UpdateArticleHandler.ts
================
import slugify from 'slugify';

import { RepoArticle } from '@conduit/core/repository';

import { ArticleNotFoundError, ArticleTitleAlreadyTakenError } from '../../errors';
import {
  UpdateArticleByIdInput,
  UpdateArticleByIdOutput,
  UpdateArticleHandlerConstructor,
  ValidateIfArticleExistInput,
  ValidateIfArticleExistOutput
} from './types';

export class UpdateArticleHandler {
  private repoArticle: RepoArticle;

  constructor({ repoArticle }: UpdateArticleHandlerConstructor) {
    this.repoArticle = repoArticle;
  }

  async execute({
    id,
    title,
    description,
    body
  }: UpdateArticleByIdInput): UpdateArticleByIdOutput {
    const article = await this.repoArticle.getArticleById({ id });
    if (!article) {
      throw new ArticleNotFoundError({});
    }

    let slug: string | undefined;
    if (title && article.title !== title) {
      await this.validateIfArticleExist({ title });
      slug = slugify(title);
    }

    await this.repoArticle.updateArticleById({
      id,
      title,
      slug,
      description,
      body
    });
  }

  private async validateIfArticleExist({
    title
  }: ValidateIfArticleExistInput): ValidateIfArticleExistOutput {
    const slug = slugify(title);
    const article = await this.repoArticle.getArticleBySlug({ slug });
    if (article) {
      throw new ArticleTitleAlreadyTakenError({ title });
    }
  }
}

================
File: packages/core/service/article/index.ts
================
export { ArticleService } from './ArticleService';
export * from './errors';

================
File: packages/core/service/article/types.ts
================
import { RepoArticle } from '@conduit/core/repository';

export interface ArticleServiceConstructor {
  repoArticle: RepoArticle;
}

export {
  GetArticleByIdInput,
  GetArticleByIdOutput,
  GetArticleBySlugInput,
  GetArticleBySlugOutput,
  DeleteArticleByIdInput,
  DeleteArticleByIdOutput,
  GetTagsByArticleIdsInput,
  GetTagsByArticleIdsOutput,
  GetAvailableTagsOutput,
  GetArticleCommentsByArticleIdInput,
  GetArticleCommentsByArticleIdOutput,
  CountArticleCommentsByArticleIdInput,
  CountArticleCommentsByArticleIdOutput,
  GetArticleCommentByIdInput,
  GetArticleCommentByIdOutput,
  CountArticlesInput,
  CountArticlesOutput,
  GetArticlesInput,
  GetArticlesOutput,
  GetTagsByArticleIdInput,
  GetTagsByArticleIdOutput,
  DeleteArticleCommentByIdInput,
  DeleteArticleCommentByIdOutput
} from '@conduit/core/repository/RepoArticle/types';

================
File: packages/core/service/auth/AuthService.ts
================
import {
  AccessTokenHandler,
  ComparePasswordInput,
  ComparePasswordOutput,
  EncryptPasswordInput,
  EncryptPasswordOutput,
  GenerateAccessTokenInput,
  GenerateAccessTokenOutput,
  PasswordHandler,
  VerifyAccessTokenInput,
  VerifyAccessTokenOutput
} from './implementations';

export class AuthService {
  private passwordHandler: PasswordHandler;
  private accessTokenHandler: AccessTokenHandler;

  constructor() {
    this.passwordHandler = new PasswordHandler();
    this.accessTokenHandler = new AccessTokenHandler();
  }

  generateAccessToken(input: GenerateAccessTokenInput): GenerateAccessTokenOutput {
    return this.accessTokenHandler.generateAccessToken(input);
  }

  verifyAccessToken(input: VerifyAccessTokenInput): VerifyAccessTokenOutput {
    return this.accessTokenHandler.verifyAccessToken(input);
  }

  async encryptPassword(input: EncryptPasswordInput): EncryptPasswordOutput {
    return this.passwordHandler.encryptPassword(input);
  }

  async comparePassword(input: ComparePasswordInput): ComparePasswordOutput {
    await this.passwordHandler.comparePassword(input);
  }
}

================
File: packages/core/service/auth/constants/AuthErrorCodes.ts
================
export enum AuthErrorCodes {
  Generic = 'AUTH_GENERIC',
  PasswordNotMatch = 'AUTH_PASSWORD_NOT_MATCH',
  PasswordRequirementsNotMetError = 'AUTH_PASSWORD_REQUIREMENTS_NOT_MET',
  InvalidToken = 'AUTH_INVALID_TOKEN'
}

================
File: packages/core/service/auth/constants/index.ts
================
export * from './AuthErrorCodes';

================
File: packages/core/service/auth/errors/AuthError.ts
================
import { AppError } from '../../../utils';
import { AuthErrorCodes } from '../constants';

export class AuthError extends AppError {
  constructor({
    code = AuthErrorCodes.Generic,
    message,
    details,
    cause
  }: AuthErrorConstructor) {
    super({
      code,
      message,
      details,
      cause
    });
  }
}

export interface AuthErrorConstructor {
  message?: string;
  code?: AuthErrorCodes;
  details?: any[];
  cause?: Error;
}

================
File: packages/core/service/auth/errors/index.ts
================
export * from './AuthError';
export * from './PasswordNotMatchError';
export * from './PasswordRequirementsNotMetError';
export * from './InvalidTokenError';

================
File: packages/core/service/auth/errors/InvalidTokenError.ts
================
import { AuthErrorCodes } from '../constants';
import { AuthError } from './AuthError';

export class InvalidTokenError extends AuthError {
  constructor({ message, cause }: InvalidTokenErrorConstructor) {
    super({
      code: AuthErrorCodes.InvalidToken,
      message:
        message ??
        'Sorry, your login is invalid. Please try again or contact support for help.',
      cause
    });
  }
}

interface InvalidTokenErrorConstructor {
  message?: string;
  cause?: Error;
}

================
File: packages/core/service/auth/errors/PasswordNotMatchError.ts
================
import { AuthErrorCodes } from '../constants';
import { AuthError } from './AuthError';

export class PasswordNotMatchError extends AuthError {
  constructor() {
    super({
      code: AuthErrorCodes.PasswordNotMatch,
      message: 'Passwords do not match. Please try again.'
    });
  }
}

================
File: packages/core/service/auth/errors/PasswordRequirementsNotMetError.ts
================
import { AuthErrorCodes } from '../constants';
import { AuthError } from './AuthError';

export class PasswordRequirementsNotMetError extends AuthError {
  constructor({ details }: PasswordRequirementsNotMetErrorConstructor) {
    super({
      code: AuthErrorCodes.PasswordRequirementsNotMetError,
      message:
        'Password requirements not met. Your password must be at least 6 characters long and contain at least one letter and one digit.',
      details
    });
  }
}

interface PasswordRequirementsNotMetErrorConstructor {
  details?: string[];
}

================
File: packages/core/service/auth/implementations/AccessTokenHandler/AccessTokenHandler.ts
================
import jsonwebtoken, { JsonWebTokenError, TokenExpiredError } from 'jsonwebtoken';

import { config } from '@conduit/utils';

import { InvalidTokenError } from '../../errors';
import {
  GenerateAccessTokenInput,
  GenerateAccessTokenOutput,
  GenerateRefreshTokenInput,
  GenerateRefreshTokenOutput,
  JwtPayload,
  RefreshTokenPayload,
  VerifyAccessTokenInput,
  VerifyAccessTokenOutput,
  VerifyRefreshTokenInput,
  VerifyRefreshTokenOutput
} from './types';

export class AccessTokenHandler {
  private static version = '1.0';

  verifyAccessToken({
    accessToken
  }: VerifyAccessTokenInput): VerifyAccessTokenOutput {
    try {
      const payload = jsonwebtoken.verify(
        accessToken,
        config.auth.jwtSecret
      ) as JwtPayload;
      return payload.userId;
    } catch (error) {
      if (error instanceof TokenExpiredError) {
        throw new InvalidTokenError({
          message: 'Your session has expired. Please log in again.',
          cause: error
        });
      }
      if (error instanceof JsonWebTokenError) {
        throw new InvalidTokenError({ cause: error });
      }
      throw error;
    }
  }

  verifyRefreshToken({
    refreshToken
  }: VerifyRefreshTokenInput): VerifyRefreshTokenOutput {
    try {
      const payload = jsonwebtoken.verify(
        refreshToken,
        config.auth.jwtSecret
      ) as RefreshTokenPayload;
      return payload;
    } catch (error) {
      if (error instanceof TokenExpiredError) {
        throw new InvalidTokenError({
          message: 'Your session has expired. Please log in again.',
          cause: error
        });
      }
      if (error instanceof JsonWebTokenError) {
        throw new InvalidTokenError({ cause: error });
      }
      throw error;
    }
  }

  generateAccessToken({
    userId,
    loginId
  }: GenerateAccessTokenInput): GenerateAccessTokenOutput {
    const payload: JwtPayload = {
      userId,
      iss: 'Conduit',
      sub: userId,
      jti: loginId,
      version: AccessTokenHandler.version
    };
    if (config.domain) {
      payload.aud = `https://${config.domain}`;
    }
    const accessToken = jsonwebtoken.sign(payload, config.auth.jwtSecret, {
      expiresIn: config.auth.expiresIn
    });
    return accessToken;
  }

  generateRefreshToken({
    userId,
    loginId
  }: GenerateRefreshTokenInput): GenerateRefreshTokenOutput {
    const payload: RefreshTokenPayload = {
      userId,
      loginId,
      version: AccessTokenHandler.version
    };
    const refreshToken = jsonwebtoken.sign(payload, config.auth.jwtSecret, {
      expiresIn: config.auth.expiresIn
    });
    return refreshToken;
  }
}

================
File: packages/core/service/auth/implementations/AccessTokenHandler/index.ts
================
export { AccessTokenHandler } from './AccessTokenHandler';
export {
  VerifyAccessTokenInput,
  VerifyAccessTokenOutput,
  VerifyRefreshTokenInput,
  VerifyRefreshTokenOutput,
  GenerateAccessTokenInput,
  GenerateAccessTokenOutput
} from './types';

================
File: packages/core/service/auth/implementations/AccessTokenHandler/types.ts
================
export interface JwtPayload {
  userId: string;
  aud?: string;
  iss: string;
  sub: string;
  jti: string;
  version?: string;
}

export interface RefreshTokenPayload {
  userId: string;
  loginId: string;
  version?: string;
}

/**
 *
 * function: generateAccessToken
 *
 */
export interface GenerateAccessTokenInput {
  userId: string;
  loginId: string;
}

export type GenerateAccessTokenOutput = string;

/**
 *
 * function: generateRefreshToken
 *
 */
export interface GenerateRefreshTokenInput {
  userId: string;
  loginId: string;
}

export type GenerateRefreshTokenOutput = string;

/**
 *
 * function: verifyAccessToken
 *
 */
export interface VerifyAccessTokenInput {
  accessToken: string;
}

export type VerifyAccessTokenOutput = string;

/**
 *
 * function: verifyRefreshToken
 *
 */
export interface VerifyRefreshTokenInput {
  refreshToken: string;
}

export type VerifyRefreshTokenOutput = RefreshTokenPayload;

================
File: packages/core/service/auth/implementations/index.ts
================
export * from './AccessTokenHandler';
export * from './PasswordHandler';

================
File: packages/core/service/auth/implementations/PasswordHandler/index.ts
================
export { PasswordHandler } from './PasswordHandler';
export {
  ComparePasswordInput,
  ComparePasswordOutput,
  EncryptPasswordInput,
  EncryptPasswordOutput
} from './types';

================
File: packages/core/service/auth/implementations/PasswordHandler/PasswordHandler.ts
================
import { compare, hash } from 'bcryptjs';

import {
  PasswordNotMatchError,
  PasswordRequirementsNotMetError
} from '../../errors';
import {
  ComparePasswordInput,
  ComparePasswordOutput,
  EncryptPasswordInput,
  EncryptPasswordOutput,
  ValidatePasswordInput,
  ValidatePasswordOutput
} from './types';

export class PasswordHandler {
  async encryptPassword({ password }: EncryptPasswordInput): EncryptPasswordOutput {
    this.validatePassword({ password });
    const hashed = await hash(password, 10);
    return hashed;
  }

  async comparePassword({
    password,
    encryptedPassword
  }: ComparePasswordInput): ComparePasswordOutput {
    const matched = await compare(password, encryptedPassword);
    if (!matched) {
      throw new PasswordNotMatchError();
    }
  }

  private validatePassword({
    password
  }: ValidatePasswordInput): ValidatePasswordOutput {
    const details: string[] = [];
    if (password.length < 6) {
      details.push('The password must be at least 6 characters long');
    }
    // Regular expression to match passwords with at least one letter and one digit
    const passwordRegex = /^(?=.*[a-zA-Z])(?=.*\d).+$/;
    if (!passwordRegex.test(password)) {
      details.push('The password must contain at least one letter and one digit');
    }
    if (details.length > 0) {
      throw new PasswordRequirementsNotMetError({ details });
    }
  }
}

================
File: packages/core/service/auth/implementations/PasswordHandler/types.ts
================
/**
 *
 * function: encryptPassword
 *
 */
export interface EncryptPasswordInput {
  password: string;
}

export type EncryptPasswordOutput = Promise<string>;

/**
 *
 * function: comparePassword
 *
 */
export interface ComparePasswordInput {
  password: string;
  encryptedPassword: string;
}

export type ComparePasswordOutput = Promise<void>;

/**
 *
 * function: validatePassword
 *
 */
export interface ValidatePasswordInput {
  password: string;
}

export type ValidatePasswordOutput = void;

================
File: packages/core/service/auth/index.ts
================
export { AuthService } from './AuthService';
export * from './errors';

================
File: packages/core/service/index.ts
================
export * from './ServiceFactory';
export * from './auth';
export * from './user';
export * from './article';

================
File: packages/core/service/ServiceFactory.ts
================
import { RepoFactory } from '@conduit/core/repository';

import { ArticleService } from './article';
import { AuthService } from './auth';
import { UserService } from './user';

export class ServiceFactory {
  private readonly repoFactory: RepoFactory = new RepoFactory();

  newAuthService(): AuthService {
    return new AuthService();
  }

  newArticleService(): ArticleService {
    const repoArticle = this.repoFactory.newRepoArticle();
    return new ArticleService({ repoArticle });
  }

  newUserService(): UserService {
    const repoUser = this.repoFactory.newRepoUser();
    const authService = this.newAuthService();
    return new UserService({ authService, repoUser });
  }
}

================
File: packages/core/service/user/constants/index.ts
================
export * from './UserErrorCode';

================
File: packages/core/service/user/constants/UserErrorCode.ts
================
export enum UserErrorCodes {
  Generic = 'USER_GENERIC',
  UserExisted = 'USER_EXISTED',
  UserNotFound = 'USER_NOT_FOUND',
  InvalidFollow = 'USER_INVALID_FOLLOW'
}

================
File: packages/core/service/user/errors/index.ts
================
export * from './UserError';
export * from './InvalidFollowError';
export * from './UserExistError';
export * from './UserNotFoundError';

================
File: packages/core/service/user/errors/InvalidFollowError.ts
================
import { UserErrorCodes } from '../constants';
import { UserError } from './UserError';

export class InvalidFollowError extends UserError {
  constructor({ message }: InvalidFollowErrorConstructor) {
    super({
      code: UserErrorCodes.InvalidFollow,
      message
    });
  }
}

interface InvalidFollowErrorConstructor {
  message: string;
}

================
File: packages/core/service/user/errors/UserError.ts
================
import { AppError } from '../../../utils';
import { UserErrorCodes } from '../constants';

export class UserError extends AppError {
  constructor({
    code = UserErrorCodes.Generic,
    message,
    details,
    cause
  }: UserErrorConstructor) {
    super({
      code,
      message,
      details,
      cause
    });
  }
}

export interface UserErrorConstructor {
  message?: string;
  code?: UserErrorCodes;
  details?: any[];
  cause?: Error;
}

================
File: packages/core/service/user/errors/UserExistError.ts
================
import { UserErrorCodes } from '../constants';
import { UserError } from './UserError';

export class UserExistError extends UserError {
  public type: 'email' | 'username';

  constructor({ type }: UserExistErrorConstructor) {
    super({
      code: UserErrorCodes.UserExisted,
      message:
        type === 'email'
          ? 'The provided email is already registered. Please use a different email.'
          : 'The provided username is already taken. Please use a different username.'
    });
    this.type = type;
  }
}

interface UserExistErrorConstructor {
  type: 'email' | 'username';
}

================
File: packages/core/service/user/errors/UserNotFoundError.ts
================
import { UserErrorCodes } from '../constants';
import { UserError } from './UserError';

export class UserNotFoundError extends UserError {
  constructor({ message }: UserNotFoundErrorConstructor) {
    super({
      code: UserErrorCodes.UserNotFound,
      message:
        message ??
        'Sorry, we could not find an user with that information. Please try again with a different email or username'
    });
  }
}

export interface UserNotFoundErrorConstructor {
  message?: string;
}

================
File: packages/core/service/user/implementations/CreateUserHandler/CreateUserHandler.ts
================
import { RepoUser } from '@conduit/core/repository';
import { AuthService } from '@conduit/core/service/auth';

import { UserExistError } from '../../errors';
import {
  CreateUserHandlerConstructor,
  CreateUserInput,
  CreateUserOutput,
  ValidateInputInput,
  ValidateInputOutput
} from './types';

export class CreateUserHandler {
  private readonly authService: AuthService;
  private readonly repoUser: RepoUser;

  constructor({ authService, repoUser }: CreateUserHandlerConstructor) {
    this.authService = authService;
    this.repoUser = repoUser;
  }

  async createUser({
    email,
    username,
    password,
    image,
    bio
  }: CreateUserInput): CreateUserOutput {
    await this.validateInput({ email, username });
    // Encrypt password
    const encryptedPassword = await this.authService.encryptPassword({ password });
    // Create user in database and return userId
    const userId = await this.repoUser.createUser({
      email,
      username,
      bio,
      image,
      hash: encryptedPassword
    });
    return userId;
  }

  private async validateInput({
    email,
    username
  }: ValidateInputInput): ValidateInputOutput {
    const { exists, emailExists } = await this.repoUser.getIsUserExists({
      email,
      username
    });
    if (exists) {
      throw new UserExistError({
        type: emailExists ? 'email' : 'username'
      });
    }
  }
}

================
File: packages/core/service/user/implementations/CreateUserHandler/index.ts
================
export { CreateUserHandler } from './CreateUserHandler';
export { CreateUserInput, CreateUserOutput } from './types';

================
File: packages/core/service/user/implementations/CreateUserHandler/types.ts
================
import { RepoUser } from '@conduit/core/repository';
import { AuthService } from '@conduit/core/service';

export interface CreateUserHandlerConstructor {
  repoUser: RepoUser;
  authService: AuthService;
}

export interface CreateUserInput {
  email: string;
  username: string;
  password: string;
  image?: string;
  bio?: string;
}

export type CreateUserOutput = Promise<string>;

/**
 *
 * function: validateInput
 *
 */
export interface ValidateInputInput {
  email: string;
  username: string;
}

export type ValidateInputOutput = Promise<void>;

================
File: packages/core/service/user/implementations/FollowHandler/FollowHandler.ts
================
import { RepoUser } from '@conduit/core/repository';

import { InvalidFollowError, UserNotFoundError } from '../../errors';
import {
  FollowHandlerConstructor,
  FollowUserInput,
  FollowUserOutput,
  UnfollowUserInput,
  UnfollowUserOutput
} from './types';

export class FollowHandler {
  private readonly repoUser: RepoUser;

  constructor({ repoUser }: FollowHandlerConstructor) {
    this.repoUser = repoUser;
  }

  async followUser({
    followerId,
    followingUsername
  }: FollowUserInput): FollowUserOutput {
    const profile = await this.repoUser.getUserProfile({
      username: followingUsername,
      requestingUserId: followerId
    });
    if (!profile) {
      throw new UserNotFoundError({ message: 'The requested user was not found.' });
    }
    if (followerId === profile.id) {
      throw new InvalidFollowError({ message: 'You cannot follow yourself' });
    }
    if (profile.following) {
      throw new InvalidFollowError({
        message: 'You are already following this user'
      });
    }
    await this.repoUser.followUser({ followerId, followingId: profile.id });
  }

  async unfollowUser({
    followerId,
    followingUsername
  }: UnfollowUserInput): UnfollowUserOutput {
    const profile = await this.repoUser.getUserProfile({
      username: followingUsername,
      requestingUserId: followerId
    });
    if (!profile) {
      throw new UserNotFoundError({ message: 'The requested user was not found.' });
    }
    if (followerId === profile.id) {
      throw new InvalidFollowError({ message: 'You cannot unfollow yourself' });
    }
    if (!profile.following) {
      throw new InvalidFollowError({ message: 'You are not following this user' });
    }
    await this.repoUser.unfollowUser({ followerId, followingId: profile.id });
  }
}

================
File: packages/core/service/user/implementations/FollowHandler/index.ts
================
export { FollowHandler } from './FollowHandler';
export {
  FollowUserInput,
  FollowUserOutput,
  UnfollowUserInput,
  UnfollowUserOutput
} from './types';

================
File: packages/core/service/user/implementations/FollowHandler/types.ts
================
import { RepoUser } from '@conduit/core/repository';

export interface FollowHandlerConstructor {
  repoUser: RepoUser;
}

/**
 *
 * function: followUser
 *
 */
export interface FollowUserInput {
  followerId: string;
  followingUsername: string;
}

export type FollowUserOutput = Promise<void>;

/**
 *
 * function: unfollowUser
 *
 */
export interface UnfollowUserInput {
  followerId: string;
  followingUsername: string;
}

export type UnfollowUserOutput = Promise<void>;

================
File: packages/core/service/user/implementations/index.ts
================
export * from './CreateUserHandler';
export * from './UpdateUserHandler';
export * from './FollowHandler';

================
File: packages/core/service/user/implementations/UpdateUserHandler/index.ts
================
export { UpdateUserHandler } from './UpdateUserHandler';
export { UpdateUserInput, UpdateUserOutput } from './types';

================
File: packages/core/service/user/implementations/UpdateUserHandler/types.ts
================
import { RepoUser } from '@conduit/core/repository';
import { AuthService } from '@conduit/core/service';

export interface UpdateUserHandlerConstructor {
  authService: AuthService;
  repoUser: RepoUser;
}

export interface UpdateUserInput {
  id: string;
  email?: string;
  username?: string;
  password?: string;
  image?: string;
  bio?: string;
}

export type UpdateUserOutput = Promise<void>;

/**
 *
 * function: validateUserExistInput
 *
 */
export interface ValidateUserExistInput {
  userId: string;
  email: string;
  username: string;
}

export type ValidateUserExistOutput = Promise<void>;

================
File: packages/core/service/user/implementations/UpdateUserHandler/UpdateUserHandler.ts
================
import { RepoUser } from '@conduit/core/repository';
import { AuthService } from '@conduit/core/service';

import { UserError, UserExistError, UserNotFoundError } from '../../errors';
import {
  UpdateUserHandlerConstructor,
  UpdateUserInput,
  UpdateUserOutput,
  ValidateUserExistInput,
  ValidateUserExistOutput
} from './types';

export class UpdateUserHandler {
  private authService: AuthService;
  private repoUser: RepoUser;

  constructor({ authService, repoUser }: UpdateUserHandlerConstructor) {
    this.authService = authService;
    this.repoUser = repoUser;
  }

  async execute({
    id,
    email,
    username,
    password,
    image,
    bio
  }: UpdateUserInput): UpdateUserOutput {
    const user = await this.repoUser.getUserById({ id });
    if (!user) {
      throw new UserNotFoundError({});
    }

    await this.validateUserExist({
      userId: id,
      email: email ?? user.email,
      username: username ?? user.username
    });

    const hash = password
      ? await this.authService.encryptPassword({ password })
      : undefined;

    await this.repoUser.updateUserById({
      id,
      email,
      username,
      hash,
      image,
      bio
    });
  }

  private async validateUserExist({
    userId,
    email,
    username
  }: ValidateUserExistInput): ValidateUserExistOutput {
    const { exists, emailExists, usernameExists } =
      await this.repoUser.getIsUserExists({
        userId,
        email,
        username
      });
    if (exists) {
      if (emailExists) {
        throw new UserExistError({ type: 'email' });
      }
      if (usernameExists) {
        throw new UserExistError({ type: 'username' });
      }
      throw new UserError({ message: 'User already exists' });
    }
  }
}

================
File: packages/core/service/user/index.ts
================
export { UserService } from './UserService';
export * from './errors';

================
File: packages/core/service/user/types.ts
================
import { RepoUser } from '@conduit/core/repository';

import { AuthService } from '../auth';

export interface UserServiceConstructor {
  repoUser: RepoUser;
  authService: AuthService;
}

================
File: packages/core/service/user/UserService.ts
================
import { RepoUser } from '@conduit/core/repository';
import {
  GetUserByEmailInput,
  GetUserByEmailOutput,
  GetUserByIdInput,
  GetUserByIdOutput,
  GetUserProfileInput,
  GetUserProfileOutput
} from '@conduit/core/repository/RepoUser/types';

import {
  CreateUserHandler,
  CreateUserInput,
  CreateUserOutput,
  FollowHandler,
  FollowUserInput,
  FollowUserOutput,
  UnfollowUserInput,
  UnfollowUserOutput,
  UpdateUserHandler,
  UpdateUserInput,
  UpdateUserOutput
} from './implementations';
import { UserServiceConstructor } from './types';

export class UserService {
  private repoUser: RepoUser;
  private createUserHandler: CreateUserHandler;
  private updateUserHandler: UpdateUserHandler;
  private followHandler: FollowHandler;

  constructor({ repoUser, authService }: UserServiceConstructor) {
    this.repoUser = repoUser;
    this.createUserHandler = new CreateUserHandler({ repoUser, authService });
    this.updateUserHandler = new UpdateUserHandler({ repoUser, authService });
    this.followHandler = new FollowHandler({ repoUser });
  }

  async getUserProfile(input: GetUserProfileInput): GetUserProfileOutput {
    return this.repoUser.getUserProfile(input);
  }

  async getUserById({ id }: GetUserByIdInput): GetUserByIdOutput {
    return this.repoUser.getUserById({ id });
  }

  async getUserByEmail({ email }: GetUserByEmailInput): GetUserByEmailOutput {
    return this.repoUser.getUserByEmail({ email });
  }

  async updateUserById(input: UpdateUserInput): UpdateUserOutput {
    await this.updateUserHandler.execute(input);
  }

  async createUser(input: CreateUserInput): CreateUserOutput {
    return this.createUserHandler.createUser(input);
  }

  async followUser(input: FollowUserInput): FollowUserOutput {
    return this.followHandler.followUser(input);
  }

  async unfollowUser(input: UnfollowUserInput): UnfollowUserOutput {
    return this.followHandler.unfollowUser(input);
  }
}

================
File: packages/core/tests/article/comment.spec.ts
================
import assert from 'assert';
import { Chance } from 'chance';

import { ArticleNotFoundError, ServiceFactory } from '@conduit/core';
import { dangerouslyResetDb } from '@conduit/core/database';

describe('Article Service - Article Comment', () => {
  describe('Create Article Comment', () => {
    it('should be able to add comment to an article', async () => {
      const { articleService, userId, articleId } = await setup();

      const commentId = await articleService.createArticleComment({
        articleId,
        userId,
        body: 'This is a comment'
      });

      const comment = await articleService.getArticleCommentById({ id: commentId });
      assert(comment);
      expect(comment.body).toBe('This is a comment');
    });

    it('should throw an error if the article does not exist', async () => {
      const { articleService, userId } = await setup();

      await expect(
        articleService.createArticleComment({
          articleId: 'non-existing-article-id',
          userId,
          body: 'This is a comment'
        })
      ).rejects.toThrow(ArticleNotFoundError);
    });

    it('should throw an error when trying to add a comment to a deleted article', async () => {
      const { articleService, userId, articleId } = await setup();

      await articleService.deleteArticleById({ id: articleId });

      await expect(
        articleService.createArticleComment({
          articleId,
          userId,
          body: 'This is a comment'
        })
      ).rejects.toThrow(ArticleNotFoundError);
    });
  });

  describe('Delete comment', () => {
    it('should be able to delete the comment', async () => {
      const { articleService, userId, articleId } = await setup();

      const commentId = await articleService.createArticleComment({
        articleId,
        userId,
        body: 'This is a comment'
      });

      let response = await articleService.getArticleCommentsByArticleId({
        articleId,
        limit: 10,
        offset: 0
      });
      expect(response.count).toBe(1);

      await articleService.deleteArticleCommentById({ id: commentId });

      response = await articleService.getArticleCommentsByArticleId({
        articleId,
        limit: 10,
        offset: 0
      });
      expect(response.count).toBe(0);
    });
  });

  describe('Retrieve comments', () => {
    it('should be able to get comments from an article', async () => {
      const { articleService, userId, articleId } = await setup();

      await articleService.createArticleComment({
        articleId,
        userId,
        body: 'This is a comment'
      });

      await articleService.createArticleComment({
        articleId,
        userId,
        body: 'This is a comment'
      });

      const response = await articleService.getArticleCommentsByArticleId({
        articleId,
        limit: 10,
        offset: 0
      });
      expect(response.count).toBe(2);
      expect(response.comments.length).toBe(2);
    });

    it('should not be possible to retrieve the deleted comments from an article', async () => {
      const { articleService, userId, articleId } = await setup();

      const commentId = await articleService.createArticleComment({
        articleId,
        userId,
        body: 'This is a comment'
      });

      let response = await articleService.getArticleCommentsByArticleId({
        articleId,
        limit: 10,
        offset: 0
      });
      expect(response.count).toBe(1);

      await articleService.deleteArticleCommentById({ id: commentId });

      response = await articleService.getArticleCommentsByArticleId({
        articleId,
        limit: 10,
        offset: 0
      });
      expect(response.count).toBe(0);
    });
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const serviceFactory = new ServiceFactory();
  const userService = serviceFactory.newUserService();
  const articleService = serviceFactory.newArticleService();

  const userId = await userService.createUser({
    email: chance.email(),
    username: chance.word(),
    password: 'Abcd1234'
  });

  const articleId = await articleService.createArticle({
    title: chance.sentence(),
    description: chance.paragraph(),
    body: chance.paragraph(),
    userId
  });

  return {
    chance,
    userService,
    articleService,
    articleId,
    userId
  };
};

================
File: packages/core/tests/article/create-article.spec.ts
================
import { Chance } from 'chance';

import { ArticleTitleAlreadyTakenError, ServiceFactory } from '@conduit/core';
import { dangerouslyResetDb } from '@conduit/core/database';
import { RepoFactory } from '@conduit/core/repository';
import { CreateArticleHandler } from '@conduit/core/service/article/implementations';

describe('Article Service - Create Article', () => {
  it('should be able to create an article', async () => {
    const { createArticleHandler, chance, userId } = await setup();

    const articleId = await createArticleHandler.execute({
      title: chance.word(),
      description: chance.sentence(),
      body: chance.paragraph(),
      userId
    });

    expect(articleId).toBeDefined();
  });

  it('should not be able to create article with the same title as an existing article', async () => {
    const { createArticleHandler, chance, userId } = await setup();

    const title = chance.word();
    await createArticleHandler.execute({
      title,
      description: chance.sentence(),
      body: chance.paragraph(),
      userId
    });

    try {
      await createArticleHandler.execute({
        title,
        description: chance.sentence(),
        body: chance.paragraph(),
        userId
      });
    } catch (error) {
      expect(error).toBeInstanceOf(ArticleTitleAlreadyTakenError);
    }
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const repoFactory = new RepoFactory();
  const serviceFactory = new ServiceFactory();
  const repoArticle = repoFactory.newRepoArticle();
  const createArticleHandler = new CreateArticleHandler({ repoArticle });

  const userService = serviceFactory.newUserService();
  const userId = await userService.createUser({
    username: chance.word(),
    email: chance.email(),
    password: 'Abcd1234'
  });

  return { chance, createArticleHandler, repoArticle, userId };
};

================
File: packages/core/tests/article/favorite.spec.ts
================
import assert from 'assert';
import { Chance } from 'chance';

import {
  ArticleAlreadyFavoritedError,
  ArticleNotYetFavoritedError,
  ServiceFactory
} from '@conduit/core';
import { dangerouslyResetDb } from '@conduit/core/database';
import { RepoFactory } from '@conduit/core/repository';

describe('Article Service - Favorite Article', () => {
  describe('Favorite an Article', () => {
    it('should be able to favorite an article', async () => {
      const { articleService, articleAId, userBId } = await setup();
      await articleService.favoriteArticle({
        articleId: articleAId,
        userId: userBId
      });

      const article = await articleService.getArticleById({
        id: articleAId,
        requestingUserId: userBId
      });
      assert(article);
      expect(article.favorited).toBe(true);
      expect(article.favoritesCount).toBe(1);
    });

    it('should throw an error if the user tries to favorite an article that has already been favorited', async () => {
      const { articleService, articleAId, userBId } = await setup();
      await articleService.favoriteArticle({
        articleId: articleAId,
        userId: userBId
      });

      try {
        await articleService.favoriteArticle({
          articleId: articleAId,
          userId: userBId
        });
      } catch (error) {
        expect(error).toBeInstanceOf(ArticleAlreadyFavoritedError);
      }
    });
  });

  describe('Unfavorite an Article', () => {
    it('should be able to unfavorite an article', async () => {
      const { articleService, articleAId, userBId } = await setup();

      await articleService.favoriteArticle({
        articleId: articleAId,
        userId: userBId
      });

      await articleService.unfavoriteArticle({
        articleId: articleAId,
        userId: userBId
      });

      const article = await articleService.getArticleById({
        id: articleAId,
        requestingUserId: userBId
      });
      assert(article);
      expect(article.favorited).toBe(false);
      expect(article.favoritesCount).toBe(0);
    });

    it('should throw an error if the user tries to unfavorite an article that has already been unfavorited', async () => {
      const { articleService, articleAId, userBId } = await setup();

      try {
        await articleService.unfavoriteArticle({
          articleId: articleAId,
          userId: userBId
        });
      } catch (error) {
        expect(error).toBeInstanceOf(ArticleNotYetFavoritedError);
      }

      const article = await articleService.getArticleById({
        id: articleAId,
        requestingUserId: userBId
      });

      assert(article);
      expect(article.favorited).toBe(false);
      expect(article.favoritesCount).toBe(0);
    });
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const repoFactory = new RepoFactory();
  const serviceFactory = new ServiceFactory();
  const repoArticle = repoFactory.newRepoArticle();

  const articleService = serviceFactory.newArticleService();
  const userService = serviceFactory.newUserService();

  const userAId = await userService.createUser({
    username: chance.word(),
    email: chance.email(),
    password: 'Abcd1234'
  });

  const userBId = await userService.createUser({
    username: chance.word(),
    email: chance.email(),
    password: 'Abcd1234'
  });

  const articleAId = await articleService.createArticle({
    title: chance.word(),
    body: chance.paragraph(),
    description: chance.sentence(),
    userId: userAId
  });

  return { chance, articleService, repoArticle, userAId, userBId, articleAId };
};

================
File: packages/core/tests/article/get-article.spec.ts
================
import assert from 'assert';
import { Chance } from 'chance';

import { ServiceFactory } from '@conduit/core';
import { dangerouslyResetDb } from '@conduit/core/database';
import { RepoFactory } from '@conduit/core/repository';
import { CreateArticleHandler } from '@conduit/core/service/article/implementations';

describe('Article Repository - Get Article', () => {
  it('should be able to get the details of an article by slug', async () => {
    const { createArticleHandler, userId, repoArticle } = await setup();
    const title = 'hello-world';
    const description = 'This is a description';
    const body = 'This is the body';

    const articleId = await createArticleHandler.execute({
      title,
      description,
      body,
      userId
    });

    const article = await repoArticle.getArticleBySlug({ slug: title });

    assert(article);
    expect(article.id).toBe(articleId);
    expect(article.title).toBe(title);
    expect(article.description).toBe(description);
    expect(article.body).toBe(body);
    expect(article.author.id).toBe(userId);
    expect(article.author.following).toBeFalsy();
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const repoFactory = new RepoFactory();
  const serviceFactory = new ServiceFactory();
  const repoArticle = repoFactory.newRepoArticle();
  const createArticleHandler = new CreateArticleHandler({ repoArticle });

  const userService = serviceFactory.newUserService();
  const userId = await userService.createUser({
    username: chance.word(),
    email: chance.email(),
    password: 'Abcd1234'
  });

  return { chance, createArticleHandler, repoArticle, userId };
};

================
File: packages/core/tests/article/list.spec.ts
================
import assert from 'assert';
import { Chance } from 'chance';
import pMap from 'p-map';

import { ServiceFactory } from '@conduit/core';
import { dangerouslyResetDb } from '@conduit/core/database';

describe('Article Repository - List Articles', () => {
  it('should be able to return a list of articles', async () => {
    const { articleService, userId } = await setup();

    await pMap(
      new Array(10),
      async (_, index) => {
        await articleService.createArticle({
          title: `title-${index}`,
          description: `description-${index}`,
          body: `body-${index}`,
          userId
        });
      },
      { concurrency: 1, stopOnError: true }
    );

    const articles = await articleService.getArticles({
      limit: 10,
      offset: 0
    });

    expect(articles.length).toBe(10);
    const count = await articleService.countArticles({});
    expect(count).toBe(10);
  });

  it('should be able to return a filtered article list by tags', async () => {
    const { articleService, userId } = await setup();

    const ids = await pMap(
      new Array(10),
      async (_, index) => {
        const id = await articleService.createArticle({
          title: `title-${index}`,
          description: `description-${index}`,
          body: `body-${index}`,
          userId
        });
        return id;
      },
      { concurrency: 1, stopOnError: true }
    );

    assert(ids[0]);

    await articleService.createArticleTags({
      articleId: ids[0],
      tagList: ['tag1', 'tag2']
    });

    const articles = await articleService.getArticles({ tags: ['tag1'] });
    expect(articles.length).toBe(1);

    const count = await articleService.countArticles({ tags: ['tag1'] });
    expect(count).toBe(1);
  });

  it("should be able to return a filtered article list by the author's name", async () => {
    const { articleService, userService, chance } = await setup();

    const usernameA = 'userA';
    const usernameB = 'userB';

    const userIdA = await userService.createUser({
      username: usernameA,
      email: chance.email(),
      password: 'Abcd1234'
    });

    const userIdB = await userService.createUser({
      username: usernameB,
      email: chance.email(),
      password: 'Abcd1234'
    });

    await articleService.createArticle({
      title: 'title-1',
      description: 'description-1',
      body: 'body-1',
      userId: userIdA
    });

    await articleService.createArticle({
      title: 'title-2',
      description: 'description-2',
      body: 'body-2',
      userId: userIdB
    });

    const articles = await articleService.getArticles({ author: usernameA });
    expect(articles.length).toBe(1);

    const count = await articleService.countArticles({ author: usernameA });
    expect(count).toBe(1);
  });

  it('should be able to return a filtered article list that is favorited by user', async () => {
    const { articleService, userService, chance } = await setup();

    const usernameA = 'userA';
    const usernameB = 'userB';

    const userIdA = await userService.createUser({
      username: usernameA,
      email: chance.email(),
      password: 'Abcd1234'
    });

    const userIdB = await userService.createUser({
      username: usernameB,
      email: chance.email(),
      password: 'Abcd1234'
    });

    const articleId = await articleService.createArticle({
      title: 'title-1',
      description: 'description-1',
      body: 'body-1',
      userId: userIdA
    });

    await articleService.favoriteArticle({
      userId: userIdB,
      articleId
    });

    const articles = await articleService.getArticles({ favorited: usernameB });
    expect(articles.length).toBe(1);

    const count = await articleService.countArticles({ favorited: usernameB });
    expect(count).toBe(1);
  });

  it('should return an empty list if no articles match the filter parameters', async () => {
    const { articleService, userId } = await setup();

    await pMap(
      new Array(10),
      async (_, index) => {
        await articleService.createArticle({
          title: `title-${index}`,
          description: `description-${index}`,
          body: `body-${index}`,
          userId
        });
      },
      { concurrency: 1, stopOnError: true }
    );

    const articles = await articleService.getArticles({
      limit: 10,
      offset: 0,
      tags: ['non-existent-tag']
    });
    expect(articles.length).toBe(0);

    const count = await articleService.countArticles({
      tags: ['non-existent-tag']
    });
    expect(count).toBe(0);
  });

  it('should be able to limit the number of articles returned', async () => {
    const { articleService, userId } = await setup();

    await pMap(
      new Array(10),
      async (_, index) => {
        await articleService.createArticle({
          title: `title-${index}`,
          description: `description-${index}`,
          body: `body-${index}`,
          userId
        });
      },
      { concurrency: 1, stopOnError: true }
    );

    const articles = await articleService.getArticles({
      limit: 5,
      offset: 0
    });
    expect(articles.length).toBe(5);
  });

  it('should be able to paginate the articles using the offset parameter', async () => {
    const { articleService, userId } = await setup();

    await pMap(
      new Array(9),
      async (_, index) => {
        await articleService.createArticle({
          title: `title-${index}`,
          description: `description-${index}`,
          body: `body-${index}`,
          userId
        });
      },
      { concurrency: 1, stopOnError: true }
    );

    const articles = await articleService.getArticles({
      limit: 5,
      offset: 0
    });
    expect(articles.length).toBe(5);

    const articles2 = await articleService.getArticles({
      limit: 5,
      offset: 1
    });
    expect(articles2.length).toBe(4);

    const articles3 = await articleService.getArticles({
      limit: 5,
      offset: 2
    });
    expect(articles3.length).toBe(0);
  });

  it('should be able to remove articles from the feed when the user unfollows another user', async () => {
    const { articleService, userService, chance } = await setup();

    const usernameA = 'userA';
    const usernameB = 'userB';

    const userIdA = await userService.createUser({
      username: usernameA,
      email: chance.email(),
      password: 'Abcd1234'
    });

    const userIdB = await userService.createUser({
      username: usernameB,
      email: chance.email(),
      password: 'Abcd1234'
    });

    await userService.followUser({
      followerId: userIdA,
      followingUsername: usernameB
    });

    await articleService.createArticle({
      title: 'title-1',
      description: 'description-1',
      body: 'body-1',
      userId: userIdB
    });

    const articles = await articleService.getArticles({ followedBy: userIdA });
    const count = await articleService.countArticles({ followedBy: userIdA });

    expect(articles.length).toBe(1);
    expect(count).toBe(1);

    await userService.unfollowUser({
      followerId: userIdA,
      followingUsername: usernameB
    });

    const articles2 = await articleService.getArticles({ followedBy: userIdA });
    const count2 = await articleService.countArticles({ followedBy: userIdA });

    expect(articles2.length).toBe(0);
    expect(count2).toBe(0);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const serviceFactory = new ServiceFactory();

  const username = chance.word();

  const userService = serviceFactory.newUserService();

  const userId = await userService.createUser({
    username,
    email: chance.email(),
    password: 'Abcd1234'
  });

  const articleService = serviceFactory.newArticleService();

  return {
    chance,
    username,
    userService,
    articleService,
    userId
  };
};

================
File: packages/core/tests/article/tags.spec.ts
================
import assert from 'assert';
import { Chance } from 'chance';

import { ArticleNotFoundError, RecordStatus, ServiceFactory } from '@conduit/core';
import { dangerouslyResetDb } from '@conduit/core/database';
import { RepoFactory } from '@conduit/core/repository';
import {
  CreateArticleHandler,
  CreateArticleTagsHandler
} from '@conduit/core/service/article/implementations';

import { knex } from '../../database/knex';

describe('Article Service - Article Tags', () => {
  it('should be able to create tags for an article', async () => {
    const { articleId, createArticleTagsHandler } = await setup();

    await createArticleTagsHandler.execute({
      articleId,
      tagList: ['tag1', 'tag2']
    });
  });

  it('should be able to return a list of tags for an article', async () => {
    const { repoArticle, articleId, createArticleTagsHandler } = await setup();

    await createArticleTagsHandler.execute({
      articleId,
      tagList: ['tag1', 'tag2']
    });

    const tags = await repoArticle.getTagsByArticleId({ articleId });
    expect(tags).toHaveLength(2);
    expect(tags.map((item) => item.tag)).toContain('tag1');
    expect(tags.map((item) => item.tag)).toContain('tag2');
  });

  it('should throw an error when attempting to retrieve tags from an article that has been deleted', async () => {
    const { articleId, createArticleTagsHandler } = await setup();

    await knex
      .table('article')
      .update({ record_status: RecordStatus.Deleted })
      .where({ article_id: articleId });

    try {
      await createArticleTagsHandler.execute({
        articleId,
        tagList: ['tag1', 'tag2']
      });
      assert.fail('Expected an error to be thrown');
    } catch (error) {
      expect(error).toBeInstanceOf(ArticleNotFoundError);
    }
  });

  it('should return all article tags for all articles that have not been deleted', async () => {
    const { createArticleTagsHandler, articleService, articleId } = await setup();

    await createArticleTagsHandler.execute({
      articleId,
      tagList: ['tag1', 'tag2']
    });

    let tags = await articleService.getAvailableTags();
    expect(tags).toHaveLength(2);

    await knex
      .table('article')
      .update({ record_status: RecordStatus.Deleted })
      .where({ article_id: articleId });

    tags = await articleService.getAvailableTags();
    expect(tags).toHaveLength(0);
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const repoFactory = new RepoFactory();
  const serviceFactory = new ServiceFactory();
  const repoArticle = repoFactory.newRepoArticle();
  const articleService = serviceFactory.newArticleService();
  const createArticleHandler = new CreateArticleHandler({ repoArticle });
  const createArticleTagsHandler = new CreateArticleTagsHandler({ repoArticle });

  const userService = serviceFactory.newUserService();
  const userId = await userService.createUser({
    username: chance.word(),
    email: chance.email(),
    password: 'Abcd1234'
  });
  const articleId = await createArticleHandler.execute({
    title: chance.word(),
    description: chance.sentence(),
    body: chance.paragraph(),
    userId
  });

  return {
    chance,
    repoArticle,
    articleId,
    createArticleTagsHandler,
    articleService
  };
};

================
File: packages/core/tests/article/update-article.spec.ts
================
import assert from 'assert';
import { Chance } from 'chance';

import { ArticleTitleAlreadyTakenError, ServiceFactory } from '@conduit/core';
import { dangerouslyResetDb } from '@conduit/core/database';
import { RepoFactory } from '@conduit/core/repository';
import {
  CreateArticleHandler,
  UpdateArticleHandler
} from '@conduit/core/service/article/implementations';

describe('Article Service - Update Article', () => {
  it('should be able to update the article', async () => {
    const { chance, updateArticleHandler, articleId, repoArticle } = await setup();

    const title = chance.word();
    const description = chance.sentence();
    const body = chance.paragraph();

    await updateArticleHandler.execute({
      id: articleId,
      title,
      description,
      body
    });

    const article = await repoArticle.getArticleById({ id: articleId });
    assert(!!article);

    expect(article.title).toBe(title);
    expect(article.description).toBe(description);
    expect(article.body).toBe(body);
  });

  it('should be able to update specific fields of an article, rather than requiring all fields to be updated', async () => {
    const { chance, updateArticleHandler, repoArticle, articleId } = await setup();

    const title = chance.word();

    await updateArticleHandler.execute({
      id: articleId,
      title
    });

    const article = await repoArticle.getArticleById({ id: articleId });
    assert(!!article);

    expect(article.title).toBe(title);
  });

  it('should throw an error if the title has already been used by another article', async () => {
    const { chance, updateArticleHandler, createArticleHandler, userId } =
      await setup();

    const title = chance.word();

    await createArticleHandler.execute({
      title,
      description: chance.sentence(),
      body: chance.paragraph(),
      userId
    });

    const articleId = await createArticleHandler.execute({
      title: chance.word(),
      description: chance.sentence(),
      body: chance.paragraph(),
      userId
    });

    try {
      await updateArticleHandler.execute({
        id: articleId,
        title
      });
      assert.fail('Should have thrown an error');
    } catch (error) {
      expect(error).toBeInstanceOf(ArticleTitleAlreadyTakenError);
    }
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const repoFactory = new RepoFactory();
  const serviceFactory = new ServiceFactory();
  const repoArticle = repoFactory.newRepoArticle();
  const createArticleHandler = new CreateArticleHandler({ repoArticle });
  const updateArticleHandler = new UpdateArticleHandler({ repoArticle });

  const userService = serviceFactory.newUserService();
  const userId = await userService.createUser({
    username: chance.word(),
    email: chance.email(),
    password: 'Abcd1234'
  });

  const articleId = await createArticleHandler.execute({
    title: chance.word(),
    description: chance.sentence(),
    body: chance.paragraph(),
    userId
  });

  return {
    chance,
    updateArticleHandler,
    createArticleHandler,
    repoArticle,
    userId,
    articleId
  };
};

================
File: packages/core/tests/auth/access-token.spec.ts
================
import assert from 'assert';
import { Chance } from 'chance';
import jsonwebtoken from 'jsonwebtoken';
import moment from 'moment';
import * as sinon from 'sinon';

import { InvalidTokenError } from '@conduit/core/service';
import { AccessTokenHandler } from '@conduit/core/service/auth/implementations';

describe('Auth Service - Access Token', () => {
  describe('Generate Access Token', () => {
    it('should able be to generate a valid access token', async () => {
      const { accessTokenHandler, chance } = await setup();
      const userId = chance.guid();
      const loginId = chance.guid();

      const accessToken = accessTokenHandler.generateAccessToken({
        userId,
        loginId
      });
      expect(accessToken).toBeDefined();

      const response = jsonwebtoken.decode(accessToken);
      expect(response).toBeDefined();

      const payload = response as any;
      expect(payload.userId).toBe(userId);
      expect(payload.jti).toBe(loginId);
    });
  });

  describe('Verify Access Token', () => {
    it('should be able to verify a valid access token', async () => {
      const { accessTokenHandler, chance } = await setup();
      const userId = chance.guid();
      const loginId = chance.guid();

      const accessToken = accessTokenHandler.generateAccessToken({
        userId,
        loginId
      });
      expect(accessToken).toBeDefined();

      const response = accessTokenHandler.verifyAccessToken({ accessToken });
      expect(response).toBe(userId);
    });

    it('should throw an error if the access token is invalid', async () => {
      const { accessTokenHandler, chance } = await setup();
      const accessToken = chance.string();

      try {
        accessTokenHandler.verifyAccessToken({ accessToken });
        assert.fail('Should have thrown an error');
      } catch (error) {
        expect(error).toBeInstanceOf(InvalidTokenError);
      }
    });

    it('should throw an error if the access token has expired', async () => {
      const { accessTokenHandler, chance } = await setup();
      const userId = chance.guid();
      const loginId = chance.guid();

      const accessToken = accessTokenHandler.generateAccessToken({
        userId,
        loginId
      });
      expect(accessToken).toBeDefined();

      sinon.useFakeTimers(moment().add(1, 'month').toDate());

      try {
        accessTokenHandler.verifyAccessToken({ accessToken });
        assert.fail('Should have thrown an error');
      } catch (error) {
        expect(error).toBeInstanceOf(InvalidTokenError);
      }
    });
  });

  describe('Generate Refresh Token', () => {
    it('should be able to generate a valid refresh token', async () => {
      const { accessTokenHandler, chance } = await setup();
      const userId = chance.guid();
      const loginId = chance.guid();

      const refreshToken = accessTokenHandler.generateRefreshToken({
        userId,
        loginId
      });
      expect(refreshToken).toBeDefined();

      const response = jsonwebtoken.decode(refreshToken);
      expect(response).toBeDefined();

      const payload = response as any;
      expect(payload.userId).toBe(userId);
      expect(payload.loginId).toBe(loginId);
    });
  });

  describe('Verify Refresh Token', () => {
    it('should be able to verify a valid refresh token', async () => {
      const { accessTokenHandler, chance } = await setup();
      const userId = chance.guid();
      const loginId = chance.guid();

      const refreshToken = accessTokenHandler.generateRefreshToken({
        userId,
        loginId
      });
      expect(refreshToken).toBeDefined();

      const response = accessTokenHandler.verifyRefreshToken({ refreshToken });
      expect(response).toBeDefined();
      expect(response.userId).toBe(userId);
      expect(response.loginId).toBe(loginId);
    });
  });

  afterEach(() => {
    sinon.restore();
  });
});

const setup = async () => {
  const chance = new Chance();
  const accessTokenHandler = new AccessTokenHandler();
  return { chance, accessTokenHandler };
};

================
File: packages/core/tests/auth/password.spec.ts
================
import assert from 'assert';
import { Chance } from 'chance';

import {
  PasswordNotMatchError,
  PasswordRequirementsNotMetError
} from '@conduit/core/service';
import { PasswordHandler } from '@conduit/core/service/auth/implementations';

describe('Auth - Password', () => {
  it("should throw an error if the password's length is less than 6", async () => {
    const { passwordHandler } = await setup();
    try {
      await passwordHandler.encryptPassword({ password: 'abc12' });
      assert.fail();
    } catch (error) {
      expect(error).toBeInstanceOf(PasswordRequirementsNotMetError);
      if (error instanceof PasswordRequirementsNotMetError) {
        expect(error.details).toHaveLength(1);
      }
    }
  });

  it("should throw an error if the password doesn't contain at least one digit or letter", async () => {
    const { passwordHandler } = await setup();
    try {
      await passwordHandler.encryptPassword({ password: 'abcdef' });
      assert.fail();
    } catch (error) {
      expect(error).toBeInstanceOf(PasswordRequirementsNotMetError);
      if (error instanceof PasswordRequirementsNotMetError) {
        expect(error.details).toHaveLength(1);
      }
    }
  });

  it("should throw an error if the length of the password is less than 6 characters and it doesn't contain at least one digit or letter", async () => {
    const { passwordHandler } = await setup();
    try {
      await passwordHandler.encryptPassword({ password: 'abcde' });
      assert.fail();
    } catch (error) {
      expect(error).toBeInstanceOf(PasswordRequirementsNotMetError);
      if (error instanceof PasswordRequirementsNotMetError) {
        expect(error.details).toHaveLength(2);
      }
    }
  });

  it('should be able to encrypt a password securely', async () => {
    const { passwordHandler } = await setup();
    const hash = await passwordHandler.encryptPassword({ password: '123abc' });
    expect(hash).toBeDefined();
  });

  it('should be able to encrypt and then verify a password', async () => {
    const { passwordHandler } = await setup();
    const password = '123abc';
    const hash = await passwordHandler.encryptPassword({ password });
    expect(hash).toBeDefined();
    await passwordHandler.comparePassword({ password, encryptedPassword: hash });
  });

  it('should throw an error if the password is incorrect', async () => {
    const { passwordHandler } = await setup();
    const password = '123abc';
    const hash = await passwordHandler.encryptPassword({ password });
    expect(hash).toBeDefined();
    try {
      await passwordHandler.comparePassword({ password, encryptedPassword: hash });
    } catch (error) {
      expect(error).toBeInstanceOf(PasswordNotMatchError);
    }
  });
});

const setup = async () => {
  const chance = new Chance();
  const passwordHandler = new PasswordHandler();
  return { chance, passwordHandler };
};

================
File: packages/core/tests/user/create-user.spec.ts
================
import assert from 'assert';
import { Chance } from 'chance';

import { ServiceFactory, UserExistError, UserStatus } from '@conduit/core';
import { dangerouslyResetDb } from '@conduit/core/database';
import { RepoFactory } from '@conduit/core/repository';
import { CreateUserHandler } from '@conduit/core/service/user/implementations';

describe('User Service - Create User', () => {
  it('should be able to create an user', async () => {
    const { createUserHandler, chance, repoUser } = await setup();
    const username = chance.word();
    const email = chance.email();
    const password = 'Abcd1234';

    const userId = await createUserHandler.createUser({
      username,
      email,
      password
    });

    const user = await repoUser.getUserById({ id: userId });
    assert(!!user);

    expect(user).toBeDefined();
    expect(user.username).toEqual(username);
    expect(user.email).toEqual(email);
    expect(user.recordStatus).toEqual(UserStatus.Active);
    expect(user.bio).toBeNull();
    expect(user.image).toBeNull();
  });

  it('should throw an error if the username is already taken', async () => {
    const { createUserHandler, chance } = await setup();
    const username = chance.word();
    const email = chance.email();
    const password = 'Abcd1234';

    await createUserHandler.createUser({
      username,
      email,
      password
    });

    try {
      await createUserHandler.createUser({
        username,
        email: chance.email(),
        password
      });
      assert.fail('Should have thrown an error');
    } catch (error) {
      expect(error).toBeInstanceOf(UserExistError);
    }
  });

  it('should throw an error if the email has already been used', async () => {
    const { createUserHandler, chance } = await setup();
    const username = chance.word();
    const email = chance.email();
    const password = 'Abcd1234';

    await createUserHandler.createUser({
      username,
      email,
      password
    });

    try {
      await createUserHandler.createUser({
        username: chance.word(),
        email,
        password
      });
      assert.fail('Should have thrown an error');
    } catch (error) {
      expect(error).toBeInstanceOf(UserExistError);
    }
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const repoFactory = new RepoFactory();
  const serviceFactory = new ServiceFactory();
  const repoUser = repoFactory.newRepoUser();
  const authService = serviceFactory.newAuthService();
  const createUserHandler = new CreateUserHandler({ repoUser, authService });
  return { chance, createUserHandler, repoUser };
};

================
File: packages/core/tests/user/following.spec.ts
================
import assert from 'assert';
import { Chance } from 'chance';

import { InvalidFollowError, ServiceFactory } from '@conduit/core';
import { dangerouslyResetDb } from '@conduit/core/database';
import { RepoFactory } from '@conduit/core/repository';
import {
  CreateUserHandler,
  FollowHandler
} from '@conduit/core/service/user/implementations';

describe('User Service - Following', () => {
  describe('Follow an User', () => {
    it('should be able to follow an user', async () => {
      const { followHandler, userAId, userBUsername, repoUser } = await setup();

      await followHandler.followUser({
        followerId: userAId,
        followingUsername: userBUsername
      });

      const userB = await repoUser.getUserProfile({
        username: userBUsername,
        requestingUserId: userAId
      });

      assert(userB);
      expect(userB.following).toBe(true);
    });

    it('should throw an error if the user is already following the targeted user', async () => {
      const { followHandler, userAId, userBUsername } = await setup();

      await followHandler.followUser({
        followerId: userAId,
        followingUsername: userBUsername
      });

      try {
        await followHandler.followUser({
          followerId: userAId,
          followingUsername: userBUsername
        });
      } catch (error) {
        expect(error).toBeInstanceOf(InvalidFollowError);
      }
    });

    it('should throw an error if the user is trying to follow themselves', async () => {
      const { followHandler, userAId, userAUsername } = await setup();

      try {
        await followHandler.followUser({
          followerId: userAId,
          followingUsername: userAUsername
        });
      } catch (error) {
        expect(error).toBeInstanceOf(InvalidFollowError);
      }
    });
  });

  describe('Unfollow an User', () => {
    it('should be able to unfollow an user', async () => {
      const { followHandler, userAId, userBUsername, repoUser } = await setup();

      await followHandler.followUser({
        followerId: userAId,
        followingUsername: userBUsername
      });

      await followHandler.unfollowUser({
        followerId: userAId,
        followingUsername: userBUsername
      });

      const userB = await repoUser.getUserProfile({
        username: userBUsername,
        requestingUserId: userAId
      });

      assert(userB);
      expect(userB.following).toBe(false);
    });

    it('should throw an error if the user is trying to unfollow a user that they are not currently following', async () => {
      const { followHandler, userAId, userBUsername } = await setup();

      try {
        await followHandler.unfollowUser({
          followerId: userAId,
          followingUsername: userBUsername
        });
      } catch (error) {
        expect(error).toBeInstanceOf(InvalidFollowError);
      }
    });
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const repoFactory = new RepoFactory();
  const serviceFactory = new ServiceFactory();
  const authService = serviceFactory.newAuthService();
  const repoUser = repoFactory.newRepoUser();
  const followHandler = new FollowHandler({ repoUser });
  const createUserHandler = new CreateUserHandler({ repoUser, authService });

  const userAUsername = chance.word();

  const userAId = await createUserHandler.createUser({
    username: userAUsername,
    email: chance.email(),
    password: 'Abcd1234'
  });

  const userBUsername = chance.word();

  const userBId = await createUserHandler.createUser({
    username: userBUsername,
    email: chance.email(),
    password: 'Abcd1234'
  });

  return {
    chance,
    followHandler,
    repoUser,
    userAId,
    userAUsername,
    userBId,
    userBUsername
  };
};

================
File: packages/core/tests/user/update-user.spec.ts
================
import assert from 'assert';
import { Chance } from 'chance';

import { ServiceFactory, UserExistError } from '@conduit/core';
import { dangerouslyResetDb } from '@conduit/core/database';
import { RepoFactory } from '@conduit/core/repository';
import { UpdateUserHandler } from '@conduit/core/service/user/implementations';

describe('User Service - Update User', () => {
  it('should be able to update the user', async () => {
    const { updateUserHandler, userABody, userAId, chance, repoUser } =
      await setup();
    const email = chance.email();
    const bio = chance.sentence();
    const image = chance.url();

    await updateUserHandler.execute({
      id: userAId,
      email,
      bio,
      image
    });

    const user = await repoUser.getUserById({ id: userAId });

    assert(!!user);
    expect(user).toBeDefined();
    expect(user.username).toEqual(userABody.username);
    expect(user.email).toEqual(email);
    expect(user.bio).toEqual(bio);
    expect(user.image).toEqual(image);
  });

  it('should be able to update only the provided fields', async () => {
    const { updateUserHandler, userABody, userAId, chance, repoUser } =
      await setup();
    const email = chance.email();
    const image = chance.url();

    await updateUserHandler.execute({
      id: userAId,
      email,
      image
    });

    const user = await repoUser.getUserById({ id: userAId });

    assert(!!user);
    expect(user).toBeDefined();
    expect(user.username).toEqual(userABody.username);
    expect(user.email).toEqual(email);
    expect(user.bio).toBeNull();
    expect(user.image).toEqual(image);
  });

  it('should throw an error if user tries to update their email with an existing username', async () => {
    const { updateUserHandler, userAId, userBBody } = await setup();

    try {
      await updateUserHandler.execute({
        id: userAId,
        email: userBBody.email
      });
      assert.fail('Should have thrown an error');
    } catch (error) {
      expect(error).toBeInstanceOf(UserExistError);
    }
  });

  it('should throw an error if user tries to update their email with an existing email address', async () => {
    const { updateUserHandler, userAId, userBBody } = await setup();

    try {
      await updateUserHandler.execute({
        id: userAId,
        email: userBBody.email
      });
      assert.fail('Should have thrown an error');
    } catch (error) {
      expect(error).toBeInstanceOf(UserExistError);
    }
  });

  beforeEach(() => dangerouslyResetDb());
});

const setup = async () => {
  const chance = new Chance();
  const repoFactory = new RepoFactory();
  const serviceFactory = new ServiceFactory();
  const repoUser = repoFactory.newRepoUser();
  const authService = serviceFactory.newAuthService();
  const userService = serviceFactory.newUserService();
  const updateUserHandler = new UpdateUserHandler({ repoUser, authService });

  const userABody = {
    username: chance.word(),
    email: chance.email(),
    password: 'Abcd1234'
  };

  const userBBody = {
    username: chance.word(),
    email: chance.email(),
    password: 'Abcd1234'
  };

  const userAId = await userService.createUser(userABody);
  const userBId = await userService.createUser(userBBody);

  return {
    chance,
    updateUserHandler,
    repoUser,
    userABody,
    userAId,
    userBBody,
    userBId
  };
};

================
File: packages/core/tsconfig.json
================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "@conduit/config/tsconfig.base.json",
  "compilerOptions": {
    "sourceMap": false,
    "outDir": "./",
    "paths": {
      "@conduit/core/*": ["./*"]
    }
  },
  "include": ["./**/*.ts"],
  "paths": {
    "@conduit/core/*": ["./*"]
  }
}

================
File: packages/core/types/global.d.ts
================
import { DbDtoUser } from '@conduit/core';

declare global {
  namespace Express {
    interface Request {
      user?: DbDtoUser;
    }
  }
}

// If this file has no import/export statements (i.e. is a script)
// convert it into a module by adding an empty export statement.
export {};

================
File: packages/core/types/index.ts
================
export * from './UserStatus';
export * from './RecordStatus';

================
File: packages/core/types/RecordStatus.ts
================
export enum RecordStatus {
  Active = 'active',
  Deleted = 'deleted'
}

================
File: packages/core/types/UserStatus.ts
================
export enum UserStatus {
  Active = 'active',
  Banned = 'banned'
}

================
File: packages/core/utils/error/AppError/AppError.ts
================
import stringify from 'fast-json-stable-stringify';
import { serializeError } from 'serialize-error';

import { AppErrorProps } from './types';

export class AppError extends Error {
  public readonly code?: string;
  public readonly details?: any[];
  public readonly cause?: Error;

  constructor(props: AppErrorProps) {
    super(props.message);
    this.code = props.code;
    this.details = props.details;
    this.cause = props.cause;
  }

  static assert(
    condition: boolean,
    code?: string,
    message?: string,
    details?: any[]
  ): asserts condition {
    if (!condition) {
      throw new AppError({
        message,
        code,
        details
      });
    }
  }

  public toJSON() {
    return stringify(serializeError(this));
  }
}

================
File: packages/core/utils/error/AppError/index.ts
================
export { AppError } from './AppError';

================
File: packages/core/utils/error/AppError/types.ts
================
export interface AppErrorProps {
  message?: string;
  code?: string;
  details?: any[];
  cause?: Error;
}

================
File: packages/core/utils/error/index.ts
================
export { AppError } from './AppError';

================
File: packages/core/utils/getObjectId.ts
================
import { v4 } from 'uuid';

export const getObjectId = () => v4();

================
File: packages/core/utils/index.ts
================
export * from './error';
export * from './getObjectId';

================
File: packages/middleware/.eslintrc.js
================
const defaultConfig = require('@conduit/config/.eslintrc.json');

module.exports = {
  ...defaultConfig,
  parserOptions: {
    project: './tsconfig.json'
  }
};

================
File: packages/middleware/.prettierrc.cjs
================
module.exports = require('@conduit/config/.prettierrc.json');

================
File: packages/middleware/auth.ts
================
import { RequestHandler } from 'express';

import { InvalidTokenError, ServiceFactory, UserStatus } from '@conduit/core';
import {
  ApiErrorForbidden,
  ApiErrorInternalServerError,
  ApiErrorUnauthorized
} from '@conduit/utils';

const serviceFactory = new ServiceFactory();
const authService = serviceFactory.newAuthService();
const userService = serviceFactory.newUserService();

export const auth: RequestHandler<unknown, unknown, unknown, unknown> = async (
  req,
  _res,
  next
) => {
  const { authorization } = req.headers;

  // Early return if no authorization header is present in the request headers
  if (authorization === undefined) {
    return next();
  }

  const [policy, accessToken] = authorization.split(' ');

  if (!policy || policy.toLowerCase() !== 'bearer' || !accessToken) {
    throw new ApiErrorUnauthorized({
      errorCode: 'auth_invalid_authentication_scheme',
      message:
        'The provided authentication scheme is not supported. Please use a bearer token.'
    });
  }

  try {
    const userId = authService.verifyAccessToken({ accessToken });

    const user = await userService.getUserById({ id: userId });

    if (!user) {
      throw new Error(
        'User is successfully authenticated but not found in the database'
      );
    }

    if (user.recordStatus === UserStatus.Banned) {
      throw new ApiErrorForbidden({
        errorCode: 'auth_user_banned',
        message:
          'Sorry, your account has been banned. Please contact the support team for further information.'
      });
    }

    req.user = user;

    return next();
  } catch (error) {
    if (error instanceof Error === false) {
      return next(error);
    }
    if (error instanceof InvalidTokenError) {
      throw new ApiErrorUnauthorized({
        errorCode: 'auth_expired_token',
        message:
          'Sorry, your login is invalid. Please try again or contact support for help.',
        cause: error
      });
    }
    throw new ApiErrorInternalServerError({ cause: error });
  }
};

export const authRequired: RequestHandler<unknown, unknown, unknown, unknown> = (
  req,
  res,
  next
) => {
  const { authorization } = req.headers;

  if (authorization === undefined) {
    throw new ApiErrorUnauthorized({
      errorCode: 'auth_missing_header',
      message:
        'Authentication required. Please provide valid credentials to access this resource.'
    });
  }

  return auth(req, res, (error: any) => {
    if (error) {
      return next(error);
    }
    const { user } = req;
    if (!user) {
      throw new ApiErrorInternalServerError({
        cause: new Error('The user object should not be null')
      });
    }
    return next();
  });
};

================
File: packages/middleware/configureGlobalExceptionHandler/configureGlobalExceptionHandler.ts
================
import { ErrorRequestHandler } from 'express';
import { v4 as Uuid } from 'uuid';

import { NodeEnv } from '@conduit/types';
import {
  ApiError,
  ApiErrorInternalServerError,
  ApiErrorUnprocessableEntity,
  config,
  logger
} from '@conduit/utils';

import { ConfigureGlobalExceptionHandler } from './types';

export const configureGlobalExceptionHandler: ConfigureGlobalExceptionHandler = ({
  app,
  skipOnLocal = true
}) => {
  if (config.mode !== 'lambda' && skipOnLocal === true) {
    return;
  }
  logger.info('Configuring global exception handler for the application', {
    label: 'App'
  });
  app.use(handler);
};

// eslint-disable-next-line @typescript-eslint/no-unused-vars
const handler: ErrorRequestHandler = (error, _req, res, _next): void => {
  if (process.env.NODE_ENV !== NodeEnv.Test) {
    // Log the error using the winston logger
    logger.error(error);
  }

  // Generate a unique error ID using UUID
  const errorId = Uuid();

  // If the error is a Joi validation error, format it as an Api error
  if (error.isJoi) {
    logger.error(JSON.stringify(error.details, null, 4));
    error = new ApiErrorUnprocessableEntity({
      message: error.details.map((item) => item.message).join('\n'),
      payload: error.details.map((item) => item.message)
    });
  }

  // If the error is not already an instance of ApiError, format it as an internal server error
  if (!(error && error instanceof ApiError)) {
    // eslint-disable-next-line no-console
    logger.error(error);
    error = new ApiErrorInternalServerError({
      message: error?.message,
      cause: error
    });
  }

  // Set the HTTP status code and return the error as a JSON response
  res.status(error.code).json({
    error: {
      id: errorId,
      code: error.code,
      message: error.message,
      errorCode: error.errorCode,
      errorType: error.errorType,
      payload: error.payload
    }
  });
};

================
File: packages/middleware/configureGlobalExceptionHandler/index.ts
================
export * from './configureGlobalExceptionHandler';

================
File: packages/middleware/configureGlobalExceptionHandler/types.ts
================
import { Express } from 'express';

export interface ConfigureGlobalExceptionHandler {
  (input: { app: Express; skipOnLocal?: boolean }): void;
}

================
File: packages/middleware/configureLambda/configureLambda.ts
================
import configureServerlessExpress from '@vendia/serverless-express';

import { ConfigureLambda } from './types';

export const configureLambda: ConfigureLambda = ({ app }) =>
  configureServerlessExpress({
    app,
    logSettings: {
      level: process.env.LOG_LEVEL || 'info'
    }
  });

================
File: packages/middleware/configureLambda/index.ts
================
export * from './configureLambda';

================
File: packages/middleware/configureLambda/types.ts
================
import configureServerlessExpress from '@vendia/serverless-express';
import { Express } from 'express';

export interface ConfigureLambda<TEvent = any, TResult = any> {
  (input: {
    app: Express;
  }): ReturnType<typeof configureServerlessExpress<TEvent, TResult>>;
}

================
File: packages/middleware/configureMiddlewares/configureMiddlewares.ts
================
import bodyParser from 'body-parser';
import chalk from 'chalk';
import compression from 'compression';
import cors from 'cors';
import { Request, Response } from 'express';
import morgan from 'morgan';

import { NodeEnv } from '@conduit/types';
import { config, logger } from '@conduit/utils';

import { ConfigureMiddlewares } from './types';

export const configureMiddlewares: ConfigureMiddlewares = ({
  app,
  skipOnLocal = true
}) => {
  if (config.mode === 'local' && skipOnLocal === true) {
    return;
  }
  logger.info('Configuring middlewares for the application', { label: 'App' });

  // Enable gzip compression of HTTP responses
  app.use(compression());

  // Enable logging of incoming HTTP requests using the morgan package
  if (process.env.NODE_ENV !== NodeEnv.Test) {
    app.use(morgan(morganLogger));
  }

  // Parse JSON payloads in incoming HTTP requests
  app.use(bodyParser.json());

  app.use(cors());

  // Parse URL-encoded payloads in incoming HTTP requests
  app.use(bodyParser.urlencoded({ extended: true }));
};

const morganLogger: morgan.FormatFn<Request, Response> = (tokens, req, res) => {
  if (
    !tokens ||
    !tokens?.status ||
    !tokens['response-time'] ||
    !tokens.method ||
    !tokens.url
  ) {
    return '';
  }

  // Extract tokens and response time
  const status = tokens.status(req, res);
  const responseTimeInString = tokens['response-time'](req, res);
  const responseTime = parseInt(responseTimeInString ?? '', 10);

  // Construct log string with color coding
  return [
    chalk.yellow(tokens.method(req, res)),
    tokens.url(req, res),
    status &&
      status[0] &&
      chalk[parseInt(status[0], 10) <= 3 ? 'green' : 'red'](status),
    responseTime && chalk[responseTime > 500 ? 'red' : 'green'](`${responseTime}ms`)
  ]
    .filter(Boolean)
    .join(' - ');
};

================
File: packages/middleware/configureMiddlewares/index.ts
================
export * from './configureMiddlewares';

================
File: packages/middleware/configureMiddlewares/types.ts
================
import { Express } from 'express';

export interface ConfigureMiddlewares {
  (input: { app: Express; skipOnLocal?: boolean }): void;
}

================
File: packages/middleware/index.ts
================
export * from './auth';
export * from './configureLambda';
export * from './configureMiddlewares';
export * from './configureGlobalExceptionHandler';

================
File: packages/middleware/jest.config.js
================
/** @type {import('jest').Config} */

module.exports = require('@conduit/config/jest.config');

================
File: packages/middleware/package.json
================
{
  "name": "@conduit/middleware",
  "version": "1.0.0",
  "private": true,
  "description": "This module contains the middleware used by the Express application.",
  "keywords": [
    "conduit",
    "middleware"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/kenyipp/realworld-nodejs-example-app/tree/master/packages/middleware"
  },
  "license": "MIT",
  "author": {
    "name": "Ken Yip",
    "email": "ken20206@gmail.com",
    "url": "https://kenyip.cc"
  },
  "scripts": {
    "build": "tsc",
    "check-types": "tsc --skipLibCheck --noEmit",
    "lint": "eslint .",
    "lint:fix": "eslint --fix .",
    "prettify": "prettier --write ."
  },
  "dependencies": {
    "@conduit/config": "*",
    "@conduit/core": "*",
    "@conduit/types": "*",
    "@conduit/utils": "*",
    "@vendia/serverless-express": "^4.12.6",
    "body-parser": "^1.20.3",
    "chalk": "4.1.2",
    "compression": "^1.7.4",
    "cors": "^2.8.5",
    "express": "^4.21.1",
    "lodash": "^4.17.21",
    "morgan": "^1.10.0",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "@jest/types": "^29.6.3",
    "@trivago/prettier-plugin-sort-imports": "^4.3.0",
    "@types/express": "^5.0.0",
    "@typescript-eslint/eslint-plugin": "^5.30.7",
    "@typescript-eslint/parser": "^5.30.7",
    "eslint": "^8.19.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "eslint-config-airbnb-typescript": "^17.0.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-jest": "^26.5.3",
    "eslint-plugin-prettier": "^5.2.1",
    "prettier": "^3.3.3",
    "prettier-plugin-packagejson": "^2.5.3",
    "typescript": "^5.6.3"
  }
}

================
File: packages/middleware/tsconfig.json
================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "@conduit/config/tsconfig.base.json",
  "compilerOptions": {
    "sourceMap": false
  },
  "include": ["./**/*.ts"]
}

================
File: packages/middleware/types/global.d.ts
================
import '@conduit/core/types/global';

================
File: packages/types/.eslintrc.js
================
const defaultConfig = require('@conduit/config/.eslintrc.json');

module.exports = {
  ...defaultConfig,
  parserOptions: {
    project: './tsconfig.json'
  }
};

================
File: packages/types/.prettierrc.cjs
================
module.exports = require('@conduit/config/.prettierrc.json');

================
File: packages/types/index.ts
================
export * from './NodeEnv';

================
File: packages/types/NodeEnv.ts
================
export enum NodeEnv {
  Production = 'prod',
  Development = 'develop',
  Test = 'test',
  CI = 'ci'
}

================
File: packages/types/package.json
================
{
  "name": "@conduit/types",
  "version": "1.0.0",
  "private": true,
  "description": "The types module in this monorepository defines commonly used types shared across all packages and applications.",
  "keywords": [
    "conduit",
    "types"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/kenyipp/realworld-nodejs-example-app/tree/master/packages/types"
  },
  "license": "MIT",
  "author": {
    "name": "Ken Yip",
    "email": "ken20206@gmail.com",
    "url": "https://kenyip.cc"
  },
  "scripts": {
    "build": "tsc",
    "check-types": "tsc --skipLibCheck --noEmit",
    "lint": "eslint .",
    "lint:fix": "eslint --fix .",
    "prettify": "prettier --write ."
  },
  "dependencies": {
    "@conduit/config": "*"
  },
  "devDependencies": {
    "@jest/types": "^29.6.3",
    "@trivago/prettier-plugin-sort-imports": "^4.3.0",
    "@typescript-eslint/eslint-plugin": "^5.30.7",
    "@typescript-eslint/parser": "^5.30.7",
    "eslint": "^8.19.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "eslint-config-airbnb-typescript": "^17.0.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-jest": "^26.5.3",
    "eslint-plugin-prettier": "^5.2.1",
    "prettier": "^3.3.3",
    "prettier-plugin-packagejson": "^2.5.3",
    "typescript": "^5.6.3"
  }
}

================
File: packages/types/tsconfig.json
================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "@conduit/config/tsconfig.base.json",
  "compilerOptions": {
    "sourceMap": false,
    "outDir": "./"
  },
  "include": ["./**/*"]
}

================
File: packages/utils/.eslintrc.js
================
const defaultConfig = require('@conduit/config/.eslintrc.json');

module.exports = {
  ...defaultConfig,
  parserOptions: {
    project: './tsconfig.json'
  }
};

================
File: packages/utils/.prettierrc.cjs
================
module.exports = require('@conduit/config/.prettierrc.json');

================
File: packages/utils/config/config.ts
================
import nodeConfig from 'config';

import { Config } from './types';

export const config: Config = nodeConfig.util.toObject();

================
File: packages/utils/config/index.ts
================
export * from './config';

================
File: packages/utils/config/types.ts
================
import { NodeEnv } from '@conduit/types';

export interface Config {
  nodeEnv: NodeEnv;
  mode: 'local' | 'lambda';
  domain: string;
  auth: {
    expiresIn: string;
    jwtSecret: string;
  };
  aws: {
    accountId: string;
    region: string;
    certificateArn?: string;
  };
  database: {
    conduit: {
      host: string;
      port: number;
      user: string;
      password: string;
      database: string;
    };
  };
}

================
File: packages/utils/error/ApiError.ts
================
export class ApiError extends Error {
  code: number;
  errorType: string;
  errorCode?: string;
  cause?: Error;
  payload?: any;

  constructor({
    message,
    code,
    errorType,
    errorCode,
    cause,
    payload
  }: ApiErrorConstructor) {
    super(message);
    // Ensure the name of this error is the same as the class name
    this.name = this.constructor.name;
    // This clips the constructor invocation from the stack trace.
    // It's not absolutely essential, but it does make the stack trace a little nicer.
    Error.captureStackTrace(this, this.constructor);
    // Error status code
    this.code = code;
    // Human readable error type
    this.errorType = errorType;
    // User defined error code for that Api Error
    this.errorCode = errorCode;
    this.cause = cause;
    this.payload = payload;
  }
}

interface ApiErrorConstructor {
  message: string;
  code: number;
  errorType: string;
  errorCode?: string;
  cause?: Error;
  payload?: any;
}

================
File: packages/utils/error/ApiErrorBadRequest.ts
================
import { ApiError } from './ApiError';
import HttpError from './constants/http-error.json';

export class ApiErrorBadRequest extends ApiError {
  static Config = HttpError[400];

  constructor({
    message,
    errorCode,
    cause,
    payload
  }: ApiErrorBadRequestConstructor) {
    super({
      code: 400,
      message: message || ApiErrorBadRequest.Config.message,
      errorCode,
      errorType: ApiErrorBadRequest.Config.type,
      cause,
      payload
    });
  }

  static assert({
    condition,
    message,
    errorCode,
    cause,
    payload
  }: AssertInput): void {
    if (!condition) {
      throw new this({
        message,
        errorCode,
        cause,
        payload
      });
    }
  }
}

interface ApiErrorBadRequestConstructor {
  message?: string;
  errorCode?: string;
  cause?: Error;
  payload?: any;
}

interface AssertInput extends ApiErrorBadRequestConstructor {
  condition: boolean;
}

================
File: packages/utils/error/ApiErrorConflict.ts
================
import { ApiError } from './ApiError';
import HttpError from './constants/http-error.json';

export class ApiErrorConflict extends ApiError {
  static Config = HttpError[409];

  constructor({ message, errorCode, cause, payload }: ApiErrorConflictConstructor) {
    super({
      code: 409,
      message: message || ApiErrorConflict.Config.message,
      errorCode,
      errorType: ApiErrorConflict.Config.type,
      cause,
      payload
    });
  }

  static assert({
    condition,
    message,
    errorCode,
    cause,
    payload
  }: AssertInput): void {
    if (!condition) {
      throw new this({
        message,
        errorCode,
        cause,
        payload
      });
    }
  }
}

interface ApiErrorConflictConstructor {
  message?: string;
  errorCode?: string;
  cause?: Error;
  payload?: any;
}

interface AssertInput extends ApiErrorConflictConstructor {
  condition: boolean;
}

================
File: packages/utils/error/ApiErrorForbidden.ts
================
import { ApiError } from './ApiError';
import HttpError from './constants/http-error.json';

export class ApiErrorForbidden extends ApiError {
  static Config = HttpError[403];

  constructor({ message, errorCode, cause, payload }: ApiErrorForbiddenConstructor) {
    super({
      code: 403,
      message: message || ApiErrorForbidden.Config.message,
      errorCode,
      errorType: ApiErrorForbidden.Config.type,
      cause,
      payload
    });
  }

  static assert({
    condition,
    message,
    errorCode,
    cause,
    payload
  }: AssertInput): void {
    if (!condition) {
      throw new this({
        message,
        errorCode,
        cause,
        payload
      });
    }
  }
}

interface ApiErrorForbiddenConstructor {
  message?: string;
  errorCode?: string;
  cause?: Error;
  payload?: any;
}

interface AssertInput extends ApiErrorForbiddenConstructor {
  condition: boolean;
}

================
File: packages/utils/error/ApiErrorInternalServerError.ts
================
import { ApiError } from './ApiError';
import HttpError from './constants/http-error.json';

export class ApiErrorInternalServerError extends ApiError {
  static Config = HttpError[500];

  constructor({
    message,
    errorCode,
    cause,
    payload
  }: ApiErrorInternalServerErrorConstructor) {
    super({
      code: 500,
      message: message || ApiErrorInternalServerError.Config.message,
      errorCode,
      errorType: ApiErrorInternalServerError.Config.type,
      cause,
      payload
    });
  }

  static assert({
    condition,
    message,
    errorCode,
    cause,
    payload
  }: AssertInput): void {
    if (!condition) {
      throw new this({
        message,
        errorCode,
        cause,
        payload
      });
    }
  }
}

interface ApiErrorInternalServerErrorConstructor {
  message?: string;
  errorCode?: string;
  cause?: Error;
  payload?: any;
}

interface AssertInput extends ApiErrorInternalServerErrorConstructor {
  condition: boolean;
}

================
File: packages/utils/error/ApiErrorMethodNotAllowed.ts
================
import { ApiError } from './ApiError';
import HttpError from './constants/http-error.json';

export class ApiErrorMethodNotAllowed extends ApiError {
  static Config = HttpError[405];

  constructor({
    message,
    errorCode,
    cause,
    payload
  }: ApiErrorMethodNotAllowedConstructor) {
    super({
      code: 405,
      message: message || ApiErrorMethodNotAllowed.Config.message,
      errorCode,
      errorType: ApiErrorMethodNotAllowed.Config.type,
      cause,
      payload
    });
  }

  static assert({
    condition,
    message,
    errorCode,
    cause,
    payload
  }: AssertInput): void {
    if (!condition) {
      throw new this({
        message,
        errorCode,
        cause,
        payload
      });
    }
  }
}

interface ApiErrorMethodNotAllowedConstructor {
  message?: string;
  errorCode?: string;
  cause?: Error;
  payload?: any;
}

interface AssertInput extends ApiErrorMethodNotAllowedConstructor {
  condition: boolean;
}

================
File: packages/utils/error/ApiErrorNotFound.ts
================
import { ApiError } from './ApiError';
import HttpError from './constants/http-error.json';

export class ApiErrorNotFound extends ApiError {
  static Config = HttpError[404];

  constructor({ message, errorCode, cause, payload }: ApiErrorNotFoundConstructor) {
    super({
      code: 404,
      message: message || ApiErrorNotFound.Config.message,
      errorCode,
      errorType: ApiErrorNotFound.Config.type,
      cause,
      payload
    });
  }

  static assert({
    condition,
    message,
    errorCode,
    cause,
    payload
  }: AssertInput): void {
    if (!condition) {
      throw new this({
        message,
        errorCode,
        cause,
        payload
      });
    }
  }
}

interface ApiErrorNotFoundConstructor {
  message?: string;
  errorCode?: string;
  cause?: Error;
  payload?: any;
}

interface AssertInput extends ApiErrorNotFoundConstructor {
  condition: boolean;
}

================
File: packages/utils/error/ApiErrorNotImplemented.ts
================
import { ApiError } from './ApiError';
import HttpError from './constants/http-error.json';

export class ApiErrorNotImplemented extends ApiError {
  static Config = HttpError[501];

  constructor({
    message,
    errorCode,
    cause,
    payload
  }: ApiErrorNotImplementedConstructor) {
    super({
      code: 501,
      message: message || ApiErrorNotImplemented.Config.message,
      errorCode,
      errorType: ApiErrorNotImplemented.Config.type,
      cause,
      payload
    });
  }

  static assert({
    condition,
    message,
    errorCode,
    cause,
    payload
  }: AssertInput): void {
    if (!condition) {
      throw new this({
        message,
        errorCode,
        cause,
        payload
      });
    }
  }
}

interface ApiErrorNotImplementedConstructor {
  message?: string;
  errorCode?: string;
  cause?: Error;
  payload?: any;
}

interface AssertInput extends ApiErrorNotImplementedConstructor {
  condition: boolean;
}

================
File: packages/utils/error/ApiErrorRequestTimeout.ts
================
import { ApiError } from './ApiError';
import HttpError from './constants/http-error.json';

export class ApiErrorRequestTimeout extends ApiError {
  static Config = HttpError[408];

  constructor({
    message,
    errorCode,
    cause,
    payload
  }: ApiErrorRequestTimeoutConstructor) {
    super({
      code: 408,
      message: message || ApiErrorRequestTimeout.Config.message,
      errorCode,
      errorType: ApiErrorRequestTimeout.Config.type,
      cause,
      payload
    });
  }

  static assert({
    condition,
    message,
    errorCode,
    cause,
    payload
  }: AssertInput): void {
    if (!condition) {
      throw new this({
        message,
        errorCode,
        cause,
        payload
      });
    }
  }
}

interface ApiErrorRequestTimeoutConstructor {
  message?: string;
  errorCode?: string;
  cause?: Error;
  payload?: any;
}

interface AssertInput extends ApiErrorRequestTimeoutConstructor {
  condition: boolean;
}

================
File: packages/utils/error/ApiErrorServiceUnavailable.ts
================
import { ApiError } from './ApiError';
import HttpError from './constants/http-error.json';

export class ApiErrorServiceUnavailable extends ApiError {
  static Config = HttpError[503];

  constructor({
    message,
    errorCode,
    cause,
    payload
  }: ApiErrorServiceUnavailableConstructor) {
    super({
      code: 503,
      message: message || ApiErrorServiceUnavailable.Config.message,
      errorCode,
      errorType: ApiErrorServiceUnavailable.Config.type,
      cause,
      payload
    });
  }

  static assert({
    condition,
    message,
    errorCode,
    cause,
    payload
  }: AssertInput): void {
    if (!condition) {
      throw new this({
        message,
        errorCode,
        cause,
        payload
      });
    }
  }
}

interface ApiErrorServiceUnavailableConstructor {
  message?: string;
  errorCode?: string;
  cause?: Error;
  payload?: any;
}

interface AssertInput extends ApiErrorServiceUnavailableConstructor {
  condition: boolean;
}

================
File: packages/utils/error/ApiErrorTooManyRequests.ts
================
import { ApiError } from './ApiError';
import HttpError from './constants/http-error.json';

export class ApiErrorTooManyRequests extends ApiError {
  static Config = HttpError[429];

  constructor({
    message,
    errorCode,
    cause,
    payload
  }: ApiErrorTooManyRequestsConstructor) {
    super({
      code: 429,
      message: message || ApiErrorTooManyRequests.Config.message,
      errorCode,
      errorType: ApiErrorTooManyRequests.Config.type,
      cause,
      payload
    });
  }

  static assert({
    condition,
    message,
    errorCode,
    cause,
    payload
  }: AssertInput): void {
    if (!condition) {
      throw new this({
        message,
        errorCode,
        cause,
        payload
      });
    }
  }
}

interface ApiErrorTooManyRequestsConstructor {
  message?: string;
  errorCode?: string;
  cause?: Error;
  payload?: any;
}

interface AssertInput extends ApiErrorTooManyRequestsConstructor {
  condition: boolean;
}

================
File: packages/utils/error/ApiErrorUnauthorized.ts
================
import { ApiError } from './ApiError';
import HttpError from './constants/http-error.json';

export class ApiErrorUnauthorized extends ApiError {
  static Config = HttpError[401];

  constructor({
    message,
    errorCode,
    cause,
    payload
  }: ApiErrorUnauthorizedConstructor) {
    super({
      code: 401,
      message: message || ApiErrorUnauthorized.Config.message,
      errorCode,
      errorType: ApiErrorUnauthorized.Config.type,
      cause,
      payload
    });
  }

  static assert({
    condition,
    message,
    errorCode,
    cause,
    payload
  }: AssertInput): void {
    if (!condition) {
      throw new this({
        message,
        errorCode,
        cause,
        payload
      });
    }
  }
}

interface ApiErrorUnauthorizedConstructor {
  message?: string;
  errorCode?: string;
  cause?: Error;
  payload?: any;
}

interface AssertInput extends ApiErrorUnauthorizedConstructor {
  condition: boolean;
}

================
File: packages/utils/error/ApiErrorUnprocessableEntity.ts
================
import { ApiError } from './ApiError';
import HttpError from './constants/http-error.json';

export class ApiErrorUnprocessableEntity extends ApiError {
  static Config = HttpError[422];

  constructor({
    message,
    errorCode,
    cause,
    payload
  }: ApiErrorUnprocessableEntityConstructor) {
    super({
      code: 422,
      message: message || ApiErrorUnprocessableEntity.Config.message,
      errorCode,
      errorType: ApiErrorUnprocessableEntity.Config.type,
      cause,
      payload
    });
  }

  static assert({
    condition,
    message,
    errorCode,
    cause,
    payload
  }: AssertInput): void {
    if (!condition) {
      throw new this({
        message,
        errorCode,
        cause,
        payload
      });
    }
  }
}

interface ApiErrorUnprocessableEntityConstructor {
  message?: string;
  errorCode?: string;
  cause?: Error;
  payload?: any;
}

interface AssertInput extends ApiErrorUnprocessableEntityConstructor {
  condition: boolean;
}

================
File: packages/utils/error/constants/http-error.json
================
{
  "400": {
    "name": "Bad Request",
    "code": 400,
    "message": "The request could not be understood by the server due to malformed syntax.",
    "type": "BadRequest"
  },
  "401": {
    "name": "Unauthorized",
    "code": 401,
    "message": "The request requires user authentication.",
    "type": "Unauthorized"
  },
  "402": {
    "name": "Payment Required",
    "code": 402,
    "message": "The request can not be processed until the client makes a payment.",
    "type": "PaymentRequired"
  },
  "403": {
    "name": "Forbidden",
    "code": 403,
    "message": "The server understood the request, but is refusing to fulfill it.",
    "type": "Forbidden"
  },
  "404": {
    "name": "Not Found",
    "code": 404,
    "message": "The server has not found anything matching the Request-URI.",
    "type": "NotFound"
  },
  "405": {
    "name": "Method Not Allowed",
    "code": 405,
    "message": "The method specified in the Request-Line is not allowed for the resource identified by the Request-URI.",
    "type": "MethodNotAllowed"
  },
  "406": {
    "name": "Not Acceptable",
    "code": 406,
    "message": "The resource identified by the request is only capable of generating response entities which have content characteristics not acceptable according to the accept headers sent in the request.",
    "type": "NotAcceptable"
  },
  "407": {
    "name": "Proxy Authentication Required",
    "code": 407,
    "message": "The client must first authenticate itself with the proxy.",
    "type": "ProxyAuthenticationRequired"
  },
  "408": {
    "name": "Request Timeout",
    "code": 408,
    "message": "The client did not produce a request within the time that the server was prepared to wait.",
    "type": "RequestTimeout"
  },
  "409": {
    "name": "Conflict",
    "code": 409,
    "message": "The request could not be completed due to a conflict with the current state of the resource.",
    "type": "Conflict"
  },
  "410": {
    "name": "Gone",
    "code": 410,
    "message": "The requested resource is no longer available at the server and no forwarding address is known.",
    "type": "Gone"
  },
  "411": {
    "name": "Length Required",
    "code": 411,
    "message": "The server refuses to accept the request without a defined Content-Length.",
    "type": "LengthRequired"
  },
  "412": {
    "name": "Precondition Failed",
    "code": 412,
    "message": "The precondition given in one or more of the request-header fields evaluated to false when it was tested on the server.",
    "type": "PreconditionFailed"
  },
  "413": {
    "name": "Payload Too Large",
    "code": 413,
    "message": "The server is refusing to process a request because the request entity is larger than the server is willing or able to process.",
    "type": "RequestEntityTooLarge"
  },
  "414": {
    "name": "URI Too Long",
    "code": 414,
    "message": "The server is refusing to service the request because the request-target is longer than the server is willing to interpret.",
    "type": "URITooLong"
  },
  "415": {
    "name": "Unsupported Media Type",
    "code": 415,
    "message": "The server is refusing to service the request because the entity of the request is in a format not supported by the requested resource for the requested method.",
    "type": "UnsupportedMediaType"
  },
  "416": {
    "name": "Range Not Satisfiable",
    "code": 416,
    "message": "The request included a Range request-header field, and none of the range-specifier values in this field overlap the current extent of the selected resource, and the request did not include an If-Range request-header field.",
    "type": "RequestedRangeNotSatisfiable"
  },
  "417": {
    "name": "Expectation Failed",
    "code": 417,
    "message": "The expectation given in an Expect request-header field could not be met by this server.",
    "type": "ExpectationFailed"
  },
  "421": {
    "name": "Misdirected Request",
    "code": 421,
    "message": "The request was directed at a server that is not able to produce a response.",
    "type": "MisdirectedRequest"
  },
  "422": {
    "name": "Unprocessable Entity",
    "code": 422,
    "message": "The the server understands the content type of the request entity, and the syntax of the request entity is correct but was unable to process the contained instructions.",
    "type": "UnprocessableEntity"
  },
  "423": {
    "name": "Locked",
    "code": 423,
    "message": "The source or destination resource of a method is locked.",
    "type": "Locked"
  },
  "424": {
    "name": "Failed Dependency",
    "code": 424,
    "message": "The method could not be performed on the resource because the requested action depended on another action and that action failed.",
    "type": "FailedDependency"
  },
  "425": {
    "name": "Unordered Collection",
    "code": 425,
    "message": "The server is unwilling to risk processing a request that might be replayed.",
    "type": "TooEarly"
  },
  "426": {
    "name": "Upgrade Required",
    "code": 426,
    "message": "The server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol.",
    "type": "UpgradeRequired"
  },
  "428": {
    "name": "Precondition Required",
    "code": 428,
    "message": "The origin server requires the request to be conditional.",
    "type": "PreconditionRequired"
  },
  "429": {
    "name": "Too Many Requests",
    "code": 429,
    "message": "The user has sent too many requests in a given amount of time.",
    "type": "TooManyRequests"
  },
  "431": {
    "name": "Request Header Fields Too Large",
    "code": 431,
    "message": "The server is unwilling to process the request because its header fields are too large.",
    "type": "RequestHeaderFieldsTooLarge"
  },
  "451": {
    "code": 451,
    "message": "The server is denying access to the resource as a consequence of a legal demand.",
    "type": "UnavailableForLegalReasons"
  },
  "500": {
    "name": "Internal Server Error",
    "code": 500,
    "message": "The server encountered an unexpected condition which prevented it from fulfilling the request.",
    "type": "InternalServerError"
  },
  "501": {
    "name": "Not Implemented",
    "code": 501,
    "message": "The server does not support the functionality required to fulfill the request.",
    "type": "NotImplemented"
  },
  "502": {
    "name": "Bad Gateway",
    "code": 502,
    "message": "The server, while acting as a gateway or proxy, received an invalid response from the upstream server it accessed in attempting to fulfill the request.",
    "type": "BadGateway"
  },
  "503": {
    "name": "Service Unavailable",
    "code": 503,
    "message": "The server is currently unable to handle the request due to a temporary overloading or maintenance of the server.",
    "type": "ServiceUnavailable"
  },
  "504": {
    "name": "Gateway Timeout",
    "code": 504,
    "message": "The server, while acting as a gateway or proxy, did not receive a timely response from the upstream server it accessed in attempting to fulfill the request.",
    "type": "GatewayTimeout"
  },
  "505": {
    "name": "HTTP Version Not Supported",
    "code": 505,
    "message": "The server does not support, or refuses to support, the HTTP protocol version that was used in the request message.",
    "type": "HTTPVersionNotSupported"
  },
  "506": {
    "name": "Variant Also Negotiates",
    "code": 506,
    "message": "The server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper end point in the negotiation process.",
    "type": "VariantAlsoNegotiates"
  },
  "507": {
    "name": "Insufficient Storage",
    "code": 507,
    "message": "The method could not be performed on the resource because the server is unable to store the representation needed to successfully complete the request.",
    "type": "InsufficientStorage"
  },
  "508": {
    "name": "Loop Detected",
    "code": 508,
    "message": "The server terminated an operation because it encountered an infinite loop while processing a request with \"Depth: infinity\".",
    "type": "LoopDetected"
  },
  "510": {
    "name": "Not Extended",
    "code": 510,
    "message": "The policy for accessing the resource has not been met in the request.",
    "type": "NotExtended"
  },
  "511": {
    "name": "Network Authentication Required",
    "code": 511,
    "message": "The client needs to authenticate to gain network access.",
    "type": "NetworkAuthenticationRequired"
  }
}

================
File: packages/utils/error/index.ts
================
export * from './ApiError';
export * from './ApiErrorConflict';
export * from './ApiErrorBadRequest';
export * from './ApiErrorForbidden';
export * from './ApiErrorInternalServerError';
export * from './ApiErrorNotFound';
export * from './ApiErrorNotImplemented';
export * from './ApiErrorRequestTimeout';
export * from './ApiErrorServiceUnavailable';
export * from './ApiErrorTooManyRequests';
export * from './ApiErrorUnauthorized';
export * from './ApiErrorUnprocessableEntity';

================
File: packages/utils/index.ts
================
export * from './config';
export * from './error';
export * from './logger';

================
File: packages/utils/jest.config.js
================
/** @type {import('jest').Config} */

module.exports = require('@conduit/config/jest.config');

================
File: packages/utils/logger/formats/capitalizeLevel.ts
================
import { startCase } from 'lodash';
import { format } from 'winston';

export const capitalizeLevel = format((info) => {
  if (info.level) {
    // eslint-disable-next-line no-param-reassign
    info.level = startCase(info.level);
  }
  return info;
});

================
File: packages/utils/logger/formats/cleanStack.ts
================
import cleanStackFn, { Options } from 'clean-stack';
import { isNil } from 'lodash';
import { format } from 'winston';

export const cleanStack = format((info, options: Options = {}) => {
  if (info.message instanceof Error && !isNil(info.message.stack)) {
    // eslint-disable-next-line no-param-reassign
    info.message.stack = cleanStackFn(info.message.stack, options);
  }
  return info;
});

================
File: packages/utils/logger/formats/customPrintf.ts
================
import colors from '@colors/colors/safe';
import path from 'path';
import { format } from 'winston';

const { printf } = format;
const pwd = path.resolve(process.env.PWD || process.cwd());

const DefaultCustomPrintfOptions = {
  hideErrorStack: false
};

export const customPrintf = (
  options: CustomPrintfOptions = DefaultCustomPrintfOptions
) =>
  printf((info) => {
    let message = `${info.level} - ${info.message}`;

    if (info.stack && !options.hideErrorStack && process.env.NODE_ENV === 'dev') {
      const stackWithColors = info.stack
        .split('\n')
        .slice(1)
        .map((line: string, index: number) => {
          if (
            index === 0 ||
            (!line.includes('node_modules') && line.includes(pwd))
          ) {
            return line;
          }
          return colors.grey(line);
        })
        .join('\n');

      message += `\n${stackWithColors}`;
    }
    return message;
  });

type CustomPrintfOptions = {
  hideErrorStack: boolean;
};

================
File: packages/utils/logger/formats/environment.ts
================
import { format } from 'winston';

export const environment = format((info) => {
  // eslint-disable-next-line no-param-reassign
  info.environment = process.env.NODE_ENV || 'development';
  return info;
});

================
File: packages/utils/logger/formats/index.ts
================
export * from './cleanStack';
export * from './capitalizeLevel';
export * from './json';
export * from './label';
export * from './customPrintf';
export * from './environment';

================
File: packages/utils/logger/formats/json.ts
================
import stringify from 'safe-stable-stringify';
import { MESSAGE } from 'triple-beam';
import { format } from 'winston';

export const json = format((info, options) => {
  const jsonStringify = stringify.configure(options);
  const stringified = jsonStringify(
    info,
    options.replacer || replacer,
    options.space
  );
  // eslint-disable-next-line no-param-reassign
  info[MESSAGE] = stringified;
  return info;
});

function replacer(_key: string, value: any) {
  /**
   *
   * While safe-stable-stringify does support BigInt,
   * it doesn't wrap the value in quotes, which can result in a loss of fidelity if the resulting string is parsed.
   * However, wrapping BigInts in quotes would be a breaking change for logform,
   * so it's currently not implemented.
   *
   */
  if (typeof value === 'bigint') {
    return value.toString();
  }
  return value;
}

================
File: packages/utils/logger/formats/label.ts
================
import colors from '@colors/colors/safe';
import { get } from 'lodash';
import { format } from 'winston';

const isDevelopment = process.env.NODE_ENV === 'dev';

const labelMiddleware = format(
  (info, options: LabelOptions = DefaultLabelOptions) => {
    const {
      color = DefaultLabelOptions.color,
      labelColor = DefaultLabelOptions.labelColor
    } = options;

    const { label, message } = info;

    if (label) {
      // eslint-disable-next-line no-param-reassign
      info.message = `${
        color && isDevelopment && get(colors, labelColor)
          ? get(colors, labelColor)(`[${label}]`)
          : `[${label}]`
      } ${message}`;
    }

    return info;
  }
);

export interface LabelOptions {
  color: boolean;
  labelColor: string;
}

const DefaultLabelOptions = {
  color: false,
  labelColor: 'yellow'
};

export { labelMiddleware as label };

================
File: packages/utils/logger/index.ts
================
export { logger } from './logger';

================
File: packages/utils/logger/logger.ts
================
import winston, { format, transports } from 'winston';

import {
  capitalizeLevel,
  cleanStack,
  customPrintf,
  environment,
  label
} from './formats';

const { errors, json, combine, colorize, uncolorize, metadata } = format;
const { Console } = transports;
const { levels } = winston.config.npm;

const isDevelopment = process.env.NODE_ENV === 'dev';

export const logger = winston.createLogger({
  level: 'debug',
  levels,
  // Use the Console transport with a custom format
  transports: [
    new Console({
      format: combine(
        label({}),
        capitalizeLevel(),
        isDevelopment ? colorize() : uncolorize(),
        customPrintf()
      )
    })
  ],
  // Define the default log format options
  format: format.combine(
    environment(),
    cleanStack({}),
    errors({ stack: true }),
    json(),
    metadata({
      key: 'payload',
      fillExcept: ['label', 'timestamp', 'message', 'level', 'stack', 'environment']
    })
  ),
  // Don't exit the process when a handled exception occurs
  exitOnError: false,
  silent: process.env.NODE_ENV === 'test'
});

================
File: packages/utils/package.json
================
{
  "name": "@conduit/utils",
  "version": "1.0.0",
  "private": true,
  "description": "The utils module provides shared utilities and helper functions to streamline development, including a logger and custom error class.",
  "keywords": [
    "conduit",
    "utils"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/kenyipp/realworld-nodejs-example-app/tree/master/packages/utils"
  },
  "license": "MIT",
  "author": {
    "name": "Ken Yip",
    "email": "ken20206@gmail.com",
    "url": "https://kenyip.cc"
  },
  "scripts": {
    "build": "tsc",
    "check-types": "tsc --skipLibCheck --noEmit",
    "lint": "eslint .",
    "lint:fix": "eslint --fix .",
    "prettify": "prettier --write ."
  },
  "dependencies": {
    "@colors/colors": "^1.5.0",
    "@conduit/config": "*",
    "@conduit/types": "*",
    "clean-stack": "3.0.1",
    "config": "^3.3.12",
    "cors": "^2.8.5",
    "express": "^4.21.1",
    "lodash": "^4.17.21",
    "safe-stable-stringify": "2.4.1",
    "triple-beam": "^1.4.1",
    "winston": "^3.15.0"
  },
  "devDependencies": {
    "@jest/types": "^29.6.3",
    "@trivago/prettier-plugin-sort-imports": "^4.3.0",
    "@types/compression": "^1.7.5",
    "@types/config": "^3.3.5",
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.0",
    "@types/morgan": "^1.9.9",
    "@typescript-eslint/eslint-plugin": "^5.30.7",
    "@typescript-eslint/parser": "^5.30.7",
    "eslint": "^8.19.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "eslint-config-airbnb-typescript": "^17.0.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-jest": "^26.5.3",
    "eslint-plugin-prettier": "^5.2.1",
    "prettier": "^3.3.3",
    "prettier-plugin-packagejson": "^2.5.3",
    "typescript": "^5.6.3"
  }
}

================
File: packages/utils/tsconfig.json
================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "@conduit/config/tsconfig.base.json",
  "compilerOptions": {
    "sourceMap": false
  },
  "include": ["./**/*.ts"]
}

================
File: README.md
================
# ![Node.js / Express / Typescript / MySql / Knex Example App](./.github/images/logo.png)

<p align="center">
  Example Node (Express + Knex) codebase containing real world examples (CRUD, auth, advanced patterns, etc) that adheres to the <a href="https://github.com/gothinkster/realworld-example-apps">RealWorld</a> API spec.
</p>
<!-- The badges section -->
<p align="center">
<a href="https://github.com/kenyipp/realworld-nodejs-example-app/actions/workflows/ci.yml"><img src="https://github.com/kenyipp/realworld-nodejs-example-app/workflows/Continuous Integration/badge.svg" alt="Actions Status"></a>
<a href="https://codecov.io/gh/kenyipp/realworld-nodejs-example-app"><img src="https://codecov.io/gh/kenyipp/realworld-nodejs-example-app/branch/master/graph/badge.svg?token=AMBNXM57T8" alt="codecov"></a>
<!-- Snyk.io vulnerabilities badge -->
<a href="https://snyk.io/test/github/kenyipp/realworld-nodejs-example-app"><img src="https://snyk.io/test/github/kenyipp/realworld-nodejs-example-app/badge.svg" alt="Known Vulnerabilities"></a>
<!-- Shields.io license badge -->
<a href="https://github.com/kenyipp/realworld-nodejs-example-app/blob/master/LICENSE"><img alt="License" src="https://img.shields.io/npm/l/downsample"/></a>
</p>

<p align="center">
This repository has been approved and included on the <a href="https://codebase.show/projects/realworld?category=backend&language=typescript">project page</a> by the <a href="https://codebase.show">Codebase.show</a>  team. I am committed to continuously improving this codebase and incorporating new technologies and useful Node modules as I discover them.
</p>

<p align="center"> I created a separate <a href="https://github.com/kenyipp/realworld-nodejs-example-app-infra?tab=readme-ov-file">repository</a> to deploy this project architecture via <a href="https://docs.aws.amazon.com/cdk/v2/guide/getting_started.html">Aws Cdk</a>. Please check this repository. </p>

<p align="center"> This repository has complete functionality ‚Äî pull requests and issues are welcome! </p>

<p align="center">
<a href="#demo">Demo</a>
<span>|</span>
<a href="#get_started">Get Started</a>
<span>|</span>
<a href="#architecture">Architecture</a>
<span>|</span>
<a href="#contributing">Contributing</a>
</p>

## Demo

To demonstrate the functionality of the backend, we have deployed a live demo version of the application. You can visit the demo by following this link: [https://conduit-api-prod.kenyip.cc](https://conduit-api-prod.kenyip.cc).

The API has several endpoints that you can test out using a tool like Postman or cURL. You can find the documentation for the API endpoints on the [API documentation page](https://conduit-api-develop.kenyip.cc). Feel free to use this endpoint to create your amazing frontend applications!

Please note that the demo version of the application is intended for demonstration purposes only and may not be suitable for production use. If you would like to deploy the application yourself, please follow the instructions in the <a href="#get_started">Get Started</a> section of this README.

<a id="get_started"></a>

## Get Started
This project utilizes [Yarn](https://classic.yarnpkg.com/en/) as its package manager. Please ensure that Yarn is installed before you begin working on this project.

### Start the Program Using Docker

To start the Docker setup, run the following commands:

```sh
docker-compose build
docker-compose up -d
```

The Docker Compose configuration includes the API server, MySQL database, and the necessary program to set up the required tables for the application to function correctly.

### Local Development

1. Configure the environment variables according to the table below:

| Env                         | Description                                   | Required |
|------------------------------|-----------------------------------------------|----------|
| NODE_ENV                     | Environment in which the application is running (e.g., develop, test, ci, production) | Yes      |
| DOMAIN                       | Domain name for the application               | No       |
| AUTH_EXPIRES_IN             | Duration for which the authentication token is valid | No       |
| AUTH_JWT_SECRET              | Secret key used for signing JWT tokens        | Yes      |
| DATABASE_HOST                | Hostname of the database server               | Yes      |
| DATABASE_PORT                | Port number on which the database is listening | Yes      |
| DATABASE_USER                | Username for database authentication           | Yes      |
| DATABASE_PASSWORD            | Password for database authentication           | Yes      |
| DATABASE_NAME                | Name of the database to connect to            | Yes      |

2. Execute the following commands to install all dependencies and launch the development server:

	```sh
	yarn
	yarn dev
	```

3. Afterward, navigate to [http://localhost:3100/api/health-check](http://localhost:3100/api/health-check) to verify if the server is operating correctly.

### Deployment

This project utilizes the <a href="https://github.com/vendia/serverless-express">Express Serverless</a> framework along with <a href="https://docs.aws.amazon.com/cdk/v2/guide/getting_started.html">Amazon CDK</a> to deploy the server in a serverless architecture. You can find the [./infra](infra) folder in the root directory, which contains all the setup code related to this server. To view the entire architecture, including roles, buckets, and the CodeBuild pipeline, please refer to [this repository](https://github.com/kenyipp/realworld-nodejs-example-app-infra).

To deploy the application, run `yarn deploy --all` in the command line interface. If you need more detailed explanations on the techniques and application architecture, refer to the <a href="#architecture">architecture</a> section.

For more information on deploying a serverless application with Amazon SAM, please visit the [AWS documentation](https://docs.aws.amazon.com/serverless-application-model/?icmpid=docs_homepage_compute).

## Architecture
I have written a blog post about the techniques, structure, architecture, and my reflections on this project. For more details, click [here](https://medium.com/@ken20206/crafting-a-scalable-node-js-api-insights-from-my-realworld-project-with-express-knex-and-aws-cdk-056523e70b69)!

## Contributing

Please review the existing issues in this repository for areas that require improvement.
If you identify any missing or potential areas for improvement, feel free to open a new issue for them.

### Before commit

Before deploying and integrating the application, it is necessary to perform a series of validations such as testing, linting, and formatting. We recommend running `make pre-commit` before making each commit to ensure compliance.

## License
This project is licensed under the MIT License - see the [MIT](LICENSE) file for details.

================
File: scripts/api-test.sh
================
#!/bin/bash

TEST_COLLECTIONS_LIST=( \
	full
)

for collection in ${TEST_COLLECTIONS_LIST[@]}; do
	newman run ./tests/integration/postman-collections/$collection.json \
	  --bail										  \
	  -e "./tests/integration/testing-environment.json"
done

================
File: scripts/clean.sh
================
#!/bin/bash

# Colors for logs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Function to clean up directories
clean_directory() {
  local dir_type=$1
  local path_pattern=$2

  echo -e "${YELLOW}Searching for '$dir_type' directories ...${NC}"
  if find ./ -type d -name "$path_pattern" -exec rm -rf {} +; then
    # Removed the log for successful removal
    :
  else
    echo -e "${RED}Error removing '$dir_type' directories.${NC}"
  fi
}

# Clean .turbo directories
clean_directory ".turbo" ".turbo"

# Clean coverage directories
clean_directory "coverage" "coverage"

# Clean .nyc_output directories
clean_directory ".nyc_output" ".nyc_output"

# Final message
echo -e "${BOLD}${GREEN}Cleanup completed for all directories.${NC}"

================
File: scripts/wait-for-readiness.sh
================
#!/bin/bash

set -xe

wait_for_readiness() {
	local SERVICE="$1"
	local PORT="$2"
	local TRY_TIMEOUT=300
	local TRY_INTERVAL=1
	local REMAINING_TIME=$TRY_TIMEOUT
	while ! curl http://localhost:${PORT}/api/health-check -s --include | head -n1 | grep -q 200; do
		REMAINING_TIME=$((REMAINING_TIME - TRY_INTERVAL))
		if [ $REMAINING_TIME -lt 0 ]; then
			echo "Error: '${SERVICE}' did not start in expected duration."
			exit 1
		fi
		echo "Waiting for '${SERVICE}' to start... remaining ${REMAINING_TIME} seconds."
		sleep $TRY_INTERVAL
	done
	echo "The '${SERVICE}' is ready to be tested."
}

wait_for_readiness 'API Server' 3100

================
File: tests/integration/postman-collections/full.json
================
{
	"info": {
		"_postman_id": "0574ad8a-a525-43ae-8e1e-5fd9756037f4",
		"name": "Conduit",
		"description": "Collection for testing the Conduit API\n\nhttps://github.com/gothinkster/realworld",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "Auth",
			"item": [
				{
					"name": "Register",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"if (!(environment.isIntegrationTest)) {",
									"var responseJSON = JSON.parse(responseBody);",
									"",
									"tests['Response contains \"user\" property'] = responseJSON.hasOwnProperty('user');",
									"",
									"var user = responseJSON.user || {};",
									"",
									"tests['User has \"email\" property'] = user.hasOwnProperty('email');",
									"tests['User has \"username\" property'] = user.hasOwnProperty('username');",
									"tests['User has \"bio\" property'] = user.hasOwnProperty('bio');",
									"tests['User has \"image\" property'] = user.hasOwnProperty('image');",
									"tests['User has \"token\" property'] = user.hasOwnProperty('token');",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\"user\":{\"email\":\"{{EMAIL}}\", \"password\":\"{{PASSWORD}}\", \"username\":\"{{USERNAME}}\"}}"
						},
						"url": {
							"raw": "{{APIURL}}/users",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"users"
							]
						}
					},
					"response": []
				},
				{
					"name": "Login",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var responseJSON = JSON.parse(responseBody);",
									"",
									"tests['Response contains \"user\" property'] = responseJSON.hasOwnProperty('user');",
									"",
									"var user = responseJSON.user || {};",
									"",
									"tests['User has \"email\" property'] = user.hasOwnProperty('email');",
									"tests['User has \"username\" property'] = user.hasOwnProperty('username');",
									"tests['User has \"bio\" property'] = user.hasOwnProperty('bio');",
									"tests['User has \"image\" property'] = user.hasOwnProperty('image');",
									"tests['User has \"token\" property'] = user.hasOwnProperty('token');",
									""
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\"user\":{\"email\":\"{{EMAIL}}\", \"password\":\"{{PASSWORD}}\"}}"
						},
						"url": {
							"raw": "{{APIURL}}/users/login",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"users",
								"login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Login and Remember Token",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "a7674032-bf09-4ae7-8224-4afa2fb1a9f9",
								"type": "text/javascript",
								"exec": [
									"var responseJSON = JSON.parse(responseBody);",
									"",
									"tests['Response contains \"user\" property'] = responseJSON.hasOwnProperty('user');",
									"",
									"var user = responseJSON.user || {};",
									"",
									"tests['User has \"email\" property'] = user.hasOwnProperty('email');",
									"tests['User has \"username\" property'] = user.hasOwnProperty('username');",
									"tests['User has \"bio\" property'] = user.hasOwnProperty('bio');",
									"tests['User has \"image\" property'] = user.hasOwnProperty('image');",
									"tests['User has \"token\" property'] = user.hasOwnProperty('token');",
									"",
									"if(tests['User has \"token\" property']){",
									"    pm.globals.set('token', user.token);",
									"}",
									"",
									"tests['Global variable \"token\" has been set'] = pm.globals.get('token') === user.token;",
									""
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\"user\":{\"email\":\"{{EMAIL}}\", \"password\":\"{{PASSWORD}}\"}}"
						},
						"url": {
							"raw": "{{APIURL}}/users/login",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"users",
								"login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Current User",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var responseJSON = JSON.parse(responseBody);",
									"",
									"tests['Response contains \"user\" property'] = responseJSON.hasOwnProperty('user');",
									"",
									"var user = responseJSON.user || {};",
									"",
									"tests['User has \"email\" property'] = user.hasOwnProperty('email');",
									"tests['User has \"username\" property'] = user.hasOwnProperty('username');",
									"tests['User has \"bio\" property'] = user.hasOwnProperty('bio');",
									"tests['User has \"image\" property'] = user.hasOwnProperty('image');",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/user",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"user"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update User",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var responseJSON = JSON.parse(responseBody);",
									"",
									"tests['Response contains \"user\" property'] = responseJSON.hasOwnProperty('user');",
									"",
									"var user = responseJSON.user || {};",
									"",
									"tests['User has \"email\" property'] = user.hasOwnProperty('email');",
									"tests['User has \"username\" property'] = user.hasOwnProperty('username');",
									"tests['User has \"bio\" property'] = user.hasOwnProperty('bio');",
									"tests['User has \"image\" property'] = user.hasOwnProperty('image');",
									""
								]
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\"user\":{\"email\":\"{{EMAIL}}\"}}"
						},
						"url": {
							"raw": "{{APIURL}}/user",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"user"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Articles",
			"item": [
				{
					"name": "All Articles",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var is200Response = responseCode.code === 200;",
									"",
									"tests['Response code is 200 OK'] = is200Response;",
									"",
									"if(is200Response){",
									"    var responseJSON = JSON.parse(responseBody);",
									"",
									"    tests['Response contains \"articles\" property'] = responseJSON.hasOwnProperty('articles');",
									"    tests['Response contains \"articlesCount\" property'] = responseJSON.hasOwnProperty('articlesCount');",
									"    tests['articlesCount is an integer'] = Number.isInteger(responseJSON.articlesCount);",
									"",
									"    if(responseJSON.articles.length){",
									"        var article = responseJSON.articles[0];",
									"",
									"        tests['Article has \"title\" property'] = article.hasOwnProperty('title');",
									"        tests['Article has \"slug\" property'] = article.hasOwnProperty('slug');",
									"        tests['Article has \"body\" property'] = article.hasOwnProperty('body');",
									"        tests['Article has \"createdAt\" property'] = article.hasOwnProperty('createdAt');",
									"        tests['Article\\'s \"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.createdAt);",
									"        tests['Article has \"updatedAt\" property'] = article.hasOwnProperty('updatedAt');",
									"        tests['Article\\'s \"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.updatedAt);",
									"        tests['Article has \"description\" property'] = article.hasOwnProperty('description');",
									"        tests['Article has \"tagList\" property'] = article.hasOwnProperty('tagList');",
									"        tests['Article\\'s \"tagList\" property is an Array'] = Array.isArray(article.tagList);",
									"        tests['Article has \"author\" property'] = article.hasOwnProperty('author');",
									"        tests['Article has \"favorited\" property'] = article.hasOwnProperty('favorited');",
									"        tests['Article has \"favoritesCount\" property'] = article.hasOwnProperty('favoritesCount');",
									"        tests['favoritesCount is an integer'] = Number.isInteger(article.favoritesCount);",
									"    } else {",
									"        tests['articlesCount is 0 when feed is empty'] = responseJSON.articlesCount === 0;",
									"    }",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles"
							]
						}
					},
					"response": []
				},
				{
					"name": "Articles by Author",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var is200Response = responseCode.code === 200;",
									"",
									"tests['Response code is 200 OK'] = is200Response;",
									"",
									"if(is200Response){",
									"    var responseJSON = JSON.parse(responseBody);",
									"",
									"    tests['Response contains \"articles\" property'] = responseJSON.hasOwnProperty('articles');",
									"    tests['Response contains \"articlesCount\" property'] = responseJSON.hasOwnProperty('articlesCount');",
									"    tests['articlesCount is an integer'] = Number.isInteger(responseJSON.articlesCount);",
									"",
									"    if(responseJSON.articles.length){",
									"        var article = responseJSON.articles[0];",
									"",
									"        tests['Article has \"title\" property'] = article.hasOwnProperty('title');",
									"        tests['Article has \"slug\" property'] = article.hasOwnProperty('slug');",
									"        tests['Article has \"body\" property'] = article.hasOwnProperty('body');",
									"        tests['Article has \"createdAt\" property'] = article.hasOwnProperty('createdAt');",
									"        tests['Article\\'s \"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.createdAt);",
									"        tests['Article has \"updatedAt\" property'] = article.hasOwnProperty('updatedAt');",
									"        tests['Article\\'s \"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.updatedAt);",
									"        tests['Article has \"description\" property'] = article.hasOwnProperty('description');",
									"        tests['Article has \"tagList\" property'] = article.hasOwnProperty('tagList');",
									"        tests['Article\\'s \"tagList\" property is an Array'] = Array.isArray(article.tagList);",
									"        tests['Article has \"author\" property'] = article.hasOwnProperty('author');",
									"        tests['Article has \"favorited\" property'] = article.hasOwnProperty('favorited');",
									"        tests['Article has \"favoritesCount\" property'] = article.hasOwnProperty('favoritesCount');",
									"        tests['favoritesCount is an integer'] = Number.isInteger(article.favoritesCount);",
									"    } else {",
									"        tests['articlesCount is 0 when feed is empty'] = responseJSON.articlesCount === 0;",
									"    }",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles?author=johnny",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles"
							],
							"query": [
								{
									"key": "author",
									"value": "johnny"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Articles Favorited by Username",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var is200Response = responseCode.code === 200;",
									"",
									"tests['Response code is 200 OK'] = is200Response;",
									"",
									"if(is200Response){",
									"    var responseJSON = JSON.parse(responseBody);",
									"    ",
									"    tests['Response contains \"articles\" property'] = responseJSON.hasOwnProperty('articles');",
									"    tests['Response contains \"articlesCount\" property'] = responseJSON.hasOwnProperty('articlesCount');",
									"    tests['articlesCount is an integer'] = Number.isInteger(responseJSON.articlesCount);",
									"",
									"    if(responseJSON.articles.length){",
									"        var article = responseJSON.articles[0];",
									"",
									"        tests['Article has \"title\" property'] = article.hasOwnProperty('title');",
									"        tests['Article has \"slug\" property'] = article.hasOwnProperty('slug');",
									"        tests['Article has \"body\" property'] = article.hasOwnProperty('body');",
									"        tests['Article has \"createdAt\" property'] = article.hasOwnProperty('createdAt');",
									"        tests['Article\\'s \"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.createdAt);",
									"        tests['Article has \"updatedAt\" property'] = article.hasOwnProperty('updatedAt');",
									"        tests['Article\\'s \"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.updatedAt);",
									"        tests['Article has \"description\" property'] = article.hasOwnProperty('description');",
									"        tests['Article has \"tagList\" property'] = article.hasOwnProperty('tagList');",
									"        tests['Article\\'s \"tagList\" property is an Array'] = Array.isArray(article.tagList);",
									"        tests['Article has \"author\" property'] = article.hasOwnProperty('author');",
									"        tests['Article has \"favorited\" property'] = article.hasOwnProperty('favorited');",
									"        tests['Article has \"favoritesCount\" property'] = article.hasOwnProperty('favoritesCount');",
									"        tests['favoritesCount is an integer'] = Number.isInteger(article.favoritesCount);",
									"    } else {",
									"        tests['articlesCount is 0 when feed is empty'] = responseJSON.articlesCount === 0;",
									"    }",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles?favorited={{USERNAME}}",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles"
							],
							"query": [
								{
									"key": "favorited",
									"value": "{{USERNAME}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Articles by Tag",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var is200Response = responseCode.code === 200;",
									"",
									"tests['Response code is 200 OK'] = is200Response;",
									"",
									"if(is200Response){",
									"    var responseJSON = JSON.parse(responseBody);",
									"",
									"    tests['Response contains \"articles\" property'] = responseJSON.hasOwnProperty('articles');",
									"    tests['Response contains \"articlesCount\" property'] = responseJSON.hasOwnProperty('articlesCount');",
									"    tests['articlesCount is an integer'] = Number.isInteger(responseJSON.articlesCount);",
									"",
									"    if(responseJSON.articles.length){",
									"        var article = responseJSON.articles[0];",
									"",
									"        tests['Article has \"title\" property'] = article.hasOwnProperty('title');",
									"        tests['Article has \"slug\" property'] = article.hasOwnProperty('slug');",
									"        tests['Article has \"body\" property'] = article.hasOwnProperty('body');",
									"        tests['Article has \"createdAt\" property'] = article.hasOwnProperty('createdAt');",
									"        tests['Article\\'s \"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.createdAt);",
									"        tests['Article has \"updatedAt\" property'] = article.hasOwnProperty('updatedAt');",
									"        tests['Article\\'s \"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.updatedAt);",
									"        tests['Article has \"description\" property'] = article.hasOwnProperty('description');",
									"        tests['Article has \"tagList\" property'] = article.hasOwnProperty('tagList');",
									"        tests['Article\\'s \"tagList\" property is an Array'] = Array.isArray(article.tagList);",
									"        tests['Article has \"author\" property'] = article.hasOwnProperty('author');",
									"        tests['Article has \"favorited\" property'] = article.hasOwnProperty('favorited');",
									"        tests['Article has \"favoritesCount\" property'] = article.hasOwnProperty('favoritesCount');",
									"        tests['favoritesCount is an integer'] = Number.isInteger(article.favoritesCount);",
									"    } else {",
									"        tests['articlesCount is 0 when feed is empty'] = responseJSON.articlesCount === 0;",
									"    }",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles?tag=dragons",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles"
							],
							"query": [
								{
									"key": "tag",
									"value": "dragons"
								}
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Articles, Favorite, Comments",
			"item": [
				{
					"name": "Create Article",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "e711dbf8-8065-4ba8-8b74-f1639a7d8208",
								"type": "text/javascript",
								"exec": [
									"var responseJSON = JSON.parse(responseBody);",
									"",
									"tests['Response contains \"article\" property'] = responseJSON.hasOwnProperty('article');",
									"",
									"var article = responseJSON.article || {};",
									"",
									"tests['Article has \"title\" property'] = article.hasOwnProperty('title');",
									"tests['Article has \"slug\" property'] = article.hasOwnProperty('slug');",
									"pm.globals.set('slug', article.slug);",
									"",
									"tests['Article has \"body\" property'] = article.hasOwnProperty('body');",
									"tests['Article has \"createdAt\" property'] = article.hasOwnProperty('createdAt');",
									"tests['Article\\'s \"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.createdAt);",
									"tests['Article has \"updatedAt\" property'] = article.hasOwnProperty('updatedAt');",
									"tests['Article\\'s \"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.updatedAt);",
									"tests['Article has \"description\" property'] = article.hasOwnProperty('description');",
									"tests['Article has \"tagList\" property'] = article.hasOwnProperty('tagList');",
									"tests['Article\\'s \"tagList\" property is an Array'] = Array.isArray(article.tagList);",
									"tests['Article has \"author\" property'] = article.hasOwnProperty('author');",
									"tests['Article has \"favorited\" property'] = article.hasOwnProperty('favorited');",
									"tests['Article has \"favoritesCount\" property'] = article.hasOwnProperty('favoritesCount');",
									"tests['favoritesCount is an integer'] = Number.isInteger(article.favoritesCount);",
									""
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\"article\":{\"title\":\"How to train your dragon\", \"description\":\"Ever wonder how?\", \"body\":\"Very carefully.\", \"tagList\":[\"training\", \"dragons\"]}}"
						},
						"url": {
							"raw": "{{APIURL}}/articles",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles"
							]
						}
					},
					"response": []
				},
				{
					"name": "Feed",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var is200Response = responseCode.code === 200;",
									"",
									"tests['Response code is 200 OK'] = is200Response;",
									"",
									"if(is200Response){",
									"    var responseJSON = JSON.parse(responseBody);",
									"",
									"    tests['Response contains \"articles\" property'] = responseJSON.hasOwnProperty('articles');",
									"    tests['Response contains \"articlesCount\" property'] = responseJSON.hasOwnProperty('articlesCount');",
									"    tests['articlesCount is an integer'] = Number.isInteger(responseJSON.articlesCount);",
									"",
									"    if(responseJSON.articles.length){",
									"        var article = responseJSON.articles[0];",
									"",
									"        tests['Article has \"title\" property'] = article.hasOwnProperty('title');",
									"        tests['Article has \"slug\" property'] = article.hasOwnProperty('slug');",
									"        tests['Article has \"body\" property'] = article.hasOwnProperty('body');",
									"        tests['Article has \"createdAt\" property'] = article.hasOwnProperty('createdAt');",
									"        tests['Article\\'s \"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.createdAt);",
									"        tests['Article has \"updatedAt\" property'] = article.hasOwnProperty('updatedAt');",
									"        tests['Article\\'s \"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.updatedAt);",
									"        tests['Article has \"description\" property'] = article.hasOwnProperty('description');",
									"        tests['Article has \"tagList\" property'] = article.hasOwnProperty('tagList');",
									"        tests['Article\\'s \"tagList\" property is an Array'] = Array.isArray(article.tagList);",
									"        tests['Article has \"author\" property'] = article.hasOwnProperty('author');",
									"        tests['Article has \"favorited\" property'] = article.hasOwnProperty('favorited');",
									"        tests['Article has \"favoritesCount\" property'] = article.hasOwnProperty('favoritesCount');",
									"        tests['favoritesCount is an integer'] = Number.isInteger(article.favoritesCount);",
									"    } else {",
									"        tests['articlesCount is 0 when feed is empty'] = responseJSON.articlesCount === 0;",
									"    }",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles/feed",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles",
								"feed"
							]
						}
					},
					"response": []
				},
				{
					"name": "All Articles",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var is200Response = responseCode.code === 200;",
									"",
									"tests['Response code is 200 OK'] = is200Response;",
									"",
									"if(is200Response){",
									"    var responseJSON = JSON.parse(responseBody);",
									"",
									"    tests['Response contains \"articles\" property'] = responseJSON.hasOwnProperty('articles');",
									"    tests['Response contains \"articlesCount\" property'] = responseJSON.hasOwnProperty('articlesCount');",
									"    tests['articlesCount is an integer'] = Number.isInteger(responseJSON.articlesCount);",
									"",
									"    if(responseJSON.articles.length){",
									"        var article = responseJSON.articles[0];",
									"",
									"        tests['Article has \"title\" property'] = article.hasOwnProperty('title');",
									"        tests['Article has \"slug\" property'] = article.hasOwnProperty('slug');",
									"        tests['Article has \"body\" property'] = article.hasOwnProperty('body');",
									"        tests['Article has \"createdAt\" property'] = article.hasOwnProperty('createdAt');",
									"        tests['Article\\'s \"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.createdAt);",
									"        tests['Article has \"updatedAt\" property'] = article.hasOwnProperty('updatedAt');",
									"        tests['Article\\'s \"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.updatedAt);",
									"        tests['Article has \"description\" property'] = article.hasOwnProperty('description');",
									"        tests['Article has \"tagList\" property'] = article.hasOwnProperty('tagList');",
									"        tests['Article\\'s \"tagList\" property is an Array'] = Array.isArray(article.tagList);",
									"        tests['Article has \"author\" property'] = article.hasOwnProperty('author');",
									"        tests['Article has \"favorited\" property'] = article.hasOwnProperty('favorited');",
									"        tests['Article has \"favoritesCount\" property'] = article.hasOwnProperty('favoritesCount');",
									"        tests['favoritesCount is an integer'] = Number.isInteger(article.favoritesCount);",
									"    } else {",
									"        tests['articlesCount is 0 when feed is empty'] = responseJSON.articlesCount === 0;",
									"    }",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles"
							]
						}
					},
					"response": []
				},
				{
					"name": "All Articles with auth",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var is200Response = responseCode.code === 200;",
									"",
									"tests['Response code is 200 OK'] = is200Response;",
									"",
									"if(is200Response){",
									"    var responseJSON = JSON.parse(responseBody);",
									"",
									"    tests['Response contains \"articles\" property'] = responseJSON.hasOwnProperty('articles');",
									"    tests['Response contains \"articlesCount\" property'] = responseJSON.hasOwnProperty('articlesCount');",
									"    tests['articlesCount is an integer'] = Number.isInteger(responseJSON.articlesCount);",
									"",
									"    if(responseJSON.articles.length){",
									"        var article = responseJSON.articles[0];",
									"",
									"        tests['Article has \"title\" property'] = article.hasOwnProperty('title');",
									"        tests['Article has \"slug\" property'] = article.hasOwnProperty('slug');",
									"        tests['Article has \"body\" property'] = article.hasOwnProperty('body');",
									"        tests['Article has \"createdAt\" property'] = article.hasOwnProperty('createdAt');",
									"        tests['Article\\'s \"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.createdAt);",
									"        tests['Article has \"updatedAt\" property'] = article.hasOwnProperty('updatedAt');",
									"        tests['Article\\'s \"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.updatedAt);",
									"        tests['Article has \"description\" property'] = article.hasOwnProperty('description');",
									"        tests['Article has \"tagList\" property'] = article.hasOwnProperty('tagList');",
									"        tests['Article\\'s \"tagList\" property is an Array'] = Array.isArray(article.tagList);",
									"        tests['Article has \"author\" property'] = article.hasOwnProperty('author');",
									"        tests['Article has \"favorited\" property'] = article.hasOwnProperty('favorited');",
									"        tests['Article has \"favoritesCount\" property'] = article.hasOwnProperty('favoritesCount');",
									"        tests['favoritesCount is an integer'] = Number.isInteger(article.favoritesCount);",
									"    } else {",
									"        tests['articlesCount is 0 when feed is empty'] = responseJSON.articlesCount === 0;",
									"    }",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles"
							]
						}
					},
					"response": []
				},
				{
					"name": "Articles by Author",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var is200Response = responseCode.code === 200;",
									"",
									"tests['Response code is 200 OK'] = is200Response;",
									"",
									"if(is200Response){",
									"    var responseJSON = JSON.parse(responseBody);",
									"",
									"    tests['Response contains \"articles\" property'] = responseJSON.hasOwnProperty('articles');",
									"    tests['Response contains \"articlesCount\" property'] = responseJSON.hasOwnProperty('articlesCount');",
									"    tests['articlesCount is an integer'] = Number.isInteger(responseJSON.articlesCount);",
									"",
									"    if(responseJSON.articles.length){",
									"        var article = responseJSON.articles[0];",
									"",
									"        tests['Article has \"title\" property'] = article.hasOwnProperty('title');",
									"        tests['Article has \"slug\" property'] = article.hasOwnProperty('slug');",
									"        tests['Article has \"body\" property'] = article.hasOwnProperty('body');",
									"        tests['Article has \"createdAt\" property'] = article.hasOwnProperty('createdAt');",
									"        tests['Article\\'s \"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.createdAt);",
									"        tests['Article has \"updatedAt\" property'] = article.hasOwnProperty('updatedAt');",
									"        tests['Article\\'s \"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.updatedAt);",
									"        tests['Article has \"description\" property'] = article.hasOwnProperty('description');",
									"        tests['Article has \"tagList\" property'] = article.hasOwnProperty('tagList');",
									"        tests['Article\\'s \"tagList\" property is an Array'] = Array.isArray(article.tagList);",
									"        tests['Article has \"author\" property'] = article.hasOwnProperty('author');",
									"        tests['Article has \"favorited\" property'] = article.hasOwnProperty('favorited');",
									"        tests['Article has \"favoritesCount\" property'] = article.hasOwnProperty('favoritesCount');",
									"        tests['favoritesCount is an integer'] = Number.isInteger(article.favoritesCount);",
									"    } else {",
									"        tests['articlesCount is 0 when feed is empty'] = responseJSON.articlesCount === 0;",
									"    }",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles?author={{USERNAME}}",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles"
							],
							"query": [
								{
									"key": "author",
									"value": "{{USERNAME}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Articles by Author with auth",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var is200Response = responseCode.code === 200;",
									"",
									"tests['Response code is 200 OK'] = is200Response;",
									"",
									"if(is200Response){",
									"    var responseJSON = JSON.parse(responseBody);",
									"",
									"    tests['Response contains \"articles\" property'] = responseJSON.hasOwnProperty('articles');",
									"    tests['Response contains \"articlesCount\" property'] = responseJSON.hasOwnProperty('articlesCount');",
									"    tests['articlesCount is an integer'] = Number.isInteger(responseJSON.articlesCount);",
									"",
									"    if(responseJSON.articles.length){",
									"        var article = responseJSON.articles[0];",
									"",
									"        tests['Article has \"title\" property'] = article.hasOwnProperty('title');",
									"        tests['Article has \"slug\" property'] = article.hasOwnProperty('slug');",
									"        tests['Article has \"body\" property'] = article.hasOwnProperty('body');",
									"        tests['Article has \"createdAt\" property'] = article.hasOwnProperty('createdAt');",
									"        tests['Article\\'s \"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.createdAt);",
									"        tests['Article has \"updatedAt\" property'] = article.hasOwnProperty('updatedAt');",
									"        tests['Article\\'s \"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.updatedAt);",
									"        tests['Article has \"description\" property'] = article.hasOwnProperty('description');",
									"        tests['Article has \"tagList\" property'] = article.hasOwnProperty('tagList');",
									"        tests['Article\\'s \"tagList\" property is an Array'] = Array.isArray(article.tagList);",
									"        tests['Article has \"author\" property'] = article.hasOwnProperty('author');",
									"        tests['Article has \"favorited\" property'] = article.hasOwnProperty('favorited');",
									"        tests['Article has \"favoritesCount\" property'] = article.hasOwnProperty('favoritesCount');",
									"        tests['favoritesCount is an integer'] = Number.isInteger(article.favoritesCount);",
									"    } else {",
									"        tests['articlesCount is 0 when feed is empty'] = responseJSON.articlesCount === 0;",
									"    }",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles?author={{USERNAME}}",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles"
							],
							"query": [
								{
									"key": "author",
									"value": "{{USERNAME}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Single Article by slug",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var responseJSON = JSON.parse(responseBody);",
									"",
									"tests['Response contains \"article\" property'] = responseJSON.hasOwnProperty('article');",
									"",
									"var article = responseJSON.article || {};",
									"",
									"tests['Article has \"title\" property'] = article.hasOwnProperty('title');",
									"tests['Article has \"slug\" property'] = article.hasOwnProperty('slug');",
									"tests['Article has \"body\" property'] = article.hasOwnProperty('body');",
									"tests['Article has \"createdAt\" property'] = article.hasOwnProperty('createdAt');",
									"tests['Article\\'s \"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.createdAt);",
									"tests['Article has \"updatedAt\" property'] = article.hasOwnProperty('updatedAt');",
									"tests['Article\\'s \"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.updatedAt);",
									"tests['Article has \"description\" property'] = article.hasOwnProperty('description');",
									"tests['Article has \"tagList\" property'] = article.hasOwnProperty('tagList');",
									"tests['Article\\'s \"tagList\" property is an Array'] = Array.isArray(article.tagList);",
									"tests['Article has \"author\" property'] = article.hasOwnProperty('author');",
									"tests['Article has \"favorited\" property'] = article.hasOwnProperty('favorited');",
									"tests['Article has \"favoritesCount\" property'] = article.hasOwnProperty('favoritesCount');",
									"tests['favoritesCount is an integer'] = Number.isInteger(article.favoritesCount);",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles/{{slug}}",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles",
								"{{slug}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Articles by Tag",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var is200Response = responseCode.code === 200;",
									"",
									"tests['Response code is 200 OK'] = is200Response;",
									"",
									"if(is200Response){",
									"    var responseJSON = JSON.parse(responseBody);",
									"    tests['Response contains \"articles\" property'] = responseJSON.hasOwnProperty('articles');",
									"    tests['Response contains \"articlesCount\" property'] = responseJSON.hasOwnProperty('articlesCount');",
									"    tests['articlesCount is an integer'] = Number.isInteger(responseJSON.articlesCount);",
									"    var article = responseJSON.articles[0];",
									"    tests['An article was returned'] = article !== undefined;",
									"    tests['Article has \"title\" property'] = article.hasOwnProperty('title');",
									"    tests['Article has \"slug\" property'] = article.hasOwnProperty('slug');",
									"    tests['Article has \"body\" property'] = article.hasOwnProperty('body');",
									"    tests['Article has \"createdAt\" property'] = article.hasOwnProperty('createdAt');",
									"    tests['Article\\'s \"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.createdAt);",
									"    tests['Article has \"updatedAt\" property'] = article.hasOwnProperty('updatedAt');",
									"    tests['Article\\'s \"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.updatedAt);",
									"    tests['Article has \"description\" property'] = article.hasOwnProperty('description');",
									"    tests['Article has \"tagList\" property'] = article.hasOwnProperty('tagList');",
									"    tests['Article\\'s \"tagList\" property is an Array'] = Array.isArray(article.tagList);",
									"    tests['The first tag is dragons'] = article.tagList[0] === 'dragons';",
									"    tests['The second tag is training'] = article.tagList[1] === 'training';",
									"    tests['Article has \"author\" property'] = article.hasOwnProperty('author');",
									"    tests['Article has \"favorited\" property'] = article.hasOwnProperty('favorited');",
									"    tests['Article has \"favoritesCount\" property'] = article.hasOwnProperty('favoritesCount');",
									"    tests['favoritesCount is an integer'] = Number.isInteger(article.favoritesCount);",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles?tag=dragons",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles"
							],
							"query": [
								{
									"key": "tag",
									"value": "dragons"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Update Article",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"if (!(environment.isIntegrationTest)) {",
									"var responseJSON = JSON.parse(responseBody);",
									"",
									"tests['Response contains \"article\" property'] = responseJSON.hasOwnProperty('article');",
									"",
									"var article = responseJSON.article || {};",
									"",
									"tests['Article has \"title\" property'] = article.hasOwnProperty('title');",
									"tests['Article has \"slug\" property'] = article.hasOwnProperty('slug');",
									"tests['Article has \"body\" property'] = article.hasOwnProperty('body');",
									"tests['Article has \"createdAt\" property'] = article.hasOwnProperty('createdAt');",
									"tests['Article\\'s \"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.createdAt);",
									"tests['Article has \"updatedAt\" property'] = article.hasOwnProperty('updatedAt');",
									"tests['Article\\'s \"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.updatedAt);",
									"tests['Article has \"description\" property'] = article.hasOwnProperty('description');",
									"tests['Article has \"tagList\" property'] = article.hasOwnProperty('tagList');",
									"tests['Article\\'s \"tagList\" property is an Array'] = Array.isArray(article.tagList);",
									"tests['Article has \"author\" property'] = article.hasOwnProperty('author');",
									"tests['Article has \"favorited\" property'] = article.hasOwnProperty('favorited');",
									"tests['Article has \"favoritesCount\" property'] = article.hasOwnProperty('favoritesCount');",
									"tests['favoritesCount is an integer'] = Number.isInteger(article.favoritesCount);",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\"article\":{\"body\":\"With two hands\"}}"
						},
						"url": {
							"raw": "{{APIURL}}/articles/{{slug}}",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles",
								"{{slug}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Favorite Article",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var responseJSON = JSON.parse(responseBody);",
									"",
									"tests['Response contains \"article\" property'] = responseJSON.hasOwnProperty('article');",
									"",
									"var article = responseJSON.article || {};",
									"",
									"tests['Article has \"title\" property'] = article.hasOwnProperty('title');",
									"tests['Article has \"slug\" property'] = article.hasOwnProperty('slug');",
									"tests['Article has \"body\" property'] = article.hasOwnProperty('body');",
									"tests['Article has \"createdAt\" property'] = article.hasOwnProperty('createdAt');",
									"tests['Article\\'s \"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.createdAt);",
									"tests['Article has \"updatedAt\" property'] = article.hasOwnProperty('updatedAt');",
									"tests['Article\\'s \"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.updatedAt);",
									"tests['Article has \"description\" property'] = article.hasOwnProperty('description');",
									"tests['Article has \"tagList\" property'] = article.hasOwnProperty('tagList');",
									"tests['Article\\'s \"tagList\" property is an Array'] = Array.isArray(article.tagList);",
									"tests['Article has \"author\" property'] = article.hasOwnProperty('author');",
									"tests['Article has \"favorited\" property'] = article.hasOwnProperty('favorited');",
									"tests[\"Article's 'favorited' property is true\"] = article.favorited === true;",
									"tests['Article has \"favoritesCount\" property'] = article.hasOwnProperty('favoritesCount');",
									"tests['favoritesCount is an integer'] = Number.isInteger(article.favoritesCount);",
									"tests[\"Article's 'favoritesCount' property is greater than 0\"] = article.favoritesCount > 0;",
									""
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles/{{slug}}/favorite",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles",
								"{{slug}}",
								"favorite"
							]
						}
					},
					"response": []
				},
				{
					"name": "Articles Favorited by Username",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var is200Response = responseCode.code === 200;",
									"",
									"tests['Response code is 200 OK'] = is200Response;",
									"",
									"if(is200Response){",
									"    var responseJSON = JSON.parse(responseBody);",
									"    article = responseJSON.articles[0];",
									"    tests['Response contains \"articles\" property'] = responseJSON.hasOwnProperty('articles');",
									"    tests['Response contains \"articlesCount\" property'] = responseJSON.hasOwnProperty('articlesCount');",
									"    tests['articlesCount is an integer'] = Number.isInteger(responseJSON.articlesCount);",
									"    tests['Article has \"title\" property'] = article.hasOwnProperty('title');",
									"    tests['Article has \"slug\" property'] = article.hasOwnProperty('slug');",
									"    tests['Article has \"body\" property'] = article.hasOwnProperty('body');",
									"    tests['Article has \"createdAt\" property'] = article.hasOwnProperty('createdAt');",
									"    tests['Article\\'s \"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.createdAt);",
									"    tests['Article has \"updatedAt\" property'] = article.hasOwnProperty('updatedAt');",
									"    tests['Article\\'s \"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.updatedAt);",
									"    tests['Article has \"description\" property'] = article.hasOwnProperty('description');",
									"    tests['Article has \"tagList\" property'] = article.hasOwnProperty('tagList');",
									"    tests['Article\\'s \"tagList\" property is an Array'] = Array.isArray(article.tagList);",
									"    tests['Article has \"author\" property'] = article.hasOwnProperty('author');",
									"    tests['Article has \"favorited\" property'] = article.hasOwnProperty('favorited');",
									"    tests['Article has \"favoritesCount\" property'] = article.hasOwnProperty('favoritesCount');",
									"    tests['favoritesCount is 1'] = article.favoritesCount === 1;",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles?favorited={{USERNAME}}",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles"
							],
							"query": [
								{
									"key": "favorited",
									"value": "{{USERNAME}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Articles Favorited by Username with auth",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var is200Response = responseCode.code === 200;",
									"",
									"tests['Response code is 200 OK'] = is200Response;",
									"",
									"if(is200Response){",
									"    var responseJSON = JSON.parse(responseBody);",
									"    article = responseJSON.articles[0];",
									"    tests['Response contains \"articles\" property'] = responseJSON.hasOwnProperty('articles');",
									"    tests['Response contains \"articlesCount\" property'] = responseJSON.hasOwnProperty('articlesCount');",
									"    tests['articlesCount is an integer'] = Number.isInteger(responseJSON.articlesCount);",
									"    tests['Article has \"title\" property'] = article.hasOwnProperty('title');",
									"    tests['Article has \"slug\" property'] = article.hasOwnProperty('slug');",
									"    tests['Article has \"body\" property'] = article.hasOwnProperty('body');",
									"    tests['Article has \"createdAt\" property'] = article.hasOwnProperty('createdAt');",
									"    tests['Article\\'s \"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.createdAt);",
									"    tests['Article has \"updatedAt\" property'] = article.hasOwnProperty('updatedAt');",
									"    tests['Article\\'s \"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.updatedAt);",
									"    tests['Article has \"description\" property'] = article.hasOwnProperty('description');",
									"    tests['Article has \"tagList\" property'] = article.hasOwnProperty('tagList');",
									"    tests['Article\\'s \"tagList\" property is an Array'] = Array.isArray(article.tagList);",
									"    tests['Article has \"author\" property'] = article.hasOwnProperty('author');",
									"    tests['Article has \"favorited\" property'] = article.hasOwnProperty('favorited');",
									"    tests['Article has \"favoritesCount\" property'] = article.hasOwnProperty('favoritesCount');",
									"    tests['favoritesCount is 1'] = article.favoritesCount === 1;",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles?favorited={{USERNAME}}",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles"
							],
							"query": [
								{
									"key": "favorited",
									"value": "{{USERNAME}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Unfavorite Article",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var responseJSON = JSON.parse(responseBody);",
									"",
									"tests['Response contains \"article\" property'] = responseJSON.hasOwnProperty('article');",
									"",
									"var article = responseJSON.article || {};",
									"",
									"tests['Article has \"title\" property'] = article.hasOwnProperty('title');",
									"tests['Article has \"slug\" property'] = article.hasOwnProperty('slug');",
									"tests['Article has \"body\" property'] = article.hasOwnProperty('body');",
									"tests['Article has \"createdAt\" property'] = article.hasOwnProperty('createdAt');",
									"tests['Article\\'s \"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.createdAt);",
									"tests['Article has \"updatedAt\" property'] = article.hasOwnProperty('updatedAt');",
									"tests['Article\\'s \"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(article.updatedAt);",
									"tests['Article has \"description\" property'] = article.hasOwnProperty('description');",
									"tests['Article has \"tagList\" property'] = article.hasOwnProperty('tagList');",
									"tests['Article\\'s \"tagList\" property is an Array'] = Array.isArray(article.tagList);",
									"tests['Article has \"author\" property'] = article.hasOwnProperty('author');",
									"tests['Article has \"favorited\" property'] = article.hasOwnProperty('favorited');",
									"tests['Article has \"favoritesCount\" property'] = article.hasOwnProperty('favoritesCount');",
									"tests['favoritesCount is an integer'] = Number.isInteger(article.favoritesCount);",
									"tests[\"Article's \\\"favorited\\\" property is false\"] = article.favorited === false;",
									""
								]
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles/{{slug}}/favorite",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles",
								"{{slug}}",
								"favorite"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Comment for Article",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "9f90c364-cc68-4728-961a-85eb00197d7b",
								"type": "text/javascript",
								"exec": [
									"var responseJSON = JSON.parse(responseBody);",
									"",
									"tests['Response contains \"comment\" property'] = responseJSON.hasOwnProperty('comment');",
									"",
									"var comment = responseJSON.comment || {};",
									"",
									"tests['Comment has \"id\" property'] = comment.hasOwnProperty('id');",
									"pm.globals.set('commentId', comment.id);",
									"",
									"tests['Comment has \"body\" property'] = comment.hasOwnProperty('body');",
									"tests['Comment has \"createdAt\" property'] = comment.hasOwnProperty('createdAt');",
									"tests['\"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(comment.createdAt);",
									"tests['Comment has \"updatedAt\" property'] = comment.hasOwnProperty('updatedAt');",
									"tests['\"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(comment.updatedAt);",
									"tests['Comment has \"author\" property'] = comment.hasOwnProperty('author');",
									""
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\"comment\":{\"body\":\"Thank you so much!\"}}"
						},
						"url": {
							"raw": "{{APIURL}}/articles/{{slug}}/comments",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles",
								"{{slug}}",
								"comments"
							]
						}
					},
					"response": []
				},
				{
					"name": "All Comments for Article",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var is200Response = responseCode.code === 200",
									"",
									"tests['Response code is 200 OK'] = is200Response;",
									"",
									"if(is200Response){",
									"    var responseJSON = JSON.parse(responseBody);",
									"",
									"    tests['Response contains \"comments\" property'] = responseJSON.hasOwnProperty('comments');",
									"",
									"    if(responseJSON.comments.length){",
									"        var comment = responseJSON.comments[0];",
									"",
									"        tests['Comment has \"id\" property'] = comment.hasOwnProperty('id');",
									"        tests['Comment has \"body\" property'] = comment.hasOwnProperty('body');",
									"        tests['Comment has \"createdAt\" property'] = comment.hasOwnProperty('createdAt');",
									"        tests['\"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(comment.createdAt);",
									"        tests['Comment has \"updatedAt\" property'] = comment.hasOwnProperty('updatedAt');",
									"        tests['\"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(comment.updatedAt);",
									"        tests['Comment has \"author\" property'] = comment.hasOwnProperty('author');",
									"    }",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles/{{slug}}/comments",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles",
								"{{slug}}",
								"comments"
							]
						}
					},
					"response": []
				},
				{
					"name": "All Comments for Article without login",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var is200Response = responseCode.code === 200",
									"",
									"tests['Response code is 200 OK'] = is200Response;",
									"",
									"if(is200Response){",
									"    var responseJSON = JSON.parse(responseBody);",
									"",
									"    tests['Response contains \"comments\" property'] = responseJSON.hasOwnProperty('comments');",
									"",
									"    if(responseJSON.comments.length){",
									"        var comment = responseJSON.comments[0];",
									"",
									"        tests['Comment has \"id\" property'] = comment.hasOwnProperty('id');",
									"        tests['Comment has \"body\" property'] = comment.hasOwnProperty('body');",
									"        tests['Comment has \"createdAt\" property'] = comment.hasOwnProperty('createdAt');",
									"        tests['\"createdAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(comment.createdAt);",
									"        tests['Comment has \"updatedAt\" property'] = comment.hasOwnProperty('updatedAt');",
									"        tests['\"updatedAt\" property is an ISO 8601 timestamp'] = /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/.test(comment.updatedAt);",
									"        tests['Comment has \"author\" property'] = comment.hasOwnProperty('author');",
									"    }",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles/{{slug}}/comments",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles",
								"{{slug}}",
								"comments"
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete Comment for Article",
					"request": {
						"method": "DELETE",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles/{{slug}}/comments/{{commentId}}",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles",
								"{{slug}}",
								"comments",
								"{{commentId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete Article",
					"request": {
						"method": "DELETE",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/articles/{{slug}}",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"articles",
								"{{slug}}"
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"id": "67853a4a-e972-4573-a295-dad12a46a9d7",
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"id": "3057f989-15e4-484e-b8fa-a041043d0ac0",
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Profiles",
			"item": [
				{
					"name": "Register Celeb",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"if (!(environment.isIntegrationTest)) {",
									"var responseJSON = JSON.parse(responseBody);",
									"",
									"tests['Response contains \"user\" property'] = responseJSON.hasOwnProperty('user');",
									"",
									"var user = responseJSON.user || {};",
									"",
									"tests['User has \"email\" property'] = user.hasOwnProperty('email');",
									"tests['User has \"username\" property'] = user.hasOwnProperty('username');",
									"tests['User has \"bio\" property'] = user.hasOwnProperty('bio');",
									"tests['User has \"image\" property'] = user.hasOwnProperty('image');",
									"tests['User has \"token\" property'] = user.hasOwnProperty('token');",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\"user\":{\"email\":\"celeb_{{EMAIL}}\", \"password\":\"{{PASSWORD}}\", \"username\":\"celeb_{{USERNAME}}\"}}"
						},
						"url": {
							"raw": "{{APIURL}}/users",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"users"
							]
						}
					},
					"response": []
				},
				{
					"name": "Profile",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"if (!(environment.isIntegrationTest)) {",
									"var is200Response = responseCode.code === 200;",
									"",
									"tests['Response code is 200 OK'] = is200Response;",
									"",
									"if(is200Response){",
									"    var responseJSON = JSON.parse(responseBody);",
									"",
									"    tests['Response contains \"profile\" property'] = responseJSON.hasOwnProperty('profile');",
									"    ",
									"    var profile = responseJSON.profile || {};",
									"    ",
									"    tests['Profile has \"username\" property'] = profile.hasOwnProperty('username');",
									"    tests['Profile has \"bio\" property'] = profile.hasOwnProperty('bio');",
									"    tests['Profile has \"image\" property'] = profile.hasOwnProperty('image');",
									"    tests['Profile has \"following\" property'] = profile.hasOwnProperty('following');",
									"}",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/profiles/celeb_{{USERNAME}}",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"profiles",
								"celeb_{{USERNAME}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Follow Profile",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"if (!(environment.isIntegrationTest)) {",
									"var is200Response = responseCode.code === 200;",
									"",
									"tests['Response code is 200 OK'] = is200Response;",
									"",
									"if(is200Response){",
									"    var responseJSON = JSON.parse(responseBody);",
									"",
									"    tests['Response contains \"profile\" property'] = responseJSON.hasOwnProperty('profile');",
									"    ",
									"    var profile = responseJSON.profile || {};",
									"    ",
									"    tests['Profile has \"username\" property'] = profile.hasOwnProperty('username');",
									"    tests['Profile has \"bio\" property'] = profile.hasOwnProperty('bio');",
									"    tests['Profile has \"image\" property'] = profile.hasOwnProperty('image');",
									"    tests['Profile has \"following\" property'] = profile.hasOwnProperty('following');",
									"    tests['Profile\\'s \"following\" property is true'] = profile.following === true;",
									"}",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\"user\":{\"email\":\"{{EMAIL}}\"}}"
						},
						"url": {
							"raw": "{{APIURL}}/profiles/celeb_{{USERNAME}}/follow",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"profiles",
								"celeb_{{USERNAME}}",
								"follow"
							]
						}
					},
					"response": []
				},
				{
					"name": "Unfollow Profile",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"if (!(environment.isIntegrationTest)) {",
									"var is200Response = responseCode.code === 200;",
									"",
									"tests['Response code is 200 OK'] = is200Response;",
									"",
									"if(is200Response){",
									"    var responseJSON = JSON.parse(responseBody);",
									"",
									"    tests['Response contains \"profile\" property'] = responseJSON.hasOwnProperty('profile');",
									"    ",
									"    var profile = responseJSON.profile || {};",
									"    ",
									"    tests['Profile has \"username\" property'] = profile.hasOwnProperty('username');",
									"    tests['Profile has \"bio\" property'] = profile.hasOwnProperty('bio');",
									"    tests['Profile has \"image\" property'] = profile.hasOwnProperty('image');",
									"    tests['Profile has \"following\" property'] = profile.hasOwnProperty('following');",
									"    tests['Profile\\'s \"following\" property is false'] = profile.following === false;",
									"}",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{token}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/profiles/celeb_{{USERNAME}}/follow",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"profiles",
								"celeb_{{USERNAME}}",
								"follow"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Tags",
			"item": [
				{
					"name": "All Tags",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var is200Response = responseCode.code === 200;",
									"",
									"tests['Response code is 200 OK'] = is200Response;",
									"",
									"if(is200Response){",
									"    var responseJSON = JSON.parse(responseBody);",
									"    ",
									"    tests['Response contains \"tags\" property'] = responseJSON.hasOwnProperty('tags');",
									"    tests['\"tags\" property returned as array'] = Array.isArray(responseJSON.tags);",
									"}",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Requested-With",
								"value": "XMLHttpRequest"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{APIURL}}/tags",
							"host": [
								"{{APIURL}}"
							],
							"path": [
								"tags"
							]
						}
					},
					"response": []
				}
			]
		}
	]
}

================
File: tests/integration/testing-environment.json
================
{
	"values": [
		{
			"key": "APIURL",
			"value": "http://127.0.0.1:3100/api",
			"type": "text"
		},
		{
			"key": "EMAIL",
			"value": "admin@conduit.com",
			"type": "text"
		},
		{
			"key": "PASSWORD",
			"value": "abc123",
			"type": "text"
		},
		{
			"key": "USERNAME",
			"value": "conduit",
			"type": "text"
		}
	]
}

================
File: turbo.json
================
{
  "$schema": "https://turbo.build/schema.json",
  "globalEnv": [
    "NODE_ENV"
  ],
  "cacheDir": ".turbo/cache",
  "tasks": {
    "test": {
      "dependsOn": [
        "^test"
      ]
    },
    "test:coverage": {
      "dependsOn": [
        "^test:coverage"
      ]
    },
    "db:migrate": {
      "outputLogs": "full",
      "dependsOn": [
        "^db:migrate"
      ]
    },
    "deploy": {
      "dependsOn": [
        "^deploy"
      ],
      "cache": false
    },
    "lint": {
      "dependsOn": [
        "^lint"
      ]
    },
    "lint:fix": {
      "dependsOn": [
        "^lint:fix"
      ]
    },
    "build": {
      "outputLogs": "full",
      "dependsOn": [
        "^build"
      ]
    },
    "check-types": {
      "dependsOn": [
        "^check-types"
      ]
    },
    "prettify": {
      "dependsOn": [
        "^prettify"
      ]
    },
    "dev": {
      "persistent": true,
      "cache": false
    },
    "start": {
      "persistent": true,
      "cache": false
    },
    "start:ci": {
      "persistent": true,
      "cache": false
    }
  }
}
